<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>声明、类型、语句与控制结构 - Kurisu&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kurisu&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kurisu&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用一致的变量声明形式 变量声明形式的选择上应尽量保持项目范围内一致。 Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。 就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用"><meta property="og:type" content="blog"><meta property="og:title" content="声明、类型、语句与控制结构"><meta property="og:url" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="Kurisu&#039;s Blog"><meta property="og:description" content="使用一致的变量声明形式 变量声明形式的选择上应尽量保持项目范围内一致。 Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。 就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115213038800.png"><meta property="article:published_time" content="2022-11-15T12:17:37.000Z"><meta property="article:modified_time" content="2022-11-15T13:33:20.181Z"><meta property="article:author" content="Kurisu"><meta property="article:tag" content="Go"><meta property="article:tag" content="Go语言精进之路"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},"headline":"声明、类型、语句与控制结构","image":["https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png","https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115213038800.png"],"datePublished":"2022-11-15T12:17:37.000Z","dateModified":"2022-11-15T13:33:20.181Z","author":{"@type":"Person","name":"Kurisu"},"publisher":{"@type":"Organization","name":"Kurisu's Blog","logo":{"@type":"ImageObject","url":"https://mrcq.github.io/img/logo.svg"}},"description":"使用一致的变量声明形式 变量声明形式的选择上应尽量保持项目范围内一致。 Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。 就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用"}</script><link rel="canonical" href="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto Serif Simplified Chinese:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ed68212360e83c07d191372605274f6e";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="D5E963705D472839D42E0AC1C65D96AB"><script src="https://www.googletagmanager.com/gtag/js?id=G-X1YWL675NS" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-X1YWL675NS');</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Kurisu&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>声明、类型、语句与控制结构</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2022-11-15T12:17:37.000Z" title="2022-11-15T12:17:37.000Z">2022-11-15</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-11-15T13:33:20.181Z" title="2022-11-15T13:33:20.181Z">2022-11-15</time></span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span><span class="level-item">22 分钟读完 (大约3284个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><h2 id="使用一致的变量声明形式"><a href="#使用一致的变量声明形式" class="headerlink" title="使用一致的变量声明形式"></a>使用一致的变量声明形式</h2><ul>
<li>变量声明形式的选择上应尽量保持项目范围内一致。</li>
<li>Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。</li>
<li>就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合。</li>
<li>包级变量，只能使用 var 关键字的变量声明方式。</li>
<li>尽量在分支控制时应用短变量声明形式。<span id="more"></span></li>
</ul>
<p><img src="/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png"></p>
<h2 id="使用无类型常量简化代码"><a href="#使用无类型常量简化代码" class="headerlink" title="使用无类型常量简化代码"></a>使用无类型常量简化代码</h2><ul>
<li>Go是对类型安全要求十分严格的编程语言。Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算。有类型常量给代码简化带来了麻烦，但这也是Go语言对类型安全严格要求的结果。</li>
<li>无类型常量也拥有自己的默认类型：无类型的布尔型常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对应的默认类型分别为bool、int、int32(rune)、float64、complex128和string。</li>
<li>所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。当操作数是常量时，在编译时也能发现一些运行时的错误，例如整数除零、字符串索引越界等。</li>
<li>无类型常量是Go语言推荐的实践，它拥有和字面值一样的灵活特性，可以直接用于更多的表达式而不需要进行显式类型转换，从而简化了代码编写。此外，按照Go官方语言规范的描述，数值型无类型常量可以提供比基础类型更高精度的算术运算，至少有256 bit的运算精度。</li>
</ul>
<h2 id="使用iota实现枚举常量"><a href="#使用iota实现枚举常量" class="headerlink" title="使用iota实现枚举常量"></a>使用iota实现枚举常量</h2><ul>
<li><p>Go的const语法提供了“隐式重复前一个非空表达式”的机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape</span><br><span class="line">    Pear, Watermelon</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>常量定义的后两行没有显式给予初始赋值，Go编译器将为其隐式使用第一行的表达式，这样上述定义等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Pear, Watermelon  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>iota是Go语言的一个预定义标识符，它表示的是const声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的iota自身也是一个无类型常量，可以像无类型常量那样自动参与不同类型的求值过程，而无须对其进行显式类型转换操作。</p>
</li>
<li><p>Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PI   = <span class="number">3.1415926</span>              <span class="comment">// π</span></span><br><span class="line">    PI_2 = <span class="number">3.1415926</span> / (<span class="number">2</span> * <span class="literal">iota</span>) <span class="comment">// π/2</span></span><br><span class="line">    PI_4                          <span class="comment">// π/4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>使用有类型枚举常量保证类型安全:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/time/time.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="尽量定义零值可用的类型"><a href="#尽量定义零值可用的类型" class="headerlink" title="尽量定义零值可用的类型"></a>尽量定义零值可用的类型</h2><ul>
<li><p>当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值。</p>
</li>
<li><p>Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）。</p>
<p>所有整型类型：0</p>
<p>浮点类型：0.0</p>
<p>布尔类型：false</p>
<p>字符串类型：””</p>
<p>指针、interface、切片（slice）、channel、map、function：nil</p>
<p>另外，Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</p>
</li>
<li><p>Go中的切片类型具备零值可用的特性，我们可以直接对其进行append操作，而不会出现引用nil的错误。</p>
</li>
<li><p>Go标准库的设计者很贴心地将sync.Mutex结构体的零值设计为可用状态，让Mutex的调用者可以省略对Mutex的初始化而直接使用Mutex。</p>
</li>
<li><p>Go语言零值可用的理念给内置类型、标准库的使用者带来很多便利。不过Go并非所有类型都是零值可用的，并且零值可用也有一定的限制，比如：在append场景下，零值可用的切片类型不能通过下标形式操作数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">12</span>         <span class="comment">// 报错！</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>另外，像map这样的原生类型也没有提供对零值可用的支持：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;go&quot;</span>] = <span class="number">1</span> <span class="comment">// 报错！</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m1[<span class="string">&quot;go&quot;</span>] = <span class="number">1</span> <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>另外零值可用的类型要注意尽量避免值复制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu1 := mu <span class="comment">// 错误: 避免值复制</span></span><br><span class="line">foo(mu) <span class="comment">// 错误: 避免值复制</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过指针方式传递类似Mutex这样的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">foo(&amp;mu) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
<li><p>保持与Go一致的理念，给自定义的类型一个合理的零值，并尽量保持自定义类型的零值可用，这样我们的Go代码会更加符合Go语言的惯用法。</p>
</li>
</ul>
<h2 id="使用复合字面值作为初值构造器"><a href="#使用复合字面值作为初值构造器" class="headerlink" title="使用复合字面值作为初值构造器"></a>使用复合字面值作为初值构造器</h2><ul>
<li><p>Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;<span class="string">&quot;tony&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;</span><br><span class="line">sl := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> &#123;<span class="number">1</span>:<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>:<span class="string">&quot;gopher&quot;</span>, <span class="number">3</span>:<span class="string">&quot;!&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>field:value形式的复合字面值初值构造器与普通复合字面值形式不同，field:value形式字面值中的字段可以以任意次序出现，未显式出现在字面值的结构体中的字段将采用其对应类型的零值。</p>
</li>
<li><p>复合字面值作为结构体值构造器的大量使用，使得即便采用类型零值时我们也会使用字面值构造器形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;&#125; <span class="comment">// 常用</span></span><br><span class="line">s := <span class="built_in">new</span>(myStruct) <span class="comment">// 较少使用</span></span><br></pre></td></tr></table></figure></li>
<li><p>不允许将从其他包导入的结构体中的未导出字段作为复合字面值中的field，这会导致编译错误。</p>
</li>
<li><p>对于数组/切片类型而言，当元素为复合类型时，可以省去元素复合字面量中的类型，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">float64</span></span><br><span class="line">    y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sl := []Point&#123;</span><br><span class="line">    &#123;<span class="number">1.2345</span>, <span class="number">6.2789</span>&#125;, <span class="comment">// Point&#123;1.2345, 6.2789&#125;</span></span><br><span class="line">    &#123;<span class="number">2.2345</span>, <span class="number">19.2789</span>&#125;, <span class="comment">// Point&#123;2.2345, 19.2789&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于key或value为指针类型的情况，也可以省略“&amp;T”：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]*Point&#123;</span><br><span class="line">    <span class="string">&quot;Persepolis&quot;</span>: &#123;<span class="number">29.935523</span>, <span class="number">52.891566</span>&#125;,   <span class="comment">// 相当于value为&amp;Point&#123;29.935523, 52.891566&#125;</span></span><br><span class="line">    <span class="string">&quot;Uluru&quot;</span>:      &#123;<span class="number">-25.352594</span>, <span class="number">131.034361</span>&#125;, <span class="comment">// 相当于value为&amp;Point&#123;-25.352594, 131.034361&#125;</span></span><br><span class="line">    <span class="string">&quot;Googleplex&quot;</span>: &#123;<span class="number">37.422455</span>, <span class="number">-122.084306</span>&#125;, <span class="comment">// 相当于value为&amp;Point&#123;37.422455, -122.084306&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m2) <span class="comment">// map[Googleplex:0xc0000ae050 Persepolis:0xc0000ae030 Uluru:0xc0000ae040]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="了解切片实现原理并高效使用"><a href="#了解切片实现原理并高效使用" class="headerlink" title="了解切片实现原理并高效使用"></a>了解切片实现原理并高效使用</h2><ul>
<li>Go数组是值语义的，这意味着一个数组变量表示的是整个数组，这点与C语言完全不同。在C语言中，数组变量可视为指向数组第一个元素的指针。而在Go语言中传递数组是纯粹的值拷贝，对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗。这时很多人会使用数组指针类型来定义函数参数，然后将数组地址传进函数，这样做的确可以避免性能损耗，但这是C语言的惯用法，在Go语言中，更地道的方式是使用切片。</li>
<li>切片可以提供比指针更为强大的功能，比如下标访问、边界溢出校验、动态扩容等。</li>
<li>通过语法u[low: high]形式进行数组切片化而创建的切片，一旦切片cap触碰到数组的上界，再对切片进行append操作，切片就会和原数组解除绑定。</li>
<li>重新分配底层数组并复制元素的操作代价很大，如果可以预估出切片底层数组需要承载的元素数量，强烈建议在创建切片时带上cap参数。</li>
</ul>
<h2 id="了解map实现原理并高效使用"><a href="#了解map实现原理并高效使用" class="headerlink" title="了解map实现原理并高效使用"></a>了解map实现原理并高效使用</h2><ul>
<li><p>map对value的类型没有限制，但是对key的类型有严格要求：key的类型应该严格定义了作为“==”和“!=”两个操作符的操作数时的行为，因此函数、map、切片不能作为map的key类型。</p>
</li>
<li><p>map类型不支持“零值可用”，未显式赋初值的map类型变量的零值为nil。对处于零值状态的map变量进行操作将会导致运行时panic。</p>
</li>
<li><p>和切片一样，map也是引用类型，将map类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对map变量的修改在函数外部也是可见的。</p>
</li>
<li><p>面对一个非nil的map类型变量，我们可以向其中插入符合map类型定义的任意键值对。Go运行时会负责map内部的内存管理，因此除非是系统内存耗尽，我们不用担心向map中插入数据的数量。如果key已经存在于map中，则该插入操作会用新值覆盖旧值。</p>
</li>
<li><p>map类型更多用在查找和数据读取场合。所谓查找就是判断某个key是否存在于某个map中。我们可以使用“comma ok”惯用法来进行查找：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, ok := m[<span class="string">&quot;key&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// &quot;key&quot;不在map中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果key不存在于map中，我们看到v仍然被赋予了一个“合法”值0，这个值是value类型int的零值。在这样的情况下，我们无法判定这个0是“key3”对应的值还是因“key3”不存在而返回的零值。为此我们还需要借助“comma ok”:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;key1&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;key2&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">v := m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">v = m[<span class="string">&quot;key3&quot;</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
<li><p>即便要删除的数据在map中不存在，delete也不会导致panic。</p>
</li>
<li><p>对同一map做多次遍历，遍历的元素次序并不相同。这是因为Go运行时在初始化map迭代器时对起始位置做了随机处理。因此千万不要依赖遍历map所得到的元素次序。如果你需要一个稳定的遍历次序，那么一个比较通用的做法是使用另一种数据结构来按需要的次序保存key，比如切片。</p>
</li>
<li><p>充当map描述符角色的hmap实例自身是有状态的（hmap.flags）且对状态的读写是没有并发保护的，因此map实例不是并发写安全的，不支持并发读写。如果对map实例进行并发读写，程序运行时会发生panic。比如下面并发读写map的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter3/sources/map_concurrent_read_and_write.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIteration</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        _ = fmt.Sprintf(<span class="string">&quot;[%d, %d] &quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWrite</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        m[k] = v + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="number">13</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">            doIteration(m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">            doWrite(m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Go 1.9版本中引入了支持并发写安全的sync.Map类型，可以用来在并发读写的场景下替换掉map。另外考虑到map可以自动扩容，map中数据元素的value位置可能在这一过程中发生变化，因此Go不允许获取map中value的地址，这个约束是在编译期间就生效的。示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := m[key]  <span class="comment">// 无法获取m[key]的地址</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure></li>
<li><p><img src="/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115213038800.png"></p>
</li>
<li><p>和切片一样，尽量使用cap参数创建map避免频繁扩容降低性能。</p>
</li>
</ul>
<h2 id="了解string实现原理并高效使用"><a href="#了解string实现原理并高效使用" class="headerlink" title="了解string实现原理并高效使用"></a>了解string实现原理并高效使用</h2></div><div class="article-licensing box"><div class="licensing-title"><p>声明、类型、语句与控制结构</p><p><a href="https://mrcq.github.io/2022/11/15/读书笔记/Go语言精进之路/声明、类型、语句与控制结构/">https://mrcq.github.io/2022/11/15/读书笔记/Go语言精进之路/声明、类型、语句与控制结构/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Kurisu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-11-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-11-15</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Go/">Go, </a><a class="link-muted" rel="tag" href="/tags/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/">Go语言精进之路 </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E5%AE%B9%E5%BF%8D%E7%BD%AA%E6%81%B6/"><span class="level-item">容忍罪恶</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Kurisu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Kurisu</p><p class="is-size-6 is-block">水滴石穿，聚沙成塔</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">51</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">17</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/mrcq" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/mrcq"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#使用一致的变量声明形式"><span class="level-left"><span class="level-item">1</span><span class="level-item">使用一致的变量声明形式</span></span></a></li><li><a class="level is-mobile" href="#使用无类型常量简化代码"><span class="level-left"><span class="level-item">2</span><span class="level-item">使用无类型常量简化代码</span></span></a></li><li><a class="level is-mobile" href="#使用iota实现枚举常量"><span class="level-left"><span class="level-item">3</span><span class="level-item">使用iota实现枚举常量</span></span></a></li><li><a class="level is-mobile" href="#尽量定义零值可用的类型"><span class="level-left"><span class="level-item">4</span><span class="level-item">尽量定义零值可用的类型</span></span></a></li><li><a class="level is-mobile" href="#使用复合字面值作为初值构造器"><span class="level-left"><span class="level-item">5</span><span class="level-item">使用复合字面值作为初值构造器</span></span></a></li><li><a class="level is-mobile" href="#了解切片实现原理并高效使用"><span class="level-left"><span class="level-item">6</span><span class="level-item">了解切片实现原理并高效使用</span></span></a></li><li><a class="level is-mobile" href="#了解map实现原理并高效使用"><span class="level-left"><span class="level-item">7</span><span class="level-item">了解map实现原理并高效使用</span></span></a></li><li><a class="level is-mobile" href="#了解string实现原理并高效使用"><span class="level-left"><span class="level-item">8</span><span class="level-item">了解string实现原理并高效使用</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Kurisu&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Kurisu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>