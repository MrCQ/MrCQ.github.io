{"posts":[{"title":"GO面试题","text":"基础简单介绍一下Golang？1谷歌开发的一种系统编程语言。它具有内置的垃圾收集机制并支持并发。代码可以编译成单个可执行二进制文件，不需要添加库或运行时环境即可在服务器上执行。 go格式化输出%v、%+v、%#v 的区别？123451、%v 只输出所有的值2、%+v 先输出字段属性，再输出该字段的值3、%#v 先输出结构体名字值，再输出结构体（字段属性+字段的值） Go语言局部变量分配在栈还是堆？1Go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。 参考: go语言局部变量分配在栈还是堆 如果函数内同时声明defer跟panic，会怎么执行？123一个函数内defer的执行顺序与其声明顺序相反出现panic语句时，会先执行defer后执行panic出现panic语句时，声明在panic后面的任何代码不再执行 123456789101112package mainimport( &quot;fmt&quot;)func main(){ defer func(){fmt.Println(&quot;打印前&quot;)}() defer func(){fmt.Println(&quot;打印中&quot;)}() defer func(){fmt.Println(&quot;打印后&quot;)}() panic(&quot;结束&quot;)} 12345$ go run main.go 打印后打印中打印前panic: 结束 Go语言中怎么捕获错误而不中断程序的执行？1panic + defer + recover() 12345678910111213141516171819202122package mainimport( &quot;fmt&quot; &quot;time&quot;)func main(){ go func(){ defer CatchErr() panic(&quot;test&quot;) }() time.Sleep(time.Second) fmt.Println(&quot;主线程正常退出&quot;)}func CatchErr(){ if err := recover();err !=nil{ fmt.Println(err) }} 123$ go run main.go test主线程正常退出 for range 循环的时候 是 创建每个元素的副本，还是使用元素的引用？123for range 循环的时候会创建每个元素的副本，而不是元素的引用所以 m[key] = &amp;val 取的都是变量 val 的地址所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3 123456789101112131415161718package mainimport( &quot;fmt&quot;)func main(){ slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = &amp;val } for k,v := range m { fmt.Println(k,&quot;-&gt;&quot;,*v) } } 12345$ go run main.go 0 -&gt; 31 -&gt; 32 -&gt; 33 -&gt; 3 下面这段代码有什么缺陷123func funcMui(x, y int) (sum int, error) { return x + y, nil} 123在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。这里的第一个返回值有命名 sum，第二个没有命名，所以错误。 new() 与 make() 的区别？1234567func main(){ s1 := new([]int) s2 := make([]int, 0) fmt.Println(s1) fmt.Println(s2)} 123$ go run main.go &amp;[][] 1new(T) 是为一个 T 类型的新值分配空间, 并将此空间初始化为 T 的零值, 并返回这块内存空间的地址, 也就是 T 类型的指针 T, 该指针指向 T 类型值占用的那块内存. make(T) 返回的是初始化之后的 T, 且只能用于 slice, map, channel 三种类型. make(T, args) 返回初始化之后 T 类型的值, 且此新值并不是 T 类型的零值, 也不是 T 类型的指针 T, 而是 T 类型值经过初始化之后的引用. 参考1: Go中make和new的区别 参考2: Go中make()和new()的区别 下面这段代码能否通过编译，不能的话原因是什么；如果能，输出什么？12345func main() { list := new([]int) list = append(list, 1) fmt.Println(list)} 12345678// 不能通过编译，new([]int) 之后的 list 是一个 *[]int 类型的指针，// 不能对指针执行 append 操作。// 可以改写为:func main() { list := new([]int) *list = append(*list, 1) fmt.Println(*list)} 123456func main() { s1 := []int{1, 2, 3} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1)} 12不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。 12345678var( size := 1024 max_size = size*2)func main() { fmt.Println(size,max_size)} 12不能通过编译。变量声明的简短模式，形如：x := 100。有限制：只能在函数内部使用简短模式 结构体能比较吗？如果能的话需要什么条件？1在 Go 语言中，Go 结构体有时候并不能直接比较，当其基本类型包含：slice、map、function 时，是不能比较的。若强行比较，就会导致出现例子中的直接报错的情况。 参考：Go 面试题：Go 结构体（struct）是否可以比较？ select是随机的还是顺序的?1select会随机选择一个可用通道做收发操作 Sliceslice 扩容机制1234567891011121314151617GO1.17版本及之前当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；当原 slice 容量 &lt; 1024 的时候，新 slice 容量变成原来的 2 倍；当原 slice 容量 &gt; 1024，进入一个循环，每次容量变成原来的1.25倍,直到大于期望容量。 GO1.18之后当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；当原 slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的 2 倍；当原 slice 容量 &gt; threshold，进入一个循环，每次容量增加（旧容量+3*threshold）/4。 slice的深浅拷贝12345深浅拷贝都是进行复制，区别在于复制出来的新对象与原来的对象在它们发生改变时，是否会相互影响，本质区别就是复制出来的对象与原对象是否会指向同一个地址。在Go语言，切片拷贝有三种方式：使用=操作符拷贝切片，这种就是浅拷贝使用[:]下标的方式复制切片，这种也是浅拷贝使用Go语言的内置函数copy()进行切片拷贝，这种就是深拷贝 初始化容量为2的切片append 3个元素后打印，切片内容、len、cap 分别是什么？12345func main() { s := make([]int, 2) s = append(s, 1, 2, 3) fmt.Printf(&quot;slice:%v len:%v cap:%v&quot;, s, len(s), cap(s))} 12$ go run main.go slice:[0 0 1 2 3] len:5 cap:6","link":"/2022/11/03/Go/GO%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"Go语言速成","text":"发明Go语言是出于更好地完成工作的需要。Go不是计算机科学的最新发展潮流，但它却提供了解决现实问题的最新最快的方法。 Go拥有命令式语言的静态类型，编译很快，执行也很快，同时加入了对于目前多核CPU的并发计算支持，也有相应的特性来实现大规模编程。 Go语言有非常棒的标准库，还有一个充满热情的社区。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371// 单行注释/* 多行 注释 */// 导入包的子句在每个源文件的开头。// Main比较特殊，它用来声明可执行文件，而不是一个库。package main// Import语句声明了当前文件引用的包。import ( &quot;fmt&quot; // Go语言标准库中的包 &quot;io/ioutil&quot; // 包含一些输入输出函数 m &quot;math&quot; // 数学标准库，在此文件中别名为m &quot;net/http&quot; // 一个web服务器包 &quot;os&quot; // 系统底层函数，如文件读写 &quot;strconv&quot; // 字符串转换)// 函数声明：main是程序执行的入口。// 不管你喜欢还是不喜欢，反正Go就用了花括号来包住函数体。func main() { // 往标准输出打印一行。 // 用包名fmt限制打印函数。 fmt.Println(&quot;你好世界&quot;) // 调用当前包的另一个函数。 beyondHello()}// 函数可以在括号里加参数。// 如果没有参数的话，也需要一个空括号。func beyondHello() { var x int // 变量声明，变量必须在使用之前声明。 x = 3 // 变量赋值。 // 可以用:=来偷懒，它自动把变量类型、声明和赋值都搞定了。 y := 4 sum, prod := learnMultiple(x, y) // 返回多个变量的函数 fmt.Println(&quot;sum:&quot;, sum, &quot;prod:&quot;, prod) // 简单输出 learnTypes() // 少于y分钟，学的更多！}/* &lt;- 快看快看我是跨行注释_(:з」∠)_Go语言的函数可以有多个参数和 *多个* 返回值。在这个函数中， `x`、`y` 是参数，`sum`、`prod` 是返回值的标识符（可以理解为名字）且类型为int*/func learnMultiple(x, y int) (sum, prod int) { return x + y, x * y // 返回两个值}// 内置变量类型和关键词func learnTypes() { // 短声明给你所想。 str := &quot;少说话多读书!&quot; // String类型 s2 := `这是一个可以换行的字符串` // 同样是String类型 // 非ascii字符。Go使用UTF-8编码。 g := 'Σ' // rune类型，int32的别名，使用UTF-8编码 f := 3.14195 // float64类型，IEEE-754 64位浮点数 c := 3 + 4i // complex128类型，内部使用两个float64表示 // var变量可以直接初始化。 var u uint = 7 // unsigned 无符号变量，但是实现依赖int型变量的长度 var pi float32 = 22. / 7 // 字符转换 n := byte('\\n') // byte是uint8的别名 // 数组（Array）类型的大小在编译时即确定 var a4 [4] int // 有4个int变量的数组，初始为0 a3 := [...]int{3, 1, 5} // 有3个int变量的数组，同时进行了初始化 // Array和slice各有所长，但是slice可以动态的增删，所以更多时候还是使用slice。 s3 := []int{4, 5, 9} // 回去看看 a3 ，是不是这里没有省略号？ s4 := make([]int, 4) // 分配4个int大小的内存并初始化为0 var d2 [][]float64 // 这里只是声明，并未分配内存空间 bs := []byte(&quot;a slice&quot;) // 进行类型转换 // 切片（Slice）的大小是动态的，它的长度可以按需增长 // 用内置函数 append() 向切片末尾添加元素 // 要增添到的目标是 append 函数第一个参数， // 多数时候数组在原内存处顺次增长，如 s := []int{1, 2, 3} // 这是个长度3的slice s = append(s, 4, 5, 6) // 再加仨元素，长度变为6了 fmt.Println(s) // 更新后的数组是 [1 2 3 4 5 6] // 除了向append()提供一组原子元素（写死在代码里的）以外，我们 // 还可以用如下方法传递一个slice常量或变量，并在后面加上省略号， // 用以表示我们将引用一个slice、解包其中的元素并将其添加到s数组末尾。 s = append(s, []int{7, 8, 9}...) // 第二个参数是一个slice常量 fmt.Println(s) // 更新后的数组是 [1 2 3 4 5 6 7 8 9] p, q := learnMemory() // 声明p,q为int型变量的指针 fmt.Println(*p, *q) // * 取值 // Map是动态可增长关联数组，和其他语言中的hash或者字典相似。 m := map[string]int{&quot;three&quot;: 3, &quot;four&quot;: 4} m[&quot;one&quot;] = 1 // 在Go语言中未使用的变量在编译的时候会报错，而不是warning。 // 下划线 _ 可以使你“使用”一个变量，但是丢弃它的值。 _, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs // 通常的用法是，在调用拥有多个返回值的函数时， // 用下划线抛弃其中的一个参数。下面的例子就是一个脏套路， // 调用os.Create并用下划线变量扔掉它的错误代码。 // 因为我们觉得这个文件一定会成功创建。 file, _ := os.Create(&quot;output.txt&quot;) fmt.Fprint(file, &quot;这句代码还示范了如何写入文件呢&quot;) file.Close() // 输出变量 fmt.Println(s, c, a4, s3, d2, m) learnFlowControl() // 回到流程控制}// 和其他编程语言不同的是，go支持有名称的变量返回值。// 声明返回值时带上一个名字允许我们在函数内的不同位置// 只用写return一个词就能将函数内指定名称的变量返回func learnNamedReturns(x, y int) (z int) { z = x * y return // 隐式返回z，因为前面指定了它。}// Go全面支持垃圾回收。Go有指针，但是不支持指针运算。// 你会因为空指针而犯错，但是不会因为增加指针而犯错。func learnMemory() (p, q *int) { // 返回int型变量指针p和q p = new(int) // 内置函数new分配内存 // 自动将分配的int赋值0，p不再是空的了。 s := make([]int, 20) // 给20个int变量分配一块内存 s[3] = 7 // 赋值 r := -2 // 声明另一个局部变量 return &amp;s[3], &amp;r // &amp; 取地址}func expensiveComputation() int { return 1e6}func learnFlowControl() { // if需要花括号，括号就免了 if true { fmt.Println(&quot;这句话肯定被执行&quot;) } // 用go fmt 命令可以帮你格式化代码，所以不用怕被人吐槽代码风格了， // 也不用容忍别人的代码风格。 if false { // pout } else { // gloat } // 如果太多嵌套的if语句，推荐使用switch x := 1 switch x { case 0: case 1: // 隐式调用break语句，匹配上一个即停止 case 2: // 不会运行 } // 和if一样，for也不用括号 for x := 0; x &lt; 3; x++ { // ++ 自增 fmt.Println(&quot;遍历&quot;, x) } // x在这里还是1。为什么？ // for 是go里唯一的循环关键字，不过它有很多变种 for { // 死循环 break // 骗你的 continue // 不会运行的 } // 用range可以枚举 array、slice、string、map、channel等不同类型 // 对于channel，range返回一个值， // array、slice、string、map等其他类型返回一对儿 for key, value := range map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3} { // 打印map中的每一个键值对 fmt.Printf(&quot;索引：%s, 值为：%d\\n&quot;, key, value) } // 如果你只想要值，那就用前面讲的下划线扔掉没用的 for _, name := range []string{&quot;Bob&quot;, &quot;Bill&quot;, &quot;Joe&quot;} { fmt.Printf(&quot;你是。。 %s\\n&quot;, name) } // 和for一样，if中的:=先给y赋值，然后再和x作比较。 if y := expensiveComputation(); y &gt; x { x = y } // 闭包函数 xBig := func() bool { return x &gt; 100 // x是上面声明的变量引用 } fmt.Println(&quot;xBig:&quot;, xBig()) // true （上面把y赋给x了） x /= 1e5 // x变成10 fmt.Println(&quot;xBig:&quot;, xBig()) // 现在是false // 除此之外，函数体可以在其他函数中定义并调用， // 满足下列条件时，也可以作为参数传递给其他函数： // a) 定义的函数被立即调用 // b) 函数返回值符合调用者对类型的要求 fmt.Println(&quot;两数相加乘二: &quot;, func(a, b int) int { return (a + b) * 2 }(10, 2)) // Called with args 10 and 2 // =&gt; Add + double two numbers: 24 // 当你需要goto的时候，你会爱死它的！ goto lovelove: learnFunctionFactory() // 返回函数的函数多棒啊 learnDefer() // 对defer关键字的简单介绍 learnInterfaces() // 好东西来了！}func learnFunctionFactory() { // 空行分割的两个写法是相同的，不过第二个写法比较实用 fmt.Println(sentenceFactory(&quot;原谅&quot;)(&quot;当然选择&quot;, &quot;她！&quot;)) d := sentenceFactory(&quot;原谅&quot;) fmt.Println(d(&quot;当然选择&quot;, &quot;她！&quot;)) fmt.Println(d(&quot;你怎么可以&quot;, &quot;她？&quot;))}// Decorator在一些语言中很常见，在go语言中，// 接受参数作为其定义的一部分的函数是修饰符的替代品func sentenceFactory(mystring string) func(before, after string) string { return func(before, after string) string { return fmt.Sprintf(&quot;%s %s %s&quot;, before, mystring, after) // new string }}func learnDefer() (ok bool) { // defer表达式在函数返回的前一刻执行 defer fmt.Println(&quot;defer表达式执行顺序为后进先出（LIFO）&quot;) defer fmt.Println(&quot;\\n这句话比上句话先输出，因为&quot;) // 关于defer的用法，例如用defer关闭一个文件， // 就可以让关闭操作与打开操作的代码更近一些 return true}// 定义Stringer为一个接口类型，有一个方法Stringtype Stringer interface { String() string}// 定义pair为一个结构体，有x和y两个int型变量。type pair struct { x, y int}// 定义pair类型的方法，实现Stringer接口。func (p pair) String() string { // p被叫做“接收器” // Sprintf是fmt包中的另一个公有函数。 // 用 . 调用p中的元素。 return fmt.Sprintf(&quot;(%d, %d)&quot;, p.x, p.y)}func learnInterfaces() { // 花括号用来定义结构体变量，:=在这里将一个结构体变量赋值给p。 p := pair{3, 4} fmt.Println(p.String()) // 调用pair类型p的String方法 var i Stringer // 声明i为Stringer接口类型 i = p // 有效！因为p实现了Stringer接口（类似java中的塑型） // 调用i的String方法，输出和上面一样 fmt.Println(i.String()) // fmt包中的Println函数向对象要它们的string输出，实现了String方法就可以这样使用了。 // （类似java中的序列化） fmt.Println(p) // 输出和上面一样，自动调用String函数。 fmt.Println(i) // 输出和上面一样。 learnVariadicParams(&quot;great&quot;, &quot;learning&quot;, &quot;here!&quot;)}// 有变长参数列表的函数func learnVariadicParams(myStrings ...interface{}) { // 枚举变长参数列表的每个参数值 // 下划线在这里用来抛弃枚举时返回的数组索引值 for _, param := range myStrings { fmt.Println(&quot;param:&quot;, param) } // 将可变参数列表作为其他函数的参数列表 fmt.Println(&quot;params:&quot;, fmt.Sprintln(myStrings...)) learnErrorHandling()}func learnErrorHandling() { // &quot;, ok&quot;用来判断有没有正常工作 m := map[int]string{3: &quot;three&quot;, 4: &quot;four&quot;} if x, ok := m[1]; !ok { // ok 为false，因为m中没有1 fmt.Println(&quot;别找了真没有&quot;) } else { fmt.Print(x) // 如果x在map中的话，x就是那个值喽。 } // 错误可不只是ok，它还可以给出关于问题的更多细节。 if _, err := strconv.Atoi(&quot;non-int&quot;); err != nil { // _ discards value // 输出&quot;strconv.ParseInt: parsing &quot;non-int&quot;: invalid syntax&quot; fmt.Println(err) } // 待会再说接口吧。同时， learnConcurrency()}// c是channel类型，一个并发安全的通信对象。func inc(i int, c chan int) { c &lt;- i + 1 // &lt;-把右边的发送到左边的channel。}// 我们将用inc函数来并发地增加一些数字。func learnConcurrency() { // 用make来声明一个slice，make会分配和初始化slice，map和channel。 c := make(chan int) // 用go关键字开始三个并发的goroutine，如果机器支持的话，还可能是并行执行。 // 三个都被发送到同一个channel。 go inc(0, c) // go is a statement that starts a new goroutine. go inc(10, c) go inc(-805, c) // 从channel中读取结果并打印。 // 打印出什么东西是不可预知的。 fmt.Println(&lt;-c, &lt;-c, &lt;-c) // channel在右边的时候，&lt;-是读操作。 cs := make(chan string) // 操作string的channel cc := make(chan chan string) // 操作channel的channel go func() { c &lt;- 84 }() // 开始一个goroutine来发送一个新的数字 go func() { cs &lt;- &quot;wordy&quot; }() // 发送给cs // Select类似于switch，但是每个case包括一个channel操作。 // 它随机选择一个准备好通讯的case。 select { case i := &lt;-c: // 从channel接收的值可以赋给其他变量 fmt.Println(&quot;这是……&quot;, i) case &lt;-cs: // 或者直接丢弃 fmt.Println(&quot;这是个字符串！&quot;) case &lt;-cc: // 空的，还没作好通讯的准备 fmt.Println(&quot;别瞎想&quot;) } // 上面c或者cs的值被取到，其中一个goroutine结束，另外一个一直阻塞。 learnWebProgramming() // Go很适合web编程，我知道你也想学！}// http包中的一个简单的函数就可以开启web服务器。func learnWebProgramming() { // ListenAndServe第一个参数指定了监听端口，第二个参数是一个接口，特定是http.Handler。 go func() { err := http.ListenAndServe(&quot;:8080&quot;, pair{}) fmt.Println(err) // 不要无视错误。 }() requestServer()}// 使pair实现http.Handler接口的ServeHTTP方法。func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) { // 使用http.ResponseWriter返回数据 w.Write([]byte(&quot;Y分钟golang速成!&quot;))}func requestServer() { resp, err := http.Get(&quot;http://localhost:8080&quot;) fmt.Println(err) defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) fmt.Printf(&quot;\\n服务器消息： `%s`&quot;, string(body))}","link":"/2022/10/19/Go/Go%E8%AF%AD%E8%A8%80%E9%80%9F%E6%88%90/"},{"title":"String库函数","text":"判断是不是以某个字符串开头1234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.HasPrefix(str, &quot;http://&quot;) res1 := strings.HasPrefix(str, &quot;hello&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is falseres1 is true 判断是不是以某个字符串结尾1234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.HasSuffix(str, &quot;http://&quot;) res1 := strings.HasSuffix(str, &quot;world&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is falseres1 is true 判断str在s中首次出现的位置，如果没有返回-11234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.Index(str, &quot;o&quot;) res1 := strings.Index(str, &quot;i&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出: res0 is 4res1 is -1 判断str在s中最后一次出现的位置，如果没有返回-11234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.LastIndex(str, &quot;o&quot;) res1 := strings.LastIndex(str, &quot;i&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is 7res1 is -1 字符串替换123456789101112131415package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world world&quot; res0 := strings.Replace(str, &quot;world&quot;, &quot;golang&quot;, 2) res1 := strings.Replace(str, &quot;world&quot;, &quot;golang&quot;, 1) //trings.Replace(&quot;原字符串&quot;, &quot;被替换的内容&quot;, &quot;替换的内容&quot;, 替换次数) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is hello golang golangres1 is hello golang world 求str含s的次数1234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world world&quot; countTime0 := strings.Count(str, &quot;o&quot;) countTime1 := strings.Count(str, &quot;i&quot;) fmt.Printf(&quot;countTime0 is %v\\n&quot;, countTime0) fmt.Printf(&quot;countTime1 is %v\\n&quot;, countTime1)} 输出： countTime0 is 3countTime1 is 0 重复 n 次 str1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world &quot; res0 := strings.Repeat(str, 0) res1 := strings.Repeat(str, 1) res2 := strings.Repeat(str, 2) // strings.Repeat(&quot;原字符串&quot;, 重复次数) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1) fmt.Printf(&quot;res2 is %v\\n&quot;, res2)} 输出： res0 isres1 is hello worldres2 is hello world hello world str 转为大写12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world &quot; res := strings.ToUpper(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is HELLO WORLD str 转为小写12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;HELLO WORLD &quot; res := strings.ToLower(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is hello world 去掉 str 首尾的空格12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot; hello world &quot; res := strings.TrimSpace(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出:res is hello world 去掉字符串首尾指定的字符12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hi , hello world , hi&quot; res := strings.Trim(str, &quot;hi&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is , hello world , 去掉字符串首指定的字符12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hi , hello world , hi&quot; res := strings.TrimLeft(str, &quot;hi&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is , hello world , hi 去掉字符串尾指定的字符12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hi , hello world , hi&quot; res := strings.TrimRight(str, &quot;hi&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is hi , hello world , 返回str空格分隔的所有子串的slice12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world ，hello golang&quot; res := strings.Fields(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is [hello world ，hello golang] 返回str 指定字符分隔的所有子串的slice12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world ，hello golang&quot; res := strings.Split(str, &quot;o&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is [hell w rld ，hell g lang] 用指定字符将 string 类型的 slice 中所有元素链接成一个字符串12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := []string{&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;golang&quot;} res := strings.Join(str, &quot;++&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res) /* num := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0} res1 := strings.Join(num, &quot;++&quot;) // cannot use num (type []int) as type []string in argument to strings.Join fmt.Println(res1) */} 输出： res is hello++world++hello++golang","link":"/2022/10/28/Go/String%E5%BA%93%E5%87%BD%E6%95%B0/"},{"title":"defer","text":"什么是deferdefer是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。 defer语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。 defer在一些需要回收资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。 12f, _ := os.Open(&quot;defer.txt&quot;)defer f.Close() 注意：以上代码，忽略了err, 实际上应该先判断是否出错，如果出错了，直接return. 接着再判断f是否为空，如果f为空，就不能调用f.Close()函数了，会直接panic的。 为什么需要defer程序员在编程的时候，经常需要打开一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。 但是程序员都是人，是人就会犯错。因此经常有程序员忘记关闭这些资源。Golang直接在语言层面提供defer关键字，在打开资源语句的下一行，就可以直接用defer语句来注册函数结束后执行关闭资源的操作。因为这样一颗“小小”的语法糖，程序员忘写关闭资源语句的情况就大大地减少了。 怎样合理使用deferdefer的使用其实非常简单： 12345678f,err := os.Open(filename)if err != nil { panic(err)}if f != nil { defer f.Close()} 在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。 当然，defer会有小小地延迟，对时间要求特别特别特别高的程序，可以避免使用它，其他一般忽略它带来的延迟。 defer的执行顺序多个defer出现的时候，它是一个“栈”的关系，也就是先进后出。一个函数中，写在前面的defer会比写在后面的defer调用的晚。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。 1234567891011func test(x int) { defer println(&quot;a&quot;) defer println(&quot;b&quot;) defer func() { println(100 / x) // div0 异常未被捕获，逐步往外传递，最终终⽌止进程。 }() defer println(&quot;c&quot;)}func main() { test(0)} 输出： c b a panic: runtime error: integer divide by zero defer与return执行的先后顺序 多个defer的执行顺序为“后进先出” defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。 如果函数的返回值是无名的（不带命名返回值），则go语言会在执行return的时候会执行一个类似创建一个临时变量作为保存return值的动作，而有名返回值的函数，由于返回值在函数定义的时候已经将该变量进行定义，在执行return的时候会先执行返回值保存操作，而后续的defer函数会改变这个返回值(虽然defer是在return之后执行的，但是由于使用的函数定义的变量，所以执行defer操作后对该变量的修改会影响到return的值 不带命名返回值的函数： 1234567891011121314151617181920package main import &quot;fmt&quot; func main() { fmt.Println(&quot;return:&quot;, test())// defer 和 return之间的顺序是先返回值, i=0，后defer} func test() int {//这里返回值没有命名 var i int defer func() { i++ fmt.Println(&quot;defer1&quot;, i) //作为闭包引用的话，则会在defer函数执行时根据整个上下文确定当前的值。i=2 }() defer func() { i++ fmt.Println(&quot;defer2&quot;, i) //作为闭包引用的话，则会在defer函数执行时根据整个上下文确定当前的值。i=1 }() return i} test() 先返回 i=0 defer2先于defer1执行 输出结果为: defer2 1 defer1 2 return: 0 带命名返回值的函数： 12345678910111213141516171819package main import &quot;fmt&quot; func main() { fmt.Println(&quot;return:&quot;, test())} func test() (i int) { //返回值命名i defer func() { i++ fmt.Println(&quot;defer1&quot;, i) }() defer func() { i++ fmt.Println(&quot;defer2&quot;, i) }() return i} 输出结果为: defer2 1 defer1 2 return: 2 理解return 返回值的运行机制:为了弄清上述两种情况的区别，我们首先要理解return 返回值的运行机制:return 并非原子操作，分为赋值，和返回值两步操作。eg1 : 实际上return 执行了两步操作，因为返回值没有命名，所以return 默认指定了一个返回值（假设为s），首先将i赋值给s,后续的操作因为是针对i,进行的，所以不会影响s, 此后因为s不会更新，所以return s 不会改变相当于：var i ints := ireturn seg2 : 同上，s 就相当于 命名的变量i, 因为所有的操作都是基于命名变量i(s),返回值也是i, 所以每一次defer操作，都会更新返回值i defer函数中带返回值defer后面的函数里面只要有return语句，则只有这个return的语句才会在原函数结束时执行。 12345678910111213141516171819202122package mainimport ( &quot;log&quot; &quot;time&quot;)func main(){ bigSlowOperation()}func bigSlowOperation() { defer trace(&quot;bigSlowOperation&quot;)() // don't forget the extra parentheses // ...lots of work... time.Sleep(10 * time.Second) // simulate slow operation by sleeping}func trace(msg string) func() { log.Printf(&quot;enter %s&quot;, msg) start := time.Now() return func() { log.Printf(&quot;exit %s (%s)&quot;, msg, time.Since(start)) }} 输出： 2022/10/29 17:55:00 enter bigSlowOperation2022/10/29 17:55:10 exit bigSlowOperation (10.0108435s)","link":"/2022/10/29/Go/defer/"},{"title":"三个点用法","text":"函数可变数量参数可变参数是函数最右边的参数，普通参数放在左侧。 12345678910111213141516package mainimport &quot;fmt&quot;func main() { //multiParam 可以接受可变数量的参数 multiParam(&quot;jerry&quot;, 1) multiParam(&quot;php&quot;, 1, 2)}func multiParam(name string, args ...int) { fmt.Println(name) //参数放在args切片中 for _, e := range args { fmt.Println(e) }} 展开slice 通过append合并两个slice。 1234stooges := []string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;}lang := []string{&quot;php&quot;, &quot;golang&quot;, &quot;java&quot;}stooges = append(stooges, lang...)fmt.Println(stooges) 作为可变参数时，实际上是将slice打散展开。 数组元素数量如果忽略数组[]中的数字不设置大小，…指定的长度等于数组中元素的数量，Go语言会根据元素的个数设置数组的大小。 1234stooges := [...]string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;} //等价于stooges := [3]string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;}arr := [...]int{1, 2, 3}fmt.Println(len(stooges))fmt.Println(len(arr)) go命令go描述软件包列表时，命令使用三个点作为通配符。 此命令测试当前目录及其子目录中的所有软件包。 1go test ./...","link":"/2022/10/29/Go/%E4%B8%89%E4%B8%AA%E7%82%B9%E7%94%A8%E6%B3%95/"},{"title":"函数","text":"函数定义 不支持 嵌套 (nested)、重载 (overload) 和 默认参数 (default parameter)。 无需声明原型。 支持不定长变参。 支持多返回值。 支持命名返回参数。 支持匿名函数和闭包。 使用关键字 func 定义函数，左大括号依旧不能另起一行。 1234func test(x, y int, s string) (int, string) { // 类型相同的相邻参数可合并。 n := x + y // 多返回值必须用括号。 return n, fmt.Sprintf(s, n)} 函数是第一类对象，可作为参数传递。建议将复杂签名定义为函数类型，以便于阅读。 12345678910111213141516func test(fn func() int) int { return fn()}type FormatFunc func(s string, x, y int) string // 定义函数类型。func format(fn FormatFunc, s string, x, y int) string { return fn(s, x, y)}func main() { s1 := test(func() int { return 100 }) // 直接将匿名函数当参数。 s2 := format(func(s string, x, y int) string { return fmt.Sprintf(s, x, y) }, &quot;%d, %d&quot;, 10, 20) println(s1) println(s2)} 输出： 100 10, 20 有返回值的函数，必须有明确的终止语句，否则会引发编译错误。 在函数中定义的返回值变量，会自动赋为 zero-value 。也就是说变量会自动进行初始化 int 类型初始化为 0，string 初始化为 &quot;&quot; , 结构体则根据其组成部分初始化。 如果函数中已定义返回值，return会将结果写入返回值中，并返回返回值。 1234567891011121314151617func Test() (v int) { println(`v_address:`, &amp;v) v = 1 vv := 5 defer func() { println(`defer v_address:`, &amp;v) v++ fmt.Println(`defer v:`, v) fmt.Println(`defer vv:`, vv) }() println(`vv_address:`, &amp;vv) return vv}func main() { fmt.Println(`TestDefer:`, Test())} 输出： v_address: 0xc000119e78vv_address: 0xc000119e70defer v_address: 0xc000119e78defer v: 6defer vv: 5TestDefer: 6 变参 变参本质上就是 slice。只能有一个，且必须是最后一个。 12345678910func test(s string, n ...int) string { var x int for _, i := range n { x += i } return fmt.Sprintf(s, x)}func main() { println(test(&quot;sum: %d&quot;, 1, 2, 3))} 使用 slice 对象做变参时，必须展开。 1234func main() { s := []int{1, 2, 3} println(test(&quot;sum: %d&quot;, s...))} 返回值 不能用容器对象接收多返回值。只能用多个变量，或 “_” 忽略。 123456789func test() (int, int) { return 1, 2}func main() { // s := make([]int, 2) // s = test() // Error: multiple-value test() in single-value context x, _ := test() println(x)} 多返回值可直接作为其他函数调用实参。 1234567891011121314151617func test() (int, int) { return 1, 2}func add(x, y int) int { return x + y}func sum(n ...int) int { var x int for _, i := range n { x += i } return x}func main() { println(add(test())) println(sum(test()))} 命名返回参数可看做与形参类似的局部变量，最后由 return 隐式返回。 1234567func add(x, y int) (z int) { z = x + y return}func main() { println(add(1, 2))} 命名返回参数可被同名局部变量遮蔽，此时需要显式返回。 12345678910111213func add(x, y int) (z int) { println(&amp;z) { // 不能在一个级别，引发 &quot;z redeclared in this block&quot; 错误。 var z = x + y // return // Error: result parameter z not in scope at return println(&amp;z) return z // 必须显式返回。 }}func main() { println(add(1, 1))} 输出： 0xc000059f300xc000059f282 命名返回参数允许 defer 延迟调用通过闭包读取和修改。更多defer相关 12345678910func add(x, y int) (z int) { defer func() { z += 100 }() z = x + y return}func main() { println(add(1, 2)) // 输出: 103} 显式 return 返回前，会先修改命名返回参数。 12345678910func add(x, y int) (z int) { defer func() { println(z) // 输出: 203 }() z = x + y return z + 200 // 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (ret)}func main() { println(add(1, 2)) // 输出: 203}","link":"/2022/10/29/Go/%E5%87%BD%E6%95%B0/"},{"title":"匿名函数和闭包","text":"匿名函数 未指定函数名的函数被称为匿名函数。 赋值给函数变量1234567func main() { sumFun := func(num1, num2 int) int { return num1 + num2 } sum := sumFun(10, 20) fmt.Println(sum)} 输出： 30 1234567func main() { fns := [](func(x int) int){ func(x int) int { return x + 1 }, func(x int) int { return x + 2 }, } println(fns[1](100))} 输出： 102 匿名结构体123456789func main() { d := struct { fn func() string }{ fn: func() string { return &quot;Hello, World!&quot; }, } println(d.fn())} 直接执行12345func main() { func(name string) { fmt.Println(&quot;Hello&quot;, name) }(&quot;TOMOCAT&quot;)} 输出： Hello TOMOCAT 作为函数参数可以定义一个接收匿名函数参数的函数，实现回调的效果。 1234567891011121314151617181920212223242526/* 求和并调用callback函数对结果进行特殊处理*/func sumWorker(data []int, callback func(int)) { sum := 0 for _, num := range data { sum += num } callback(sum)}func main() { // 打印出求和结果 sumWorker([]int{1, 2, 3, 4}, func(a int) { fmt.Println(&quot;sum:&quot;, a) }) // 判断求和结果是否大于100 sumWorker([]int{1, 2, 3, 4}, func(a int) { if a &gt; 100 { fmt.Println(&quot;sum &gt; 100&quot;) } else { fmt.Println(&quot;sum &lt;= 100&quot;) } })} 输出： sum: 10sum &lt;= 100 多个匿名函数 123456789101112131415func main() { f1,f2:=F(1,2) fmt.Println(f1(4)) fmt.Println(f2())}func F(x, y int)(func(int)int,func()int) { f1 := func(z int) int { return (x + y) * z / 2 } f2 := func() int { return 2 * (x + y) } return f1,f2} 输出： 66 闭包闭包是由函数及其相关引用环境组成的实体，可以理解为一个函数“捕获”了和它处于同一作用域的其他变量。说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕。 Golang中所有的匿名函数都是闭包。 理解“捕获”的概念“捕获”的本质就是引用传递而非值传递。 1234567891011func main() { i := 0 // 闭包: i是引用传递 defer func() { fmt.Println(&quot;defer closure i:&quot;, i) }() // 非闭包: i是值传递 defer fmt.Println(&quot;defer i:&quot;, i) // 修改i的值 i = 100} 输出： defer i: 0defer closure i: 100 匿名函数与自由变量组成闭包下面这个例子中实现了Go中常见的闭包场景，我们通过Adder()返回一个匿名函数，这个匿名函数和自由变量x组成闭包，只要匿名函数的实例closure没有消亡，那么x都是引用传递。 123456789101112131415161718192021222324252627/* 返回匿名函数的函数 1) x是自由变量 2) 匿名函数和x自由变量共同组成闭包*/func Adder(x int) func(int) int { return func(y int) int { x += y fmt.Printf(&quot;x addr %p, x value %d\\n&quot;, &amp;x, x) return x }}func main() { fmt.Println(&quot;----------------Adder()返回的匿名函数实例1----------------&quot;) closure := Adder(1) closure(100) closure(1000) closure(10000) fmt.Println(&quot;----------------Adder()返回的匿名函数实例2----------------&quot;) closure2 := Adder(10) closure2(1) closure2(1) closure2(1) closure2(1)} 输出： —————-Adder()返回的匿名函数实例1—————-x addr 0xc000018088, x value 101x addr 0xc000018088, x value 1101x addr 0xc000018088, x value 11101—————-Adder()返回的匿名函数实例2—————-x addr 0xc0000180c0, x value 11x addr 0xc0000180c0, x value 12x addr 0xc0000180c0, x value 13x addr 0xc0000180c0, x value 14 闭包中使用值传递由于闭包的存在，Golang中使用匿名函数的时候要特别注意区分清楚引用传递和值传递。根据实际需要，我们在不需要引用传递的地方通过匿名函数参数赋值的方式实现值传递。 1234567891011121314151617func main() { fmt.Println(&quot;----------------引用传递----------------&quot;) for i := 0; i &lt; 10; i++ { go func() { fmt.Println(i) }() } time.Sleep(10 * time.Millisecond) fmt.Println(&quot;----------------值传递----------------&quot;) for i := 0; i &lt; 10; i++ { go func(x int) { fmt.Println(x) }(i) } time.Sleep(10 * time.Millisecond) return} 输出： —————-引用传递—————-35910101010101010 —————-值传递—————-0143285697 总结 匿名函数及其“捕获”的自由变量被称为闭包 被闭包捕获的变量称为“自由变量”，在匿名函数实例未消亡时共享同个内存地址 同一个匿名函数可以构造多个实例，每个实例内的自由变量地址不同 匿名函数内部的局部变量在每次执行匿名函数时地址都是变换的 通过匿名函数参数赋值的方式可以实现值传递","link":"/2022/10/29/Go/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"},{"title":"数据","text":"Array 数组是值类型，赋值和传参会复制整个数组，而不是指针。 数组长度必须是常量，且是类型的组成部分。[2]int 和 [3]int 是不同类型。 支持 “==”、”!=” 操作符，因为内存总是被初始化过的。 指针数组 [n]*T，数组指针 *[n]T。因为数组指针是一个指针，所以在定义时，先写 *， 表示定义一个指针，后面接数据类型 可用复合语句初始化。 12345678910a := [3]int{1, 2} // 未初始化元素值为 0。b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。c := [5]int{2: 100, 4: 200} // 使用索引号初始化元素。d := [...]struct { name string age uint8}{ {&quot;user1&quot;, 10}, // 可省略元素类型。 {&quot;user2&quot;, 20}, // 别忘了最后一行的逗号。} 支持多维数组。 12a := [2][3]int{{1, 2, 3}, {4, 5, 6}}b := [...][2]int{{1, 1}, {2, 2}, {3, 3}} // 第 2 纬度不能用 &quot;...&quot;。 值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。 12345678910func test(x [2]int) { fmt.Printf(&quot;x: %p\\n&quot;, &amp;x) x[1] = 1000}func main() { a := [2]int{} fmt.Printf(&quot;a: %p\\n&quot;, &amp;a) test(a) fmt.Println(a)} 输出： a: 0xc0000a6070x: 0xc0000a60a0[0 0] 内置函数 len 和 cap 都返回数组长度 (元素数量)。 12a := [2]int{}println(len(a), cap(a)) // 2, 2 Slice 需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。 12345type slice struct { array unsafe.Pointer len int cap int} 引用类型。但自身是结构体，值拷贝传递。 array 是切片所指向的底层数组数据 属性 len 表示可用元素数量，读写操作不能超过该限制。 属性 cap 表示最大扩张容量，不能超出数组限制。 如果 slice == nil，那么 len、cap 结果都等于 0。 12 data := [...]int{0, 1, 2, 3, 4, 5, 6}slice := data[1:4:5] // [low : high : max] 创建表达式使用的是元素索引号，而非数量。 如果 max 要求获取的容量大于旧数据容量. 那会 panic 读写操作实际目标是底层数组，只需注意索引号的差别。 123456data := [...]int{0, 1, 2, 3, 4, 5}s := data[2:4]s[0] += 100s[1] += 200fmt.Println(s)fmt.Println(data) 输出： [102 203][0 1 102 203 4 5] 可直接创建 slice 对象，自动分配底层数组。 123456s1 := []int{0, 1, 2, 3, 8: 100} // 通过初始化表达式构造，可使用索引号。fmt.Println(s1, len(s1), cap(s1))s2 := make([]int, 6, 8) // 使用 make 创建，指定 len 和 cap 值。fmt.Println(s2, len(s2), cap(s2))s3 := make([]int, 6) // 省略 cap，相当于 cap = len。fmt.Println(s3, len(s3), cap(s3)) 输出： [0 1 2 3 0 0 0 0 100] 9 9[0 0 0 0 0 0] 6 8[0 0 0 0 0 0] 6 6 使用 make 动态创建 slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作。 1234s := []int{0, 1, 2, 3}p := &amp;s[2] // *int, 获取底层数组元素指针。*p += 100fmt.Println(s) 输出： [0 1 102 3] 至于 [][]T，是指元素类型为 []T 。 12345data := [][]int{ []int{1, 2, 3}, []int{100, 200}, []int{11, 22, 33, 44},} 可直接修改 struct array/slice 成员。 12345678d := [5]struct { x int}{}s := d[:]d[1].x = 10s[2].x = 20fmt.Println(d)fmt.Printf(&quot;%p, %p\\n&quot;, &amp;d, &amp;d[0]) 输出： [{0} {10} {20} {0} {0}]0x20819c180, 0x20819c180 reslice 所谓 reslice，是基于已有 slice 创建新 slice 对象，以便在 cap 允许范围内调整属性。 1234s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s1 := s[2:5] // [2 3 4]s2 := s1[2:6:7] // [4 5 6 7]s3 := s2[3:6] // Error 新对象依旧指向原底层数组。 123456s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s1 := s[2:5] // [2 3 4]s1[2] = 100s2 := s1[2:6] // [100 5 6 7]s2[3] = 200fmt.Println(s) 输出： [0 1 2 3 100 5 6 200 8 9] append 向 slice 尾部添加数据，返回新的 slice 对象。 12345s := make([]int, 0, 5)fmt.Printf(&quot;%p\\n&quot;, &amp;s)s2 := append(s, 1) // 值拷贝 fmt.Printf(&quot;%p\\n&quot;, &amp;s2)fmt.Println(s, s2) 输出： 0x2102300000x210230040[] [1] 简单点说，就是在 array[slice.high] 写数据。 123456data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s := data[:3]s2 := append(s, 100, 200) // 添加多个值。fmt.Println(data)fmt.Println(s)fmt.Println(s2) 输出： [0 1 2 100 200 5 6 7 8 9][0 1 2][0 1 2 100 200] 一旦超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。 12345data := [...]int{0, 1, 2, 3, 4, 10: 0}s := data[:2:3]s = append(s, 100, 200) // 一次 append 两个值，超出 s.cap 限制。fmt.Println(s, data) // 重新分配底层数组，与原数组⽆无关。fmt.Println(&amp;s[0], &amp;data[0]) // 比对底层数组起始指针。 输出： [0 1 100 200] [0 1 2 3 4 0 0 0 0 0 0]0x20819c180 0x20817c0c0 从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够⻓长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。 123456789s := make([]int, 0, 1)c := cap(s)for i := 0; i &lt; 50; i++ { s = append(s, i) if n := cap(s); n &gt; c { fmt.Printf(&quot;cap: %d -&gt; %d\\n&quot;, c, n) c = n }} 输出： cap: 1 -&gt; 2 cap: 2 -&gt; 4 cap: 4 -&gt; 8 cap: 8 -&gt; 16 cap: 16 -&gt; 32 cap: 32 -&gt; 64 copy 它只能用于切片，不能用于 map 等任何其他类型 它返回结果为一个 int 型值，表示 copy 的长度 切片 dst 需要先初始化长度 1func copy(dst, src []Type) int 如果 dst 长度小于 src 的长度，则 copy 部分。 如果大于，则全部拷贝过来，只是没占满 dst 的坑位而已，不会扩大被复制的cap。 相等时刚好不多不少 copy 过来。 函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。 123456data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s := data[8:]s2 := data[:5]copy(s2, s) // dst:s2, src:sfmt.Println(s2)fmt.Println(data) 输出： [8 9 2 3 4][8 9 2 3 4 5 6 7 8 9] 应及时将所需数据 copy 到较小的 slice，以便释放超大号底层数组内存。 源切片中元素类型为引用类型时，拷贝的是引用 1234567891011func wrongCopyMatrix() { matA := [][]int{ {0, 1, 1, 0}, {0, 1, 1, 1}, {1, 1, 1, 0}, } matB := make([][]int, len(matA)) copy(matB, matA) fmt.Printf(&quot;%p, %p\\n&quot;, matA, matA[0]) // 0xc0000c0000, 0xc0000c2000 fmt.Printf(&quot;%p, %p\\n&quot;, matB, matB[0]) // 0xc0000c0050, 0xc0000c2000} 如果想 copy 多维切片中的每一个切片类型的元素，那么你需要将每个切片元素进行 初始化 并 拷贝。注意是两步：先 初始化，再 拷贝。 正确的拷贝一个多维数组： 1234567891011121314func rightCopyMatrix() { matA := [][]int{ {0, 1, 1, 0}, {0, 1, 1, 1}, {1, 1, 1, 0}, } matB := make([][]int, len(matA)) for i := range matA { matB[i] = make([]int, len(matA[i])) // 注意初始化长度 copy(matB[i], matA[i]) } fmt.Printf(&quot;%p, %p\\n&quot;, matA, matA[0]) // 0xc00005c050, 0xc000018560 fmt.Printf(&quot;%p, %p\\n&quot;, matB, matB[0]) // 0xc00005c0a0, 0xc0000185c0}","link":"/2022/10/30/Go/%E6%95%B0%E6%8D%AE/"},{"title":"数组与切片","text":"数组 数组是由相同类型元素的集合组成的数据结构 数组大小在初始化之后就无法改变 数组创建可以显式指定数组的大小,也可以根据源代码自定推断数组的大小,不过后者在编译期间会被转换前一种 切片 切片其实就是动态数组,长度不固定","link":"/2022/11/01/Go/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"title":"数组与切片有什么异同","text":"slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。 数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。 而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。 数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。 123456// runtime/slice.gotype slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量} slice 的数据结构如下： 注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。 【引申1】 [3]int 和 [4]int 是同一个类型吗？不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。 【引申2】 下面的代码输出是什么？123456789101112131415161718package mainimport &quot;fmt&quot;func main() { slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := slice[2:5] s2 := s1[2:6:7] //注意这个7表示是2-&gt;7 也就是容量开始和结束位置 s2 = append(s2, 100) s2 = append(s2, 200) s1[2] = 20 fmt.Println(s1) fmt.Println(s2) fmt.Println(slice)} 结果： 123[2 3 20][4 5 6 7 100 200][0 1 2 3 20 5 6 7 100 9] s1 从 slice 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 s2 从 s1 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。 接着，向 s2 尾部追加一个元素 100： 1s2 = append(s2, 100) s2 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 s1 都可以看得到。 再次向 s2 追加元素200： 1s2 = append(s2, 100) 这时，s2 的容量不够用，该扩容了。于是，s2 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 append 带来的再一次扩容，s2 会在此次扩容的时候多留一些 buffer，将新的容量将扩大为原始容量的2倍，也就是10了。 最后，修改 s1 索引为2位置的元素： 1s1[2] = 20 这次只会影响原始数组相应位置的元素。它影响不到 s2 了，人家已经远走高飞了。 再提一点，打印 s1 的时候，只会打印出 s1 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。","link":"/2022/10/17/Go/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C/"},{"title":"类型","text":"变量 Go 是静态类型语言，不能在运行期改变变量类型。 使用关键字 var 定义变量，自动初始化为零值。如果提供初始化值，可省略变量类型，由编译器自动推断。 123var x intvar f float32 = 1.6var s = &quot;abc&quot; 全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。 在函数内部，可用更简略的 “:=” 方式定义变量。 123func main() { x := 123 // 注意检查，是定义新局部变量，还是修改全局变量。该方式容易造成错误。} 多变量赋值时，先计算所有相关值，然后再从左到右依次赋值。 12data, i := [3]int{0, 1, 2}, 0i, data[i] = 2, 100 // (i = 0) -&gt; (i = 2), (data[0] = 100) 特殊只写变量 “_”，用于忽略值占位。 12345678func test() (int, string) { return 1, &quot;abc&quot;}func main() { _, s := test() println(s)} 编译器会将未使用的局部变量当做错误。 1234var s string // 全局变量没问题。func main() { i := 0 // Error: i declared and not used。(可使用 &quot;_ = i&quot; 规避)} 注意重新赋值与定义新同名变量的区别。 123456789101112func main() { s := &quot;abc&quot; println(&amp;s) s, y := &quot;hello&quot;, 20 // 重新赋值: 与前 s 在同一层次的代码块中，且有新的变量被定义。 println(&amp;s, y) // 通常函数多返回值 err 会被重复使⽤用。 { s, z := 1000, 30 // 定义新同名变量: 不在同一层次代码块。 println(&amp;s, z) }} 常量 常量值必须是编译期可确定的数字、字符串、布尔值。 1234567891011const x, y int = 1, 2 // 多常量初始化const s = &quot;Hello, World!&quot; // 类型推断const ( // 常量组 a, b = 10, 100 c bool = false)func main() { const x = &quot;xxx&quot; // 未使用局部常量不会引发编译错误。} 在常量组中，如不提供类型和初始化值，那么视作与上一常量相同。 1234const ( s = &quot;abc&quot; x // x = &quot;abc&quot;) 常量值还可以是 len、cap、unsafe.Sizeof 等编译期可确定结果的函数返回值。 12345const ( a = &quot;abc&quot; b = len(a) c = unsafe.Sizeof(b)) 如果常量类型足以存储初始化值，那么不会引发溢出错误。 1234const ( a byte = 100 // int to byte b int = 1e20 // float64 to int, overflows) 常量不能使用 “:=” 语法定义。 枚举 关键字 iota 定义常量组中从 0 开始按行计数的自增枚举值。 123456789const ( Sunday = iota // 0 Monday // 1，通常省略后续行表达式。 Tuesday // 2 Wednesday // 3 Thursday // 4 Friday // 5 Saturday // 6) 1234567const ( _ = iota // iota = 0 KB int64 = 1 &lt;&lt; (10 * iota) // iota = 1 MB // 与 KB 表达式相同，但 iota = 2 GB TB) 在同一常量组中，可以提供多个 iota，它们各自增长。 1234const ( A, B = iota, iota &lt;&lt; 10 // 0, 0 &lt;&lt; 10 C, D // 1, 1 &lt;&lt; 10) 如果 iota 自增被打断，须显式恢复。 12345678const ( A = iota // 0 B // 1 C = &quot;c&quot; // c D // c，与上一⾏行相同。 E = iota // 4，显式恢复。注意计数包含了 C、D 两行。 F // 5) 可通过自定义类型来实现枚举类型限制。 12345678910111213141516type Color intconst ( Black Color = iota Red Blue)func test(c Color) {}func main() { c := Black test(c) x := 1 test(x) // Error: cannot use x (type int) as type Color in function argument test(1) // 常量会被编译器自动转换。} 基本类型 更明确的数字类型命名，支持 Unicode，支持常用数据结构。 支持八进制、十六进制，以及科学记数法。标准库 math 定义了各数字类型取值范围。 1a, b, c, d := 071, 0x1F, 1e9, math.MinInt16 空指针值 nil，而非 C/C++ NULL。 引用类型 引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。 内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。 12345678a := []int{0, 0, 0} // 提供初始化表达式。a[1] = 10b := make([]int, 3) // makesliceb[1] = 10c := new([]int)c[1] = 10 // Error: invalid operation: c[1] (index of type *[]int)d := new(int)*d = 10 类型转换 不支持隐式类型转换，即便是从窄向宽转换也不行。 123var b byte = 100// var n int = b // Error: cannot use b (type byte) as type int in assignmentvar n int = int(b) // 显式转换 使用括号避免优先级错误。 1234*Point(p) // 相当于 *(Point(p))(*Point)(p)&lt;-chan int(c) // 相当于 &lt;-(chan int(c))(&lt;-chan int)(c) 同样不能将其他类型当 bool 值使用。 1234a := 100if a { // Error: non-bool a (type int) used as if condition println(&quot;true&quot;)} 字符串 字符串是不可变值类型，内部用指针指向 UTF-8 字节数组。 默认值是空字符串 “”。 用索引号访问某字节，如 s[i]。 不能用序号获取字节元素指针，&amp;s[i] 非法。 不可变类型，无法修改字节数组。 字节数组尾部不包含 NULL。 在go中源代码src/builtin/builtin.go中定义了string标准概念： 1234// string is the set of all strings of 8-bit bytes, conventionally but not// necessarily representing UTF-8-encoded text. A string may be empty, but// not nil. Values of string type are immutable.type string string string是8bit字节的集合，通常是但并不一定非得是UTF-8编码的文本。 string可以为空(长度为0)，但不会是nil。 string对象不可以修改。 在go源代码src/runtime/string.go:stringStruct中定义了string的数据结构： 1234type stringStruct struct { str unsafe.Pointer //字符串首地址，指向底层字节数组的指针 len int //字符串长度} 使用 “`” 定义不做转义处理的原始字符串，支持跨行。 123456func main() { s := `ab\\r\\n\\x00c` println(s)} 输出： ab\\r\\n\\x00c 连接跨行字符串时，”+” 必须在上一行末尾，否则导致编译错误。 1234s := &quot;Hello, &quot; +&quot;World!&quot;s2 := &quot;Hello, &quot;+ &quot;World!&quot; // Error: invalid operation: + untyped string 单引号字符常量表示 Unicode Code Point，支持 \\uFFFF、\\U7FFFFFFF、\\xFF 格式。对应 rune 类型，UCS-4。 12345func main() { fmt.Printf(&quot;%T\\n&quot;, 'a') var c1, c2 rune = '\\u6211', '们' println(c1 == '我', string(c2) == &quot;\\xe4\\xbb\\xac&quot;)} 输出： int32 // rune 是 int32 的别名true true 要修改字符串，可先将其转换成 []rune 或 []byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。 12345678910func main() { s := &quot;abcd&quot; bs := []byte(s) bs[1] = 'B' println(string(bs)) u := &quot;电脑&quot; us := []rune(u) us[1] = '话' println(string(us))} 输出： aBcd电话 用 for 循环遍历字符串时，也有 byte 和 rune 两种方式。 12345678910func main() { s := &quot;abc汉字&quot; for i := 0; i &lt; len(s); i++ { // byte fmt.Printf(&quot;%c,&quot;, s[i]) } fmt.Println() for _, r := range s { // rune fmt.Printf(&quot;%c,&quot;, r) }} 输出： a,b,c,æ,±,,å,­,,a,b,c,汉,字, 指针 支持指针类型 *T，指针的指针 **T，以及包含包名前缀的 *.T。 默认值 nil，没有 NULL 常量。 操作符 “&amp;” 取变量地址，”*” 透过指针访问目标对象。 不支持指针运算，不支持 “-&gt;” 运算符，直接用 “.” 访问目标成员。 不能对指针做加减法等运算。 123x := 1234p := &amp;xp++ // Error: invalid operation: p += 1 (mismatched types *int and int) 可以在 unsafe.Pointer 和任意类型指针间进行转换。 12345678func main() { x := 0x12345678 p := unsafe.Pointer(&amp;x) // *int -&gt; Pointer n := (*[4]byte)(p) // Pointer -&gt; *[4]byte for i := 0; i &lt; len(n); i++ { fmt.Printf(&quot;%X &quot;, n[i]) }} 输出： 78 56 34 12 返回局部变量指针是安全的，编译器会根据需要将其分配在 GC Heap 上。 1234func test() *int { x := 100 return &amp;x // 在堆上分配 x 内存。但在内联时，也可能直接分配在目标栈。} 将 Pointer 转换成 uintptr，可变相实现指针运算。 123456789101112func main() { d := struct { s string x int }{&quot;abc&quot;, 100} p := uintptr(unsafe.Pointer(&amp;d)) // *struct -&gt; Pointer -&gt; uintptr p += unsafe.Offsetof(d.x) // uintptr + offset p2 := unsafe.Pointer(p) // uintptr -&gt; Pointer px := (*int)(p2) // Pointer -&gt; *int *px = 200 // d.x = 200 fmt.Printf(&quot;%#v\\n&quot;, d)} 输出： struct { s string; x int }{s:”abc”, x:200} 注意：GC 把 uintptr 当成普通整数对象，它无法阻止 “关联” 对象被回收。 自定义类型 可将类型分为命名和未命名两大类。命名类型包括 bool、int、string 等，而 array、slice、map 等和具体元素类型、长度等有关，属于未命名类型。 具有相同声明的未命名类型被视为同一类型。 具有相同基类型的指针。 具有相同元素类型和长度的 array。 具有相同元素类型的 slice。 具有相同键值类型的 map。 具有相同元素类型和传送方向的 channel。 具有相同字段序列 (字段名、类型、标签、顺序) 的匿名 struct。 签名相同 (参数和返回值，不包括参数名称) 的 function。 方法集相同 (方法名、方法签名相同，和次序无关) 的 interface。 可用 type 在全局或函数内定义新类型。 12345func main() { type bigint int64 var x bigint = 100 println(x)} 新类型不是原类型的别名，除拥有相同数据存储结构外，它们之间没有任何关系，不会持有原类型任何信息。除非目标类型是未命名类型，否则必须显式转换。 12345x := 1234var b bigint = bigint(x) // 必须显式转换，除⾮非是常量。var b2 int64 = int64(b)var s myslice = []int{1, 2, 3} // 未命名类型，隐式转换。var s2 []int = s","link":"/2022/10/27/Go/%E7%B1%BB%E5%9E%8B/"},{"title":"表达式","text":"保留字 语言设计简练，保留字不多。 运算符 全部运算符、分隔符，以及其他符号。 运算符结合律全部从左到右。 简单位运算演示。 如果运算符右侧数值的第 i 位为 1，那么计算结果中的第 i 位为 0；如果运算符右侧数值的第 i 位为 0，那么计算结果中的第 i 位为运算符左侧数值的第 i 位的值。 标志位操作。 1234a := 0a |= 1 &lt;&lt; 2 // 0000100: 在 bit2 设置标志位。a |= 1 &lt;&lt; 6 // 1000100: 在 bit6 设置标志位a = a &amp;^ (1 &lt;&lt; 6) // 0000100: 清除 bit6 标志位。 不支持运算符重载。尤其需要注意，”++”、”–” 是语句而非表达式。 123456789n := 0p := &amp;n// b := n++ // syntax error// if n++ == 1 {} // syntax error// ++n // syntax errorn++*p++ // (*p)++ 没有 “~”，取反运算也用 “^”。 12x := 1x, ^x // 0001, -0010 初始化 初始化复合对象，必须使用类型标签，且左大括号必须在类型尾部。 1234567// var a struct { x int } = { 100 } // syntax error// var b []int = { 1, 2, 3 } // syntax error// c := struct {x int; y string} // syntax error: unexpected semicolon or newline// {// }var a = struct{ x int }{100}var b = []int{1, 2, 3} 初始化值以 “,” 分隔。可以分多行，但最后一行必须以 “,” 或 “}” 结尾。 1234567891011a := []int{ 1, 2 // Error: need trailing comma before newline in composite literal}a := []int{ 1, 2, // ok}b := []int{ 1, 2 } // ok 控制流IF 可省略条件表达式括号。 支持初始化语句，可定义代码块局部变量。 代码块左大括号必须在条件表达式尾部。 1234567891011x := 0// if x &gt; 10 // Error: missing condition in if statement// {// }if n := &quot;abc&quot;; x &gt; 0 { // 初始化语句未必就是定义变量，比如 println(&quot;init&quot;) 也是可以的。 println(n[2])} else if x &lt; 0 { // 注意 else if 和 else 左大括号位置。 println(n[1])} else { println(n[0])} 不支持三元操作符 “a &gt; b ? a : b”。 For 支持三种循环方式，包括类 while 语法。 123456789101112s := &quot;abc&quot;for i, n := 0, len(s); i &lt; n; i++ { // 常见的 for 循环，支持初始化语句。 println(s[i])}n := len(s)for n &gt; 0 { // 替代 while (n &gt; 0) {} println(s[n-1]) // 替代 for (; n &gt; 0;) {} n--}for { // 替代 while (true) {} println(s) // 替代 for (;;) {}} 不要期望编译器能理解你的想法，在初始化语句中计算出全部结果是个好主意。 12345678910func length(s string) int { println(&quot;call length.&quot;) return len(s)}func main() { s := &quot;abcd&quot; for i, n := 0, length(s); i &lt; n; i++ { // 避免多次调⽤用 length 函数。 println(i, s[i]) }} 输出： call length.0 971 982 993 100 Range 类似迭代器操作，返回 (索引, 值) 或 (键, 值)。 可忽略不想要的返回值，或用 “_” 这个特殊变量。 1234567891011121314s := &quot;abc&quot;for i := range s { // 忽略 2nd value，支持 string/array/slice/map。println(s[i])}for _, c := range s { // 忽略 index。println(c)}for range s { // 忽略全部返回值，仅迭代。...}m := map[string]int{&quot;a&quot;: 1, &quot;b&quot;: 2}for k, v := range m { // 返回 (key, value)。println(k, v)} 注意，range 会复制对象。 123456789a := [3]int{0, 1, 2}for i, v := range a { // index、value 都是从复制品中取出。 if i == 0 { // 在修改前，我们先修改原数组。 a[1], a[2] = 999, 999 fmt.Println(a) // 确认修改有效，输出 [0, 999, 999]。 } a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。}fmt.Println(a) // 输出 [100, 101, 102]。 建议改用引用类型，其底层数据不会被复制。 12345678s := []int{1, 2, 3, 4, 5}for i, v := range s { // 复制 struct slice { pointer, len, cap }。 if i == 0 { s = s[:3] // 对 slice 的修改，不会影响 range。 s[2] = 100 // 对底层数据的修改。 } println(i, v)} 输出： 0 11 22 1003 44 5 Switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。 12345678910x := []int{1, 2, 3}i := 2switch i {case x[1]: println(&quot;a&quot;)case 1, 3: println(&quot;b&quot;)default: println(&quot;c&quot;)} 输出： a 如需要继续下一分支，可使用 fallthrough，但不再判断条件。 12345678x := 10switch x {case 10: println(&quot;a&quot;) fallthroughcase 0: println(&quot;b&quot;)} 输出： a b 省略条件表达式，可当 if…else if…else 使用。 1234567891011121314151617x := []int{1, 2, 3}switch {case x[1] &gt; 0: println(&quot;a&quot;)case x[1] &lt; 0: println(&quot;b&quot;)default: println(&quot;c&quot;)}switch i := x[2]; { // 带初始化语句case i &gt; 0: println(&quot;a&quot;)case i &lt; 0: println(&quot;b&quot;)default: println(&quot;c&quot;)} Goto, Break, Continue 支持在函数内 goto 跳转。标签名区分大小写，未使用标签引发错误。 12345678910111213func main() { var i int for { println(i) i++ if i &gt; 2 { goto BREAK } }BREAK: println(&quot;break&quot;)EXIT: // Error: label EXIT defined and not used} break用来结束最里面的for/select/switch的语句，如果这里有标签，那么它必须在for/select/switch的正上面。 配合标签，break 和 continue 可在多级嵌套循环中跳出。 12345678910111213141516func main() {L1: for x := 0; x &lt; 3; x++ { L2: for y := 0; y &lt; 5; y++ { if y &gt; 2 { continue L2 } if x &gt; 1 { break L1 } print(x, &quot;:&quot;, y, &quot; &quot;) } println() }} 输出： 0:0 0:1 0:21:0 1:1 1:2 break 可用于 for、switch、select，而 continue 仅能用于 for 循环。","link":"/2022/10/28/Go/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"错误处理","text":"Go语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种异常，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover。 panic 内建函数 panic是内建函数.panic会中断函数F的正常执行流程, 从F函数中跳出来, 跳回到F函数的调用者. 对于调用者来说, F看起来就是一个panic, 所以调用者会继续向上跳出, 直到当前goroutine返回. 在跳出的过程中, 进程会保持这个函数栈. 当goroutine退出时, 程序会crash F函数中的defer函数会正常执行 除了主动调用panic之外, 其他的任何运行时错误, 例如数组越界都会造成panic panic 只会触发当前 Goroutine 的延迟函数调用 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { // 主线程中的defer函数并不会执行，因为子协程 panic后，主线程中的defer并不会执行 defer println(&quot;in main&quot;) go func() { defer println(&quot;in goroutine&quot;) fmt.Println(&quot;子协程running&quot;) panic(&quot;子协程崩溃&quot;) }() time.Sleep(1 * time.Second)} 输出： 子协程runningin goroutinepanic: 子协程崩溃 延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获 123456789101112131415func test() { defer func() { fmt.Println(recover()) }() defer func() { panic(&quot;defer1 panic&quot;) }() defer func() { panic(&quot;defer2 panic&quot;) }() panic(&quot;test panic&quot;)}func main() { test()} 输出： defer1 panic recover 内建函数 recover如果想起作用的话, 必须在defer函数中使用 直接调用时无效 1234func main() { recover() panic(1)} 直接 defer 调用也是无效 1234func main() { defer recover() panic(1)} defer 调用时多层嵌套依然无效 123456func main() { defer func() { func() { recover() }() }() panic(1)} 必须在 defer 函数中直接调用才有效 123456func main() { defer func() { recover() }() panic(1)} 或下面这样也是有效的 1234567func except() { recover()}func test() { defer except() panic(&quot;test panic&quot;)} 在正常函数执行过程中, 调用recover没有任何作用, 他会返回nil. 如这样:fmt.Println(recover()) // nil 如果当前的goroutine panic了, 那么recover将会捕获这个panic的值, 并且让程序正常执行下去, 不会让程序crash 在当前goroutine的中, recover会捕获recover所在的函数产生的的panic, 由于panic会让当前函数返回, 但是对于其调用者来说, 这个panic已经不存在了, 所以程序还是会按照正常的执行流程执行下去 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func main() { f() fmt.Println(&quot;Returned normally from f.&quot;)}func f() { defer func() { if r := recover(); r != nil { fmt.Println(&quot;Recovered in f&quot;, r) } }() fmt.Println(&quot;Calling g.&quot;) g(0) fmt.Println(&quot;Returned normally from g.&quot;)}func g(i int) { if i &gt; 3 { fmt.Println(&quot;Panicking!&quot;) panic(fmt.Sprintf(&quot;%v&quot;, i)) } defer fmt.Println(&quot;Defer in g&quot;, i) fmt.Println(&quot;Printing in g&quot;, i) g(i + 1)} 输出：（**fmt.Println(&quot;Returned normally from g.&quot;)没有打印, 而fmt.Println(&quot;Returned normally from f.&quot;)打印了**） Calling g.Printing in g 0Printing in g 1Printing in g 2Printing in g 3Panicking!Defer in g 3Defer in g 2Defer in g 1Defer in g 0Recovered in f 4Returned normally from f. 如果需要保护代码片段，可将代码块重构成匿名函数，如此可确保后续代码被执行 12345678910111213func test(x, y int) { var z int func() { defer func() { if recover() != nil { z = 0 } }() z = x / y return }() println(&quot;x / y =&quot;, z)} 由于 panic、recover 参数类型为 interface{}，因此可抛出任何类型对象 error error：可预见的错误 panic：不可预见的异常 需要注意的是，你应该尽可能地使用error，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制。 go中的error是一个接口类型 12345// The error built-in interface type is the conventional interface for// representing an error condition, with the nil value representing no error.type error interface { Error() string} 从定义看出，Go中的error是一个简单的接口，接口定义了一个Error()方法，其返回值为string。 12345678910111213// src/errors/errors.gofunc New(text string) error { return &amp;errorString{text}}type errorString struct { s string}func (e *errorString) Error() string { return e.s} 使用 New 函数创建出来的 error 类型实际上是 errors 包里未导出的 errorString 类型，它包含唯一的一个字段 s，并且实现了唯一的方法：Error() string。 为什么是返回指针，不是返回结构体对象本身呢？ 就是为了避免定义两个同样错误内容的不同自定义错误做==判定的时候会相等，但是指针的话，就是比较两个不一样的地址，就不会相等。 举个使用的例子： 12345678910111213141516var ErrDivByZero = errors.New(&quot;division by zero&quot;)func div(x, y int) (int, error) { if y == 0 { return 0, ErrDivByZero } return x / y, nil}func main() { switch z, err := div(10, 0); err { case nil: println(z) case ErrDivByZero: panic(err) }} go中的错误处理，是通过返回值的形式来出来，要么你忽略，要么你处理（处理也可以是继续返回给调用者），对于golang这种设计方式，我们会在代码中写大量的if判断，以便做出决定。 12345678func main() { conent,err:=ioutil.ReadFile(&quot;filepath&quot;) if err !=nil{ //错误处理 }else { fmt.Println(string(conent)) }} 对于err如果是nil就代表没有错误，如果不是nil就代表程序出问题了，需要对错误进行处理了。","link":"/2022/10/30/Go/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"title":"MySQL面试题","text":"基础执行一条 select 语句，期间发生了什么？ 如何查看 MySQL 服务被多少个客户端连接了？ 空闲连接会一直占用着吗？ MySQL 的连接数有限制吗？ 怎么解决长连接占用内存的问题？ 12345678910连接器：建立连接，管理连接、校验用户身份；查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；执行 SQL：执行 SQL 共有三个阶段： 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划； 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端； 参考：执行一条 select 语句，期间发生了什么？","link":"/2022/11/05/MySQL/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"PHP速成","text":"这份教程所使用的版本是 PHP 5+. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614&lt;?php // PHP必须被包围于 &lt;?php ? &gt; 之中// 如果你的文件中只有php代码，那么最好省略结束括号标记// 这是单行注释的标志# 井号也可以，但是//更常见/* 这是多行注释*/// 使用 &quot;echo&quot; 或者 &quot;print&quot; 来输出信息到标准输出print('Hello '); // 输出 &quot;Hello &quot; 并且没有换行符// () 对于echo和print是可选的echo &quot;World\\n&quot;; // 输出 &quot;World&quot; 并且换行// (每个语句必须以分号结尾)// 在 &lt;?php 标签之外的语句都被自动输出到标准输出?&gt;Hello World Again!&lt;?php/************************************ * 类型与变量 */// 变量以$开始// 变量可以以字母或者下划线开头，后面可以跟着数字、字母和下划线// 布尔值是大小写无关的$boolean = true; // 或 TRUE 或 True$boolean = false; // 或 FALSE 或 False// 整型$int1 = 12; // =&gt; 12$int2 = -12; // =&gt; -12$int3 = 012; // =&gt; 10 (0开头代表八进制数)$int4 = 0x0F; // =&gt; 15 (0x开头代表十六进制数)// 浮点型 (即双精度浮点型)$float = 1.234;$float = 1.2e3;$float = 7E-10;// 算数运算$sum = 1 + 1; // 2$difference = 2 - 1; // 1$product = 2 * 2; // 4$quotient = 2 / 1; // 2// 算数运算的简写$number = 0;$number += 1; // $number 自增1echo $number++; // 输出1 (运算后自增)echo ++$number; // 输出3 (自增后运算)$number /= $float; // 先除后赋值给 $number// 字符串需要被包含在单引号之中$sgl_quotes = '$String'; // =&gt; '$String'// 如果需要在字符串中引用变量，就需要使用双引号$dbl_quotes = &quot;This is a $sgl_quotes.&quot;; // =&gt; 'This is a $String.'// 特殊字符只有在双引号中有用$escaped = &quot;This contains a \\t tab character.&quot;;$unescaped = 'This just contains a slash and a t: \\t';// 可以把变量包含在一对大括号中$money = &quot;I have $${number} in the bank.&quot;;// 自 PHP 5.3 开始, nowdocs 可以被用作多行非计算型字符串$nowdoc = &lt;&lt;&lt;'END'Multi linestringEND;// 而Heredocs则可以用作多行计算型字符串$heredoc = &lt;&lt;&lt;ENDMulti line$sgl_quotesEND;// 字符串需要用 . 来连接echo 'This string ' . 'is concatenated';/******************************** * 数组 */// PHP 中的数组都是关联型数组，也就是某些语言中的哈希表或字典// 在所有PHP版本中均适用：$associative = array('One' =&gt; 1, 'Two' =&gt; 2, 'Three' =&gt; 3);// PHP 5.4 中引入了新的语法$associative = ['One' =&gt; 1, 'Two' =&gt; 2, 'Three' =&gt; 3];echo $associative['One']; // 输出 1// 声明为列表实际上是给每个值都分配了一个整数键（key）$array = ['One', 'Two', 'Three'];echo $array[0]; // =&gt; &quot;One&quot;/******************************** * 输出 */echo('Hello World!');// 输出到标准输出// 此时标准输出就是浏览器中的网页print('Hello World!'); // 和echo相同// echo和print实际上也属于这个语言本身，所以我们省略括号echo 'Hello World!';print 'Hello World!'; $paragraph = 'paragraph';echo 100; // 直接输出标量echo $paragraph; // 或者输出变量// 如果你配置了短标签，或者使用5.4.0及以上的版本// 你就可以使用简写的echo语法?&gt;&lt;p&gt;&lt;?= $paragraph ?&gt;&lt;/p&gt;&lt;?php$x = 1;$y = 2;$x = $y; // $x 现在和 $y 的值相同$z = &amp;$y;// $z 现在持有 $y 的引用. 现在更改 $z 的值也会更改 $y 的值，反之亦然// 但是改变 $y 的值不会改变 $x 的值echo $x; // =&gt; 2echo $z; // =&gt; 2$y = 0;echo $x; // =&gt; 2echo $z; // =&gt; 0/******************************** * 逻辑 */$a = 0;$b = '0';$c = '1';$d = '1';// 如果assert的参数为假，就会抛出警告// 下面的比较都为真，不管它们的类型是否匹配assert($a == $b); // 相等assert($c != $a); // 不等assert($c &lt;&gt; $a); // 另一种不等的表示assert($a &lt; $c);assert($c &gt; $b);assert($a &lt;= $b);assert($c &gt;= $d);// 下面的比较只有在类型相同、值相同的情况下才为真assert($c === $d);assert($a !== $d);assert(1 === '1');assert(1 !== '1');// 变量可以根据其使用来进行类型转换$integer = 1;echo $integer + $integer; // =&gt; 2$string = '1';echo $string + $string; // =&gt; 2 (字符串在此时被转化为整数)$string = 'one';echo $string + $string; // =&gt; 0// 输出0，因为'one'这个字符串无法被转换为整数// 类型转换可以将一个类型视作另一种类型$boolean = (boolean) 1; // =&gt; true$zero = 0;$boolean = (boolean) $zero; // =&gt; false// 还有一些专用的函数来进行类型转换$integer = 5;$string = strval($integer);$var = null; // 空值/******************************** * 控制结构 */if (true) { print 'I get printed';}if (false) { print 'I don\\'t';} else { print 'I get printed';}if (false) { print 'Does not get printed';} elseif(true) { print 'Does';}// 三目运算符print (false ? 'Does not get printed' : 'Does');$x = 0;if ($x === '0') { print 'Does not print';} elseif($x == '1') { print 'Does not print';} else { print 'Does print';}// 下面的语法常用于模板中:?&gt;&lt;?php if ($x): ?&gt;This is displayed if the test is truthy.&lt;?php else: ?&gt;This is displayed otherwise.&lt;?php endif; ?&gt;&lt;?php// 用switch来实现相同的逻辑switch ($x) { case '0': print 'Switch does type coercion'; break; // 在case中必须使用一个break语句， // 否则在执行完这个语句后会直接执行后面的语句 case 'two': case 'three': // 如果$variable是 'two' 或 'three'，执行这里的语句 break; default: // 其他情况}// While, do...while 和 for 循环$i = 0;while ($i &lt; 5) { echo $i++;}; // 输出 &quot;01234&quot;echo &quot;\\n&quot;;$i = 0;do { echo $i++;} while ($i &lt; 5); // 输出 &quot;01234&quot;echo &quot;\\n&quot;;for ($x = 0; $x &lt; 10; $x++) { echo $x;} // 输出 &quot;0123456789&quot;echo &quot;\\n&quot;;$wheels = ['bicycle' =&gt; 2, 'car' =&gt; 4];// Foreach 循环可以遍历数组foreach ($wheels as $wheel_count) { echo $wheel_count;} // 输出 &quot;24&quot;echo &quot;\\n&quot;;// 也可以同时遍历键和值foreach ($wheels as $vehicle =&gt; $wheel_count) { echo &quot;A $vehicle has $wheel_count wheels&quot;;}echo &quot;\\n&quot;;$i = 0;while ($i &lt; 5) { if ($i === 3) { break; // 退出循环 } echo $i++;} // 输出 &quot;012&quot;for ($i = 0; $i &lt; 5; $i++) { if ($i === 3) { continue; // 跳过此次遍历 } echo $i;} // 输出 &quot;0124&quot;/******************************** * 函数 */// 通过&quot;function&quot;定义函数:function my_function () { return 'Hello';}echo my_function(); // =&gt; &quot;Hello&quot;// 函数名需要以字母或者下划线开头, // 后面可以跟着任意的字母、下划线、数字.function add ($x, $y = 1) { // $y 是可选参数，默认值为 1 $result = $x + $y; return $result;}echo add(4); // =&gt; 5echo add(4, 2); // =&gt; 6// $result 在函数外部不可访问// print $result; // 抛出警告// 从 PHP 5.3 起我们可以定义匿名函数$inc = function ($x) { return $x + 1;};echo $inc(2); // =&gt; 3function foo ($x, $y, $z) { echo &quot;$x - $y - $z&quot;;}// 函数也可以返回一个函数function bar ($x, $y) { // 用 'use' 将外部的参数引入到里面 return function ($z) use ($x, $y) { foo($x, $y, $z); };}$bar = bar('A', 'B');$bar('C'); // 输出 &quot;A - B - C&quot;// 你也可以通过字符串调用函数$function_name = 'add';echo $function_name(1, 2); // =&gt; 3// 在通过程序来决定调用哪个函数时很有用// 或者，使用 call_user_func(callable $callback [, $parameter [, ... ]]);/******************************** * 导入 */&lt;?php// 被导入的php文件也必须以php开标签开始include 'my-file.php';// 现在my-file.php就在当前作用域中可见了// 如果这个文件无法被导入（比如文件不存在），会抛出警告include_once 'my-file.php';// my-file.php中的代码在其他地方被导入了，那么就不会被再次导入// 这会避免类的多重定义错误require 'my-file.php';require_once 'my-file.php';// 和include功能相同，只不过如果不能被导入时，会抛出错误// my-include.php的内容:&lt;?phpreturn 'Anything you like.';// 文件结束// Include和Require函数也有返回值$value = include 'my-include.php';// 被引入的文件是根据文件路径或者include_path配置来查找到的// 如果文件最终没有被找到，那么就会查找当前文件夹。之后才会报错/* *//******************************** * 类 */// 类是由class关键字定义的class MyClass{ const MY_CONST = 'value'; // 常量 static $staticVar = 'static'; // 属性必须声明其作用域 public $property = 'public'; public $instanceProp; protected $prot = 'protected'; // 当前类和子类可访问 private $priv = 'private'; // 仅当前类可访问 // 通过 __construct 来定义构造函数 public function __construct($instanceProp) { // 通过 $this 访问当前对象 $this-&gt;instanceProp = $instanceProp; } // 方法就是类中定义的函数 public function myMethod() { print 'MyClass'; } final function youCannotOverrideMe() { } public static function myStaticMethod() { print 'I am static'; }}echo MyClass::MY_CONST; // 输出 'value';echo MyClass::$staticVar; // 输出 'static';MyClass::myStaticMethod(); // 输出 'I am static';// 通过new来新建实例$my_class = new MyClass('An instance property');// 如果不传递参数，那么括号可以省略// 用 -&gt; 来访问成员echo $my_class-&gt;property; // =&gt; &quot;public&quot;echo $my_class-&gt;instanceProp; // =&gt; &quot;An instance property&quot;$my_class-&gt;myMethod(); // =&gt; &quot;MyClass&quot;// 使用extends来生成子类class MyOtherClass extends MyClass{ function printProtectedProperty() { echo $this-&gt;prot; } // 方法覆盖 function myMethod() { parent::myMethod(); print ' &gt; MyOtherClass'; }}$my_other_class = new MyOtherClass('Instance prop');$my_other_class-&gt;printProtectedProperty(); // =&gt; 输出 &quot;protected&quot;$my_other_class-&gt;myMethod(); // 输出 &quot;MyClass &gt; MyOtherClass&quot;final class YouCannotExtendMe{}// 你可以使用“魔法方法”来生成getter和setter方法class MyMapClass{ private $property; public function __get($key) { return $this-&gt;$key; } public function __set($key, $value) { $this-&gt;$key = $value; }}$x = new MyMapClass();echo $x-&gt;property; // 会使用 __get() 方法$x-&gt;property = 'Something'; // 会使用 __set() 方法// 类可以是被定义成抽象类 (使用 abstract 关键字) 或者// 去实现接口 (使用 implements 关键字).// 接口需要通过interface关键字来定义interface InterfaceOne{ public function doSomething();}interface InterfaceTwo{ public function doSomethingElse();}// 接口可以被扩展interface InterfaceThree extends InterfaceTwo{ public function doAnotherContract();}abstract class MyAbstractClass implements InterfaceOne{ public $x = 'doSomething';}class MyConcreteClass extends MyAbstractClass implements InterfaceTwo{ public function doSomething() { echo $x; } public function doSomethingElse() { echo 'doSomethingElse'; }}// 一个类可以实现多个接口class SomeOtherClass implements InterfaceOne, InterfaceTwo{ public function doSomething() { echo 'doSomething'; } public function doSomethingElse() { echo 'doSomethingElse'; }}/******************************** * 特征 */// 特征 从 PHP 5.4.0 开始包括，需要用 &quot;trait&quot; 这个关键字声明trait MyTrait{ public function myTraitMethod() { print 'I have MyTrait'; }}class MyTraitfulClass{ use MyTrait;}$cls = new MyTraitfulClass();$cls-&gt;myTraitMethod(); // 输出 &quot;I have MyTrait&quot;/******************************** * 命名空间 */// 这部分是独立于这个文件的// 因为命名空间必须在一个文件的开始处。&lt;?php// 类会被默认的放在全局命名空间中，可以被一个\\来显式调用$cls = new \\MyClass();// 为一个文件设置一个命名空间namespace My\\Namespace;class MyClass{}// (或者从其他文件中)$cls = new My\\Namespace\\MyClass;//或者从其他命名空间中namespace My\\Other\\Namespace;use My\\Namespace\\MyClass;$cls = new MyClass();// 你也可以为命名空间起一个别名namespace My\\Other\\Namespace;use My\\Namespace as SomeOtherNamespace;$cls = new SomeOtherNamespace\\MyClass();*/","link":"/2022/10/20/PHP/PHP%E9%80%9F%E6%88%90/"},{"title":"hexo踩坑——插入图片","text":"记录使用hexo时插入图片遇到的问题 在使用Typora+hexo插入图片时，图片加载失败，发现url路径存在问题 采用官方解决方案搜索之后发现官方有相应解决方案，但是官方的方案和markdown兼容差，所以放弃 参考： https://cloud.tencent.com/developer/article/1702112 https://hexo.io/zh-cn/docs/asset-folders.html 采用插件可以通过hexo-asset-image插件解决markdown兼容问题，但hexo-asset-image也存在图片路径存在多余域名导致无法解析的新问题，需要修改插件代码 参考： https://blog.csdn.net/weixin_44999716/article/details/112401495 https://wangwei1237.github.io/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/","link":"/2022/10/05/hexo/hexo%E8%B8%A9%E5%9D%911/"},{"title":"hexo踩坑——修改样式","text":"记录使用hexo修改样式时遇到的问题 在使用hexo时发现目录无法粘性定位，阅读文章时中间正文很窄需要修改样式等问题，所以找了找修改方案 修改样式需要以源码形式安装icarus参考文章修改源码后发现不生效，发现因为是用npm以包安装形式安装的，需要改成源码形式安装，卸载包后以源码形式安装 https://ppoffice.github.io/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#install-source 参考修改方案https://www.alphalxy.com/2019/03/customize-icarus/ https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/#more https://ppoffice.github.io/hexo-theme-icarus/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/","link":"/2022/10/08/hexo/hexo%E8%B8%A9%E5%9D%912/"},{"title":"hexo踩坑3","text":"修改正文字体修改themes\\icarus\\layout\\common\\head.jsx中fontCssUrl的字体，由于默认使用Google CDN，直接到fonts.google.com中找想要的字体再填入即可 12345const fontCssUrl = { //default: fontcdn('Ubuntu:wght@400;600&amp;family=Source+Code+Pro', 'css2'), default: fontcdn('Noto+Sans+SC:wght@400;600&amp;family=Roboto+Mono', 'css2'), cyberpunk: fontcdn('Oxanium:wght@300;400;600&amp;family=Roboto+Mono', 'css2')}; 参考：http://www.anticme.com/2021/03/26/icarus%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/ 修改代码字体修改themes\\icarus\\include\\style\\base.styl中family-code的字体 12$family-sans-serif ?= Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif$family-code ?= 'Noto Serif Simplified Chinese' family-sans-serif: 正文字体family-code: 代码字体没有办法通过设置单独修改每个元素的字体。想改只能在代码层面改。 参考：https://github.com/ppoffice/hexo-theme-icarus/discussions/913 不蒜子计数与live2d冲突参考：https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-live2-busuanzi-err/fluid-live2-busuanzi-err/","link":"/2022/10/28/hexo/hexo%E8%B8%A9%E5%9D%913/"},{"title":"二叉树","text":"什么是二叉树二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。 相关术语结点：包含一个数据元素及若干指向子树分支的信息。 结点的度：一个结点拥有子树的数据成为结点的度。 叶子结点：也称为终端结点，没有子树的结点或者度为零的结点。 分支结点：也称为非终端结点，度不为零的结点成为非终端结点。 结点的层次：从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推。 树的度：树中所有结点的度的最大值。 树的深度：树中结点的最大层次。 二叉树的种类满二叉树如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 完全二叉树在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。 二叉搜索树（二叉排序树、二叉查找树） 左子树的所有节点的值均小于它的根节点的值 右子树的所有节点的值均大于它的根节点的值 它的左右子树也分别为二叉搜索树 平衡二叉树（AVL树）平衡二叉树具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 红黑树——TODOB树——TODO堆——TODO二叉树的存储方式二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。 链式存储 顺序存储 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。 二叉树遍历二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 深度优先遍历 前序遍历 中序遍历 后序遍历 深度优先遍历经常使用递归的方式来实现，栈其实就是递归的一种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。 这里前中后，其实指的就是中间节点的遍历顺序，只要记住 前中后序指的就是中间节点的位置就可以了。 广度优先遍历 层次遍历 广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树定义C++123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; Python12345class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None Go12345type TreeNode struct { Val int Left *TreeNode Right *TreeNode} 例题二叉树遍历 —— 二叉树遍历模板 144. 二叉树的前序遍历 145. 二叉树的后序遍历 94. 二叉树的中序遍历 102. 二叉树的层序遍历 107. 二叉树的层次遍历II 199. 二叉树的右视图 637. 二叉树的层平均值 429. N叉树的层序遍历 515. 在每个树行中找最大值 116. 填充每个节点的下一个右侧节点指针 117. 填充每个节点的下一个右侧节点指针II 104. 二叉树的最大深度 111. 二叉树的最小深度","link":"/2022/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"二叉树遍历","text":"深度优先遍历前序遍历迭代 python 12345678910111213141516171819class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: #右 st.append(node.right) if node.left: #左 st.append(node.left) st.append(node) #中 st.append(None) else: node = st.pop() result.append(node.val) return result 递归 python 1234567891011121314class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: # 保存结果 result = [] def traversal(root: TreeNode): if root == None: return result.append(root.val) # 前序 traversal(root.left) # 左 traversal(root.right) # 右 traversal(root) return result 中序遍历迭代 python 123456789101112131415161718192021class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: #添加右节点（空节点不入栈） st.append(node.right) st.append(node) #添加中节点 st.append(None) #中节点访问过，但是还没有处理，加入空节点做为标记。 if node.left: #添加左节点（空节点不入栈） st.append(node.left) else: #只有遇到空节点的时候，才将下一个节点放进结果集 node = st.pop() #重新取出栈中元素 result.append(node.val) #加入到结果集 return result 递归 python 12345678910111213class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] def traversal(root: TreeNode): if root == None: return traversal(root.left) # 左 result.append(root.val) # 中序 traversal(root.right) # 右 traversal(root) return result 后序遍历迭代 python 1234567891011121314151617181920class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) #中 st.append(None) if node.right: #右 st.append(node.right) if node.left: #左 st.append(node.left) else: node = st.pop() result.append(node.val) return result 递归 python 12345678910111213class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] def traversal(root: TreeNode): if root == None: return traversal(root.left) # 左 traversal(root.right) # 右 result.append(root.val) # 后序 traversal(root) return result 广度优先遍历迭代 python 1234567891011121314151617181920212223class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: results = [] if not root: return results from collections import deque que = deque([root]) while que: size = len(que) result = [] for _ in range(size): cur = que.popleft() result.append(cur.val) if cur.left: que.append(cur.left) if cur.right: que.append(cur.right) results.append(result) return results 递归 python 1234567891011class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: res = [] def helper(root, depth): if not root: return [] if len(res) == depth: res.append([]) # start the current depth res[depth].append(root.val) # fulfil the current depth if root.left: helper(root.left, depth + 1) # process child nodes for the next depth if root.right: helper(root.right, depth + 1) helper(root, 0) return res","link":"/2022/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"title":"动态规划","text":"什么是动态规划动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。 例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。 但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。 所以贪心解决不了动态规划的问题。 如何理解动态规划动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。 A ：”1+1+1+1+1+1+1+1 =？” A ：”上面等式的值是多少” B ：计算 “8” A : 在上面等式的左边写上 “1+” 呢？ A : “此时等式的值为多少” B : 很快得出答案 “9” A : “你怎么这么快就知道答案了” A : “只要在8的基础上加1就行了” A : “所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 ‘记住求过的解来节省时间’” 动态规划解决的问题能采用动态规划求解的问题的一般要具有3个性质： 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 动态规划模板 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 例题 509. 斐波那契数 —— 题解 70. 爬楼梯 —— 题解 746. 使用最小花费爬楼梯 —— 题解 62. 不同路径 —— 题解 63. 不同路径 II —— 题解 343. 整数拆分 —— 题解 96. 不同的二叉搜索树 —— 题解 背包问题 —— 理论基础 能否能装满背包：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) 416. 分割等和子集 —— 题解 1049. 最后一块石头的重量 II —— 题解 装满背包有几种方法：dp[j] += dp[j - nums[i]] 70. 爬楼梯 —— 题解 494. 目标和 —— 题解 377. 组合总和 Ⅳ —— 题解 518. 零钱兑换 II —— 题解 背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 474. 一和零 —— 题解 装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]) 322. 零钱兑换 —— 题解 279. 完全平方数 —— 题解 139. 单词拆分 —— 题解 打家劫舍 198. 打家劫舍—— 题解 213. 打家劫舍 II—— 题解 337. 打家劫舍 III—— 题解 买卖股票 121. 买卖股票的最佳时机—— 题解 122. 买卖股票的最佳时机 II—— 题解 123. 买卖股票的最佳时机 III—— 题解 188. 买卖股票的最佳时机 IV—— 题解 309. 最佳买卖股票时机含冷冻期—— 题解 714. 买卖股票的最佳时机含手续费—— 题解 子序列 300. 最长递增子序列—— 题解 674. 最长连续递增序列—— 题解 718. 最长重复子数组—— 题解 1143. 最长公共子序列—— 题解 1035. 不相交的线—— 题解 53. 最大子数组和—— 题解 392. 判断子序列—— 题解","link":"/2022/10/29/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"回溯法","text":"什么是回溯法回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 如何理解回溯法 回溯法是基于深度优先搜索思想, 通过遍历实现; 因此, 回溯法也是一种暴力解法, 我们可以通过剪枝, 在遍历过程中将绝对不符合条件的分支即时剪去, 避免无意义的遍历, 从而降低回溯的成本 回溯法解决的问题都可以抽象为树形结构，集合的大小构成了树的宽度，递归的深度构成了树的深度，是一个高度有限的N叉树 回溯与动态规划的区别共同点用于求解多阶段决策问题; 多阶段决策问题即: 求解一个问题分为很多步骤（阶段） 每一个步骤（阶段）可以有多种选择 不同点 动态规划用于求解问题的最优解 回溯算法可以搜索得到所有的方案(包括最优解), 但是本质上它是一种遍历算法, 时间复杂度很高 回溯法解决的问题回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 组合和排列的区别例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。记住组合无序，排列有序，就可以了。 回溯法模板分析过程 回溯函数模板返回值及参数 回溯算法返回值一般为空 参数不容易确定下来，所以一般先写逻辑，根据逻辑填写参数 回溯函数终止条件 回溯可以抽象成树形结构，遍历树形结构达到终止条件一般是达到叶子节点，找到满足条件的答案，把答案存储并结束本层递归 回溯搜索的遍历过程 遍历伪代码如下: 12345# python for 选择 in 本层集合中元素: 处理节点 backtrack(路径, 选择列表) 回溯，撤销处理结果 for循环就是遍历集合区间，一个节点有多少孩子，for循环就执行多少次 backtrack调用自己，实现递归 for循环是横向遍历，backtrack是纵向遍历，这样就把一棵树遍历完了 模板1234567891011# pythonresult = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 本层集合中元素: 处理节点 backtrack(路径, 选择列表) 回溯，撤销处理结果 例题组合问题 77. 组合 216. 组合总和 III 17. 电话号码的字母组合 39. 组合总和 —— Post not found: LeetCode/LeetCode39-组合总和 题解 40. 组合总和 II 分割问题 131. 分割回文串 93. 复原 IP 地址 —— Post not found: LeetCode/LeetCode93-复原IP地址 题解 子集问题 78. 子集 90. 子集 II 491. 递增子序列 —— Post not found: LeetCode/LeetCode491-递增子序列 题解 排列问题 46. 全排列 47. 全排列 II —— Post not found: LeetCode/LeetCode47-全排列II 题解 棋盘问题 51. N 皇后 37. 解数独 —— Post not found: LeetCode/LeetCode37-解数独 题解","link":"/2022/10/11/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"title":"背包问题","text":"什么是背包问题背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中，背包的空间有限，但我们需要最大化背包内所装物品的价值。背包问题通常出现在资源分配中，决策者必须分别从一组不可分割的项目或任务中进行选择，而这些项目又有时间或预算的限制。 01背包题目描述有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 思路分析题目 暴力解法：每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。 由题目可知 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 模板（二维dp数组） 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 确定递推公式 dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。那么可以有两个方向推出来dp[i][j]不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图： 再看其他情况。 状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。 dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。 当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。 dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？ 其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。 但只不过一开始就统一把dp数组统一初始为0，更方便一些。 确定遍历顺序 在如下图中，可以看出，有两个遍历的维度：物品与背包重量 先遍历物品或先遍历背包重量都可以，但先遍历物品好理解。 123456789// 先遍历物品// weight数组的大小 就是物品个数for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); }} 12345678// 先遍历背包// weight数组的大小 就是物品个数for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); }} 虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导 举例推导dp数组 模板（一维dp数组/滚动数组） 对于背包问题其实状态都是可以压缩的。 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 确定dp数组的定义 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i] 所以递推公式为： 1dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 一维dp数组如何初始化 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ 看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 一维dp数组遍历顺序 代码如下： 123456for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 这里和二维dp的写法中，遍历背包的顺序是不一样的，二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。因为倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次。 一维dp本质上是复用数组为上一层数组（i-1）原理上还是二维dp，根据递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);赋值当前值要参考dp[j - weight[i]]，即上一层的数据，如果从前往后遍历，上层的数据会被覆盖，导致背包多次放入，从后往前遍历则当前元素前的元素仍然和上一层的值相同。 因为一维dp是复用上一层数据，所以不可以先遍历背包容量嵌套遍历物品，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。 举例推导dp数组 代码python（二维dp数组）123456789101112131415161718192021222324252627282930def test_2_wei_bag_problem(bag_size, weight, value) -&gt; int: rows, cols = len(weight), bag_size + 1 dp = [[0 for _ in range(cols)] for _ in range(rows)] # 初始化dp数组. for i in range(rows): dp[i][0] = 0 first_item_weight, first_item_value = weight[0], value[0] for j in range(1, cols): if first_item_weight &lt;= j: dp[0][j] = first_item_value # 更新dp数组: 先遍历物品, 再遍历背包. for i in range(1, len(weight)): cur_weight, cur_val = weight[i], value[i] for j in range(1, cols): if cur_weight &gt; j: # 说明背包装不下当前物品. dp[i][j] = dp[i - 1][j] # 所以不装当前物品. else: # 定义dp数组: dp[i][j] 前i个物品里，放进容量为j的背包，价值总和最大是多少。 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cur_weight]+ cur_val) print(dp)if __name__ == &quot;__main__&quot;: bag_size = 4 weight = [1, 3, 4] value = [15, 20, 30] test_2_wei_bag_problem(bag_size, weight, value) python（一维dp数组/滚动数组）12345678910111213141516def test_1_wei_bag_problem(): weight = [1, 3, 4] value = [15, 20, 30] bag_weight = 4 # 初始化: 全为0 dp = [0] * (bag_weight + 1) # 先遍历物品, 再遍历背包容量 for i in range(len(weight)): for j in range(bag_weight, weight[i] - 1, -1): # 递归公式 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(dp)test_1_wei_bag_problem() 完全背包题目描述有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 每件商品都有无限个！ 问背包能背的物品最大价值是多少？ 思路遍历顺序01背包和完全背包唯一不同就是体现在遍历顺序上，01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即： 1234567// 先遍历物品，再遍历背包for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} dp状态图如下： for循环嵌套01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓。 因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。 如图所示完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。 1234567// 先遍历背包，再遍历物品for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl;} python（一维dp数组/滚动数组）1234567891011121314151617181920212223242526272829303132# 先遍历物品，再遍历背包def test_complete_pack1(): weight = [1, 3, 4] value = [15, 20, 30] bag_weight = 4 dp = [0]*(bag_weight + 1) for i in range(len(weight)): for j in range(weight[i], bag_weight + 1): dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(dp[bag_weight])# 先遍历背包，再遍历物品def test_complete_pack2(): weight = [1, 3, 4] value = [15, 20, 30] bag_weight = 4 dp = [0]*(bag_weight + 1) for j in range(bag_weight + 1): for i in range(len(weight)): if j &gt;= weight[i]: dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(dp[bag_weight])if __name__ == '__main__': test_complete_pack1() test_complete_pack2() 多重背包题目描述有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。 多重背包和01背包是非常像的， 为什么和01背包像呢？ 每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。 背包最大重量为10。 物品为： 重量 价值 数量 物品0 1 15 2 物品1 3 20 3 物品2 4 30 2 问背包能背的物品最大价值是多少？ 和如下情况有区别么？ 重量 价值 数量 物品0 1 15 1 物品0 1 15 1 物品1 3 20 1 物品1 3 20 1 物品1 3 20 1 物品2 4 30 1 物品2 4 30 1 毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。 python12345678910111213141516171819202122232425262728293031323334353637383940414243def test_multi_pack1(): '''版本一：改变物品数量为01背包格式''' weight = [1, 3, 4] value = [15, 20, 30] nums = [2, 3, 2] bag_weight = 10 for i in range(len(nums)): # 将物品展开数量为1 while nums[i] &gt; 1: weight.append(weight[i]) value.append(value[i]) nums[i] -= 1 dp = [0]*(bag_weight + 1) # 遍历物品 for i in range(len(weight)): # 遍历背包 for j in range(bag_weight, weight[i] - 1, -1): dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(&quot; &quot;.join(map(str, dp)))def test_multi_pack2(): '''版本：改变遍历个数''' weight = [1, 3, 4] value = [15, 20, 30] nums = [2, 3, 2] bag_weight = 10 dp = [0]*(bag_weight + 1) for i in range(len(weight)): for j in range(bag_weight, weight[i] - 1, -1): # 以上是01背包，加上遍历个数 for k in range(1, nums[i] + 1): if j - k*weight[i] &gt;= 0: dp[j] = max(dp[j], dp[j - k*weight[i]] + k*value[i]) print(&quot; &quot;.join(map(str, dp)))if __name__ == '__main__': test_multi_pack1() test_multi_pack2()","link":"/2022/10/31/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"贪心算法","text":"什么是贪心算法贪心算法（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。 如何理解贪心算法贪心算法的设计思想贪心算法在解决问题的策略上目光短浅，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。贪心算法对于大部分的优化问题都能产生最优解，但不能总获得整体最优解，通常可以获得近似最优解。该算法存在问题： 不能保证求得的最后解是最佳的 不能用来求最大或最小解问题 只能求满足某些约束条件的可行解的范围。Dijkstra算法、Prim算法和Kruskal算法都属于典型的贪心算法 贪心算法的基本要素对于一个具体的问题，怎么知道是否可用贪心算法解此问题，以及能否得到问题的最优解呢?这个问题很难给予肯定的回答。但是，从许多可以用贪心算法求解的问题中看到这类问题一般具有2个重要的性质：贪心选择性质和最优子结构性质。子问题：假设为了解决某一优化问题，需要依次作出n个决策D1，D2，…，Dn，对于任何一个整数k，1 &lt; k &lt; n，以Dk作为问题的初始状态，来进行以后的决策，这样的问题就成为是原问题的一个子问题。 贪心选择性质：所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。 贪心算法与动态规划算法的差异大多数时候，能用贪心算法求解的问题，都可以用动态规划算法求解。但是能用动态规划求解的，不一定能用贪心算法进行求解。因为贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划。 共同点 两者都具有最优子结构性质 不同点 动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题时才能做出选择。而贪心算法，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。 贪心算法中作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留，贪心算法每一步的最优解一定包含上一步的最优解。动态规划算法中全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解。 贪心法的适用范围贪心算法并不能总求得问题的整体最优解。但对于某些问题，却总能求得整体最优解，这要看问题时什么了。只要能满足贪心算法的两个性质：贪心选择性质和最优子结构性质，贪心算法就可以出色地求出问题的整体最优解。即使某些问题，贪心算法不能求得整体的最优解，贪心算法也能求出大概的整体最优解。如果你的要求不是太高，贪心算法是一个很好的选择。最优子结构性质是比较容易看出来的，但是贪心选择性质就没那么容易了，这个时候需要证明。证明往往使用数学归纳法。 贪心算法解决的问题 哈夫曼编码 磁盘文件的存储 生产调度问题 信息查询 活动安排问题 0-1背包问题和背包问题（knapsack problem） 算法思路 建立数学模型来描述问题 把求解的问题分成若干个子问题 对每一子问题求解，得到子问题的局部最优解 把子问题的解局部最优解合成原来解问题的一个解 例题 455. 分发饼干 53. 最大子数组和 1005. K 次取反后最大化的数组和 134. 加油站 860. 柠檬水找零 968. 监控二叉树 —— Post not found: LeetCode/LeetCode968-监控二叉树 题解 两个维度权衡问题 135. 分发糖果 —— Post not found: LeetCode/LeetCode135-分发糖果 题解 406. 根据身高重建队列 序列问题 376. 摆动序列 —— Post not found: LeetCode/LeetCode376-摆动序列 题解 738. 单调递增的数字 区间问题 55. 跳跃游戏 45. 跳跃游戏 II 45. 用最少数量的箭引爆气球 435. 无重叠区间 763. 划分字母区间 56. 合并区间 股票问题 122. 买卖股票的最佳时机 II 714. 买卖股票的最佳时机含手续费","link":"/2022/10/16/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"title":"原码,反码,补码","text":"机器数和真值在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念. 机器数一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。 那么，这里的 00000011 和 10000011 就是机器数。 真值 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。 例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1 原码, 反码, 补码的基础概念和计算方法在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式. 原码原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制: [+1]原 = 0000 0001 [-1]原 = 1000 0001 第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] 即 [-127 , 127] 原码是人脑最容易理解和计算的表示方式. 反码反码的表示方法是: 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. [+1] = [00000001]原 = [00000001]反 [-1] = [10000001]原 = [11111110]反 可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算. 补码补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 为何要使用原码, 反码和补码在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法. 现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同: [+1] = [00000001]原 = [00000001]反 = [00000001]补 所以不需要过多解释. 但是对于负数: [-1] = [10000001]原 = [11111110]反 = [11111111]补 可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题: 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值. 1的取反为什么是-2 先求取1的取反，也就是将1的二进制数1变成0，0变成1. 1的源码为 00000000 0000000 0000000 00000001 1的取反为 11111111 11111111 11111111 11111110 接下来就是对1取反的数进行分析 11111111 11111111 11111111 11111110这个数我们不知道是那个数，但我们知道它是一个负数，因为最左侧为1是符号位，表示负数。而在计算机中，无论正数还是负数都是以补码的形式进行加减运算的，也就是说11111111 11111111 11111111 11111110在这里是一个补码，我们需要将它转换为源码，才知道这个整数。 减一后得到反码为 11111111 11111111 11111111 11111101取反后得到源码为 10000000 00000000 00000000 00000010 也就是源码为-2最终答案1的取反为-2","link":"/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/"},{"title":"HTTP基本概念","text":"HTTP 是什么？HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。 能否详细解释「超文本传输协议」？ HTTP的名字「超文本协议传输」，它可以拆成三个部分： 超文本 传输 协议 协议 在生活中，我们也能随处可见「协议」，例如： 刚毕业时会签一个「三方协议」； 找房子时会签一个「租房协议」； 生活中的协议，本质上与计算机中的协议是相同的，协议的特点: 「协」字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。 「议」字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。 针对 HTTP 协议，我们可以这么理解。 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。 传输 所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。 别轻视了这个简单的动作，它至少包含两项重要的信息。 HTTP 协议是一个双向协议。 我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。 数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。 就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; — &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。 而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。 针对传输，我们可以进一步理解了 HTTP。 HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 超文本 HTTP 传输的内容是「超文本」。 我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。 再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。 HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。 OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案： HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 那HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议 ，这种说法正确吗？ 这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确。 HTTP常见的状态码有哪些？ 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。 HTTP常见字段有哪些？Host 字段客户端发送请求时，用来指定服务器的域名。 1Host: www.A.com 有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。 Content-Length 字段 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。 1Content-Length: 1000 如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。 大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。具体什么是 TCP 粘包，可以看这篇文章：如何理解是 TCP 面向字节流协议？(opens new window) Connection 字段Connection 字段最常用于客户端要求服务器使用「 HTTP 长连接」机制，以便其他请求复用。 HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。 1Connection: Keep-Alive 开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。 PS：大家不要把 HTTP Keep-Alive 和 TCP Keepalive 搞混了，这两个虽然长的像，但是不是一个东西，具体可以看我这篇文章：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？(opens new window) Content-Type 字段Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。 1Content-Type: text/html; charset=utf-8 上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。 1Accept: */* 上面代码中，客户端声明自己可以接受任何格式的数据。 Content-Encoding 字段Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式 1Content-Encoding: gzip 上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。 1Accept-Encoding: gzip, deflate","link":"/2022/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"TCP-IP网络模型有哪几层？","text":"为什么要有 TCP/IP 网络模型？ 对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套通用的网络协议。 这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 TCP/IP 网络模型」分别对每一层进行介绍。 应用层最上层的，也是我们能直接接触到的就是应用层（Application Layer），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。 所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。 应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。 而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。 传输层应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。 在传输层会有两个传输协议，分别是 TCP 和 UDP。 TCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。 UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。 应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）。 TCP 在建立连接的时候，会协商双方的MSS值，通常这个 MSS 会控制在 MTU 以内：最大 IP 包大小减去 IP 和 TCP 协议头的大小。（其最终目的：就是尽量避免 IP 分片） 这样 TCP 就可以在自己这一层，把用户发送的数据，预先分成多个大小限制在 MTU 里的 TCP 包。每个 TCP 的分片包，都完整了包含了 TCP 头信息，方便在接收方重组。 当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。 比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。 由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。 网络层传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。 实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。 也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层（Internet Layer）。 网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。 对于UDP来说，它并没有协商的能力，所以它只能直接把用户发送的数据，传给网络层（IP层），由网络层来进行分片。 对 网络层（IP层）来说：它并不知道上层传过来的数据，到底是 TCP 还是 UDP，它并不关心这个东西，也没有能力去区分。 如果发现数据过大，那么 IP 层会自动对数据进行切割，分片。 网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。 我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。 因此，需要将 IP 地址分成两种意义： 一个是网络号，负责标识该 IP 地址是属于哪个「子网」的； 一个是主机号，负责标识同一「子网」下的不同主机； 怎么分的呢？这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。 举个例子，比如 10.100.122.0/24，后面的/24表示就是 255.255.255.0 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。 知道了子网掩码，该怎么计算出网络地址和主机地址呢？ 将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号，如下图： 将 255.255.255.0 取反后与IP地址进行进行按位与运算，就可以得到主机号。 大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。 那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。 除了寻址能力， IP 协议还有另一个重要的能力就是路由。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。 路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。 所以，IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。 网络接口层生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。 IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。 什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。 以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。 MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。 所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。 总结综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。 再给大家贴一下每一层的封装格式： 网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。","link":"/2022/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/"},{"title":"我要做，我不要，我想要","text":"“我要做”“我不要”和“我想要”选择一个意志挑战 “我要做”意志力挑战：有没有什么事是你想多做一些的，或是停止拖延的，因为你知道这样做能提高你的生活质量？ “我不要”意志力挑战：你生活中最“顽固”的习惯是什么？有什么是你想放弃，或者想少做一点的，因为它妨害了你的健康、幸福甚至成功？ “我不要”意志力挑战：你生活中最“顽固”的习惯是什么？有什么是你想放弃，或者想少做一点的，因为它妨害了你的健康、幸福甚至成功？ 明确自己的目标“我要做”和“我不要”是自控的两种表现，但它们不是意志力的全部。要想在需要“说不”时“说不”，在需要“说好”时“说好”，你还得有第三种力量：那就是牢记自己真正想要的是什么。你没准会说，我真正想要的是巧克力蛋糕，是再喝一杯酒，是好好休个假。但当你面对诱惑和拖延症时，你得想清楚，你真正想要的，其实是变得苗条、升职加薪、不要欠债、家庭美满、远离监狱。只有想到这些，才能遏制你的一时冲动。想要做到自控，你就得在关键时刻明确自己的目标。这就是“我想要”的力量。意志力就是驾驭“我要做”、“我不要”和“我想要”这三种力量。 “我要做”“我不要”和“我想要”的神经学原理斯坦福大学的神经生物学家罗伯特·萨博斯基（Robert Sapolsky）认为，现代人大脑里前额皮质的主要作用是让人选择做“更难的事”。如果坐在沙发上比较容易，它就会让你站起来做做运动。如果吃甜品比较容易，它就会提醒你要杯茶。如果把事情拖到明天比较容易，它就会督促你打开文件，开始工作。 前额皮质并不是挤成一团的灰质，而是分成了三个区域，分管“我要做”“我不要”和“我想要”三种力量。前额皮质的左边区域负责“我要做”的力量。它能帮你处理枯燥、困难或充满压力的工作。比如，当你想冲个澡的时候，它会让你继续待在跑步机上。右边的区域则控制“我不要”的力量。它能克制你的一时冲动。比如，你开车时没有看短信，而是盯着前方的路面，就是这个区域的功劳。以上两个区域一同控制你“做什么”。 第三个区域位于前额皮质中间靠下的位置。它会记录你的目标和欲望，决定你“想要什么”。这个区域，的细胞活动越剧烈，你采取行动和拒绝诱惑的能力就越强。即便大脑的其他部分一片混乱，向你大叫“吃这个！喝那个！抽这个！买那个！”这个区域也会记住你真正想要的是什么。 两个自我两个自我导致的问题有些神经学家甚至认为，我们只有一个大脑，但我们有两个想法。或者说，我们的脑袋里有两个自我。一个自我任意妄为、及时行乐，另一个自我则克服冲动、深谋远虑。我们总是在两者之间摇摆不定，有时觉得自己想减肥，有时觉得自己想吃饼干。因此，我们可以这样来定义意志力的挑战——你一方面想要这个，一方面想要那个。当下的你想要这个，但如果不要的话，你未来的生活会更好。两个自我发生分歧的时候，总会有一方击败另一方。决定放弃的一方并没有做错，只是双方觉得重要的东西不同而已。 两个自我的价值虽然原始冲动并不总对我们有利，但想彻底摆脱它也是不对的。医学上曾研究过因脑部受损而失去本能的人。研究者发现，对于健康、幸福和自控力来说，原始的恐惧和欲望至关重要。如果没有了欲望，人们就会变得沮丧；如果没有了恐惧，人们就没法保护自己、远离伤害。在意志力挑战中获胜的关键，在于学会利用原始本能，而不是反抗这些本能。神经经济学家是一群研究人们决策时大脑活动的科学家。他们发现，自控系统和生存本能并不总会发生冲突。在某些时候，它们会相互协作，帮我们作出更好的选择。 意志力意志力第一法则：认识你自己自控力是人类最与众不同的特征之一。此外，人类还拥有自我意识。当我们做一件事的时候，我们能意识到自己在做什么，也知道我们为什么这样做。但愿我们还能知道，在做这件事情之前我们需要做些什么，这样我们就会三思而后行。 如果没有自我意识，自控系统将毫无用武之地。在作决定的时候，你必须意识到自己此刻需要意志力。否则，大脑总会默认选择最简单的。想戒烟的人需要第一时间意识到自己吸烟的冲动，也要知道哪里会让他有这种冲动（比如在室外、寒冷的环境里或摆弄打火机的时候）。他还得知道，如果自己这次投降了，明天很有可能会继续吸烟，未来很可能会疾病缠身。为了避免厄运降临，他必须有意识地戒烟。要是没有自我意识，他就完蛋了。 现代社会充斥着诱惑和刺激，不断冲击着人们的自控力。巴巴·史乌（Baba Shiv）向我们证明了，注意力分散的人更容易向诱惑屈服。如果你心里在想其他事，那么冲动就会主导你的选择。如果你想有更强的自控力，就得有更多的自我意识。 训练大脑，增强意志力神经学家发现，如果你经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你集中注意力、管理压力、克制冲动和认识自我的能力。一段时间之后，你的大脑就会变成调试良好的意志力机器。在你的前额皮质和影响自我意识的区域里，大脑灰质都会增多。 研究发现，经过仅仅3个小时的冥想练习，他们的注意力和自控力就有大幅提高。11个小时后，研究人员已经能观察到大脑的变化。刚学会冥想的人大脑里负责控制注意力、排除干扰、控制冲动的区域之间增加了许多类神经元。另一项研究发现，持续8周的日常冥想训练可以提升人们日常生活中的自我意识，相应大脑区域里的灰质也会随之增多。 意志力实验：5分钟训练大脑冥想 原地不动，安静坐好。 注意你的呼吸。 感受呼吸，弄清自己是怎么走神的。 刚开始的时候，你每天锻炼5分钟就行。习惯成自然之后，请试着每天做10-15分钟。如果你觉得有负担，那就减少到5分钟。每天做比较短的训练，也比把比较长的训练拖到明天好。这样，你每天都会有一段固定的时间冥想，比如早晨洗澡之前。如果你做不到，可以对时间进行适当的调整。 冥想不是让你什么都不想，而是让你不要太分心，不要忘了最初的目标。如果你在冥想时没法集中注意力，别担心。你只需多做练习，将注意力重新集中到呼吸上。","link":"/2022/11/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E6%88%91%E8%A6%81%E5%81%9A%EF%BC%8C%E6%88%91%E4%B8%8D%E8%A6%81%EF%BC%8C%E6%88%91%E6%83%B3%E8%A6%81/"},{"title":"GDP","text":"什么是GDPGDP就是国内生产总值，它是指一个国家或地区的所有常住单位在一定时期内（通常为一年）所生产和提供的最终产品和劳务的价值总和。 如何计算GDP第一种方法：生产法GDP = 各部分增加值之和 增加值 = 总产出 – 中间投入 第二种方法：收入法GDP = 固定资产折旧 + 劳动者报酬 + 生产税净额 + 营业盈余 从收入的角度看，GDP由四块构成：第一块是固定资产折旧。例如，当一个人投资企业时，投资购买了100万元固定资产，年折旧率是10%，每年就有10万元的折旧费，国家资产也是这样，所以GDP的第一块是固定资产折旧；第二块是劳动者报酬，这是给工人、农民等所有劳动者的工资；第三块是政府的净税收，也就是国民交的税，由政府支配的部分；第四块是企业盈余，也就是企业家盈利的部分。政府把蛋糕分成四块，构成不同人群的收入，这种计算GDP的方法就叫收入法。 第三种方法：支出法GDP = 总消费 + 总投资 + 净出口（出口 – 进口） 根据支出法公式可知，拉动一国经济增长有三驾马车：总消费、总投资、净出口。要做大一国的经济总量，增强一国的经济实力，政府就要在这三驾马车上下功夫。如果三驾马车都跑起来，该国的经济发展速度就会加快，只要有一驾马车倒下，经济发展就会放慢速度。 现实中应用最多的是支出法，GDP的一部分被人们拿去消费了，另一部分被用于投资。但在经济总量的计算中，还要考虑流往国外和从国外流入的部分。也就是说，外国人购买了我国的产品，算中国出口，需要记入中国的GDP。为什么出口也算中国的GDP？原因是当我们把产品出口到国外，外国人购买了我国的产品，外汇就流入我国的企业，我国的蛋糕就做大了。但我国进口别国商品时，同样也做大了他国的蛋糕。所以在计算GDP时，要计算净出口，即出口减进口。GDP分成三块：总消费、总投资、净出口，这三块构成了GDP的总量。 GDP的应用价值GDP说起来宏大而抽象，它却有非常现实的应用价值。通过GDP指标，我们可以计算很多数据，比如消费率、投资率、增长率等。我国政府宏观调控政策的出台就是看这个指标，如果增长率向下，说明经济下行了，需要宏观政策的调整，如果出口减少，就需要政策的刺激。","link":"/2022/10/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/GDP/"},{"title":"中国的分税制","text":"我国财税体制改革过程 1949年以后，我国财政采取的是“统收统支”，也就是说国有企业赚了多少钱全部上交国库，所有的支出再由政府拨下来，中央政府是统一收入、统一支出。 20世纪80年代以后，我国财税制度进行了三步改革：第一步改革是“利改税”，就是把所有国有企业上交的利润改成税收，不管是民营企业还是国有企业，一律要缴税，外资企业也不例外；第二步改革是“拨改贷”，就是以前给国有企业的拨款都改成了银行贷款；第三步改革是“统改包”，就是把过去的“统收统支”改成了中央政府和地方政府财政之间的“包干制”。地方收上税来后，定好一个基数给中央政府，余下的由地方政府自己支配。 1994年我国进行了一次大型财税体制改革，但没改革怎样把钱支出去。比如，我国建立了企业所得税、个人所得税制度，统一了内外资企业的税率等，而且实行了分税制，把税收的权限分开了。应该说，这场改革之后，我国中央财政和地方财政收入都在增长，政府宏观调控的能力增强了。 我国的分税制 分税制是我国现行的税制。所谓分税制是指中央政府和地方政府分开征税，一个是中央税，一个是地方税，还有一个是共享税。税收的人事权也分开了，有一个国税局和一个地税局，国税局替中央政府收税，地税局替地方政府收税。形成两套税收班子，2018年合并成新税务局统一挂牌。 当时的设想是，中央政府收那些好收的税，地方政府收那些难收的税。中央政府收的税由国税局完成，成立一个地税局来收地方税。比较大的税种由国家来收，比较小的税种由地方政府去收。什么是大税种呢？比如关税就是大税种，还有金融企业所得税，这些都属于中央税。 1994年的这次改革明确了中央和地方的支出原则。中央政府承担全国性的支出，地方政府承担本地区的发展支出。 我国的税制采用的是累进制，就是随着收入的提高，税率在不断提高，多赚钱就多缴税。其中也有一部分是按比例缴税。 分税制带来了哪些问题 地方财政苦乐不均，有的地方富，有的地方穷。中央财政现在每年都会拨给贫困地区很多钱，支援它们的发展。尽管如此，这些地区还是很困难，它们没有钱去发展，我国的中西部地区与东部沿海地区在财政收入水平上有一定差距。这些地区财政收入少，到了要支出时捉襟见肘。 我国1994年的财税体制改革，只在怎么把钱收上来的问题上做了改革，没有在怎么把钱支出上做改革。因为财政支出改革，涉及的各方利益太大了，它是在地方政府和中央政府之间做利益划分。 教育资源不平衡。当前，我国中小学教育是由地方财政来支出的。当地方财政钱不够时，中央财政再补助。这样一来，富裕地区政府有钱，那里的办学条件就会好一些，贫困地区政府钱不够，就会有失学儿童。有失学儿童的时候，中央政府就得管，否则就会出现教育不公平等现象。有些地方办希望小学，就是地方财政经费不足导致的。 个人所得税归属。当前，我国个人所得税属于地税。但随着经济发展和人们收入水平的不断提高，个人所得税会成为一个大税种。这一观点早已被西方发达国家的实践证明，西方国家的个人所得税占税收的比重很大。现在中国的个人所得税也正在变成一个大税种。 土地出让金的问题。在1994年财税体制改革时，中央政府以为土地出让金是一笔小数目，就把它划归地方政府。没想到土地出让金变得越来越大，由于商品房的出现，卖地成了地方政府的大收入，这造成了我国现在是土地财政，越穷的地方盖的楼越多。试问，如果地方政府没地可卖时，那财政支出怎么办？因此我国一定会推出房地产税。 我国未来会推出什么税 房地产税，目前国家正在研究中。未来一定会征收，这是为了解决地方政府财政收入的来源问题。 遗产税，西方各国政府都有征收，中国眼下还没有开始征收，但未来也一定会征收遗产税。为的是不让贫富在下一代转移，让每个人不因为出生在富裕家庭就不去奋斗。遗产税可以打破阶层的固化，让每个人都有机会成功。但遗产税推出需要时间，就像房地产税推出也需要时间一样。","link":"/2022/10/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%88%86%E7%A8%8E%E5%88%B6/"},{"title":"市场失灵","text":"市场会失灵吗？现在人们普遍接受亚当·斯密的经济理论，靠的是市场那只“看不见的手”。亚当·斯密说，政府别干预经济，价格机制本身就能调节经济。看价格就知道，赚钱的事我们会做，赔钱的事我们不做；对我们有利的事会做，对我们没利的事不做。可是，当河流被污染，山林被砍伐，当孩子们需要学校，出行者需要道路，当贫困山区的人们生活困难，当失业下岗的人揭不开锅时，市场是无法应对的，这就是市场失灵。特别是经济大萧条的来临，显示了市场之手的无助。人们发现，原来有些事情是市场不能做的，市场在某些方面存在失灵。 经济中的外部性市场失灵的第一个方面：经济中的外部性。什么叫外部性？就是一个人做了一件事，他对这件事的后果不负任何责任，他做了坏事不受惩罚，做了好事也得不到补偿，这就是经济中的外在性。当存在外在性时，市场解决不了它，价格也影响不了它。 经济中负的外部性比比皆是，一些人的行为损害了其他人的利益，但他们并不为此付费。当人们做出巨大贡献时，市场并没有对他们进行补偿，这是经济中正的外部性，也是市场机制不能解决的。所以，无论是正的外部性还是负的外部性，都是市场机制不能解决的。 公共物品的缺失经济生活中，还有一种情形也是市场机制不能解决的，那就是公共物品的缺失。从需求看，人们对公共物品的需求越来越多，如果有人提供了公共物品，使用时没人交费，大家都想免费使用，那么生产者和消费者之间的链条就断掉了，市场就失灵了。 收入分配不公平收入分配不公也是市场机制解决不了的。市场只能解决效率问题，让经济快速发展，但不能解决公平问题。这是市场失灵的又一种表现。收入分配不公平只能由政府解决，政府向高收入人群多征税，给低收入的人发放生活救济金，给予补助，让穷人也能过上温饱的日子。这就是我国政府目前正在做的脱贫计划。 政府扮演的经济角色 稳定经济 提供公共服务 提供公平竞争的条件 解决收入再分配的问题","link":"/2022/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5/"},{"title":"看得见的手","text":"看不见的手英国经济学家亚当·斯密，在1776年写了一本书《国富论》，书中提出了一只“看不见的手”指的是价格机制。他建议政府不要干预经济，让价格机制发挥作用，经济自然会达到平衡。亚当·斯密的这个思想统治了资本主义世界长达150年之久。在这么长的时间里，人们用斯密的理论管理国家——政府不干预经济，让经济自由发展，而政府只做一个守夜人。 看得见的手1929年，一场席卷世界的经济危机爆发了。危机首先从美国开始，股市崩盘、企业破产、银行倒闭、工人失业、经济陷入大萧条，很快就波及整个世界，各国都陷入经济大萧条中。当世人都束手无策时，英国又有一个伟大的经济学家出现了，他叫约翰·梅纳德·凯恩斯。他在1936年出版了一本书，书名叫《就业、利息和货币通论》，我们简称为《通论》。这本书可以称为经济学历史上一个重要里程碑。凯恩斯说，在经济萧条、股市低迷、失业严重的时候，你们都没有招了。但我有招，我的这个招就叫“看得见的手”。我们说，国家干预经济生活的历史是从凯恩斯开始的，宏观经济学可以说是凯恩斯开创的。经济学理论也从微观开始走向宏观，从个量分析走向总量分析。从凯恩斯开始，经济学产生了两个分支，即微观经济学和宏观经济学。 凯恩斯讲过一个著名的“挖坑理论”：雇200人挖坑，再雇200人把坑填上，这叫创造就业机会。雇200人挖坑时，需要发200把铁锹和200份干粮，这样钢材、木材和粮食需求就被拉动了。再雇200人把坑填上时，还需要发200把铁锹和200份干粮，钢材、木材和粮食的需求又被拉动了。凯恩斯举这个例子是想说明，当一国经济萧条时，政府不是没办法，政府应该出来做点事儿。用这只“看得见的手”，通过赤字和发行国债的方式把经济从大萧条中拉出来。因此，我们说“看得见的手”就是国家对经济的宏观调控。政府没钱但可以发行国债，用来刺激经济回升。","link":"/2022/10/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E6%89%8B/"},{"title":"经济中的平衡","text":"凯恩斯的简单模型 经济学家凯恩斯说，宏观经济太复杂了，涉及的内容太多了，让我来设计一个模型吧。把一国复杂的宏观经济部门抽象出来，用一个模型来表示，大家一看就明白。这就是凯恩斯的简单模型。为什么叫简单模型呢？就是不考虑利率的变化，假定利率不变。 凯恩斯说，一国的宏观经济中有两个部门，一是家庭，二是企业。家庭出卖劳动，到企业去工作，赚钱购买生活所需用品（即消费）；企业生产出产品，把产品卖出去，收回钱来继续生产。一国的宏观经济要想平衡发展，它的条件是：家庭挣的钱全花了，企业生产的产品全卖了，这样宏观经济就能够正常进行。 凯恩斯又说，现实经济中每一个家庭都是一部分钱花出去，另一部分钱存起来。对企业来讲，它也不可能都在进行简单再生产，它想扩大再生产就需要投资。家庭不花的钱存进银行，就有了储蓄；企业扩大投资找银行借钱，就有了投资。只要企业的投资等于家庭的储蓄，宏观经济就能正常运转。所以说，宏观经济平衡的最重要条件是：储蓄等于投资。这也是最核心的经济学原理之一。 如果储蓄大于投资，经济就可能出现问题。我国政府这些年来一直希望人们把储蓄拿出来消费，只有花钱，经济才有希望增长。当储蓄大于投资时，就会出现通货紧缩，因为东西卖不出去，企业只能降价卖、便宜卖、保本卖，最后赔本也得卖。 如果投资大于储蓄时，大家都想赚钱，这时需求就多了，但东西少，物以稀为贵，商品就能卖高价，这就会出现通货膨胀。我们说，前者表现为通货紧缩，钱越来越值钱；后者表现为通货膨胀，东西越来越值钱。因此，在凯恩斯的宏观经济模型中，两部门的经济要想正常运行，经济平衡的条件是储蓄一定等于投资。 因此，我们分析两部门经济平衡的条件，是家庭的收入等于企业的产品。如果你不花钱，把钱存入银行，企业到银行借钱，那储蓄要等于投资 凯恩斯还说，任何一个国家都不能没有政府，否则这个社会就会混乱。所以在他的模型中，要加入政府部门。政府怎么生存？它需要有收入，政府收入就是税收。税收用于支付政府工作人员工资、军队开支以及各项公共教育等费用。 把政府加入模型中，宏观经济的平衡条件是：财政收入等于财政支出。当我们每个人拿到收入时要交个人所得税，企业有了收入，要交企业所得税，还要交企业增值税等。当大家把这些税缴纳给政府，政府有了收入，就要把钱花出去。这样宏观经济才能正常运转。如果政府财政收入不等于财政支出，就会出现财政赤字或财政赢余。 凯恩斯最后说，在这个宏观模型中，还要加一个国外部门。因为没有一个国家经济可以完全封闭起来，既不出口也不进口。所以，在这个模型中又加了一个国外部门，这就有了出口和进口。 当国外部门被加入时，宏观经济平衡的条件是：出口等于进口。如果一国出口多，进口少，赚的钱多了，外汇就会流进来，表现为贸易顺差，就像现在的中国一样；如果一国进口大于出口，则表现为贸易逆差，就像现在的美国一样。无论是贸易顺差还是贸易逆差，这都是宏观经济不平衡的表现。 宏观经济平衡宏观经济如何平衡一国宏观经济如何平衡呢?根据凯恩斯的简单模型我们可以得到得到一个简单的总供求平衡公式： 消费+储蓄+政府税收+进口=消费+投资+政府支出+出口 经济学里用字母来表示，就是： C + S + T + M = C + I + G + X 可在现实生活中，储蓄等于投资吗？不等于！政府的税收等于支出吗？不等于！出口等于进口吗？不等于！都不等于，那宏观经济还能转动吗？凯恩斯认为，它们不必个别相等，只要总量加起来相等就可以。当你把钱给了政府，政府一定要把这笔钱花出去，当你把钱存入银行，银行一定要把它贷出去，否则经济就不能发展。 宏观经济达不到平衡，那该怎么办？当一国宏观经济不平衡，需求太多，供给不足时，人们不愿意把钱存进银行，担心钱会越来越不值钱。所以不是拿去投资就是增加消费，结果物价指数就会攀升；反之，当供给太多，需求太少时，人们都愿意把钱放在手里或者存进银行里，就是不肯花出去。不管政府怎样刺激需求，使出什么高招，百姓就是不花钱，这时宏观经济怎么平衡？只能用价格来找平。 对企业来说，他们想卖出产品就得降价卖。如果原材料厂家让生产厂家买它的原材料，就必须价格便宜，甚至就赊账卖。这种供过于求的结果，就是价格指数下降。所以我们说，当总供求不平衡时，只能用价格来平衡。 当价格指数上升时，经济开始回暖，总需求超过总供给，通货膨胀发生；当价格指数下降时，经济开始变冷，总供给超过总需求，通货紧缩出现。 政府的宏观经济调控方式政府对宏观经济的调控就是在总需求和总供给上做文章。政府不是在刺激总需求就是在增加总供给。不过，需要强调的是，政府动总需求相对容易，动总供给却相对困难。 动总需求，政府只要出台政策就能马上刺激消费，刺激投资，增加出口；但是动总供给却不那么容易。比如，想增加钢材产量，先要找到原材料，再买设备，然后培训工人，再进行生产，最快也得一年半载才能投产。所以，政府动总供给很难，动总需求相对容易。 因此，一国政府在短期内调整的是总需求，在长期内才能调整的是总供给。这一点很重要。如果总供给和总需求都调整不好，那就通过价格找平。 一国经济的总供给和总需求是否平衡，通过物价指数就可以反映出来。当你看到价格指数平稳运行，既没有通货膨胀也没有通货紧缩时，那你就知道，宏观经济趋于平衡了。如果物价指数向上，说明经济开始回暖了；如果企业利润增加，说明经济开始起来了；如果股市回升，说明经济开始热了。所以，我们说一国经济的平衡就是总供给和总需求的平衡。","link":"/2022/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E7%BB%8F%E6%B5%8E%E4%B8%AD%E7%9A%84%E5%B9%B3%E8%A1%A1/"},{"title":"财政政策","text":"财政政策的种类财政政策的种类，可以分为三种类型。 赤字性财政政策：赤字性财政政策指的是通过加大财政赤字来刺激经济。运用的条件是经济萧条时期，总供给大于总需求。储蓄大于投资，生产出来的产品卖不出去，价格下降。采取的措施是减税和扩大政府支出，以增加有效需求。所以说，赤字性的财政政策也叫积极的财政政策。 扩大政府支出：当经济遇冷时，企业不愿意投入。因为投资到哪儿都没钱可赚，大家都不愿意消费。这时政府就会拿出钱来完善基础设施建设。比如，修路、架桥、铺设高铁及高速公路等等，政府用扩大支出的方式拉动经济增长。 政府减税对国民是好事，加大政府支出对国民也是好事，但减税和加大支出带来的结果往往是带来更大的赤字和更多的国债。 紧缩性财政政策：紧缩性财政政策运用的条件是在通货膨胀时期，总需求大于总供给，投资大于储蓄，物价上涨、需求膨胀。采取的措施是加税和减少政府支出，以抑制总需求。 平衡性财政政策：平衡性财政政策对社会总供求的影响保持中性。当社会总供求矛盾不突出时使用效果才会明显。 乘数效应当我们说到财政政策时，常常会涉及乘数效应。什么叫乘数效应？乘数效应说的是政府进行投资，并不是投了1000亿元就只是1000亿元的经济规模，它还会带动相关的投资和配套资金，会产生乘数效应。 我国财政主要解决的问题我国政府的财政主要解决的是民生问题、失业问题、养老问题、教育问题等，重要的是通过税收杠杆来解决收入的再分配，让穷人有饭吃。","link":"/2022/10/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/"},{"title":"财政的收入与支出","text":"我国财政收入的主要来源 税收收入。税收是最大的一块财政收入。任何一个国家，无论是发达国家还是发展中国家，政府财政收入主要都是从税收中来的。我国财政收入的绝大部分也是从税收中来的。税收的特点是强制性和无偿性。政府收税之后，无须再返还。 债务收入。当政府的钱不够花时，它可以借债。债务收入是自愿的，但需要政府还本付息。债务收入和税收收入是完全不同的。因为借债可能存在还不上的风险。 企业收入，也叫国有资产收益。它是指国家凭借国有资产所有权获得的利润、租金、股息，红利、资金使用费等收入的总称。因为国有企业是国家出钱办的企业。 其他收入。例如，使用国有森林、地下资源等国家资源必须向政府缴纳一定费用。此外，政府还会有一些转让使用的收入。 财政收入中最核心的部分是税收。包含企业上缴的增值税、营业税、所得税等，以及我们每个人上缴的个人所得税，还有关税、金融企业所得税等一系列税收。目前，我国税收管理体制分为国家税和地方税两部分，国税归中央政府所有，地税归地方政府所有。 财政支出有哪些方面 经常性支出 比如，我国公立大学教师的收入就是从政府税收中来的。国民缴税给政府，政府把这笔钱从财政部拨出一部分给了教育部，教育部拨给了全国的高校，高校再给教师们发工资。我国有两百多万军人，有国家的公检法机构，有教育部门，有科技部门，还有庞大的公务员队伍，这些都需要国家财政养活，政府要给他们发工资，这些支出就叫财政的经常性支出。这里提出了一个概念，经常性支出。什么是经常性支出呢？就是每个月都要支出的钱。例如，这月发给公务员的工资，下月还得发，需要一直发下去。 财政的经常性支出包括三个方面：第一，维持国家机器运行的需要；第二，支持科学、教育、文化、卫生等公共事业的发展；第三，建立和维持社会保障体系的运行。 建设性支出 比如，我国搞了很多大型项目投资，修建京九铁路、三峡工程等，仅三峡工程的预算就有2 000多亿元人民币，当然这些项目有时是靠发行国债进行的。但是，这毕竟属于财政资金的投入，属于建设性支出。 建设性支出又包括两方面：一是投资关系全局的基础设施建设；二是投资大中型企业的建设。 财政的经常性支出和建设性支出一定要分清楚。经常性支出就是每个月都必须支付的钱，如果财政没有钱，那么政府机构就无法正常运转。财政余下的钱用来搞建设，如果钱不够，政府可以通过发行国债的方式搞建设。","link":"/2022/10/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E8%B4%A2%E6%94%BF%E7%9A%84%E6%94%B6%E5%85%A5%E4%B8%8E%E6%94%AF%E5%87%BA/"},{"title":"财政赤字与国债","text":"财政赤字什么是财政赤字财政赤字就是财政的支出大于收入，赤字通常用红色来记录，因此叫财政赤字。相反，如果财政收入多而支出少，也会出现一个差额，那叫财政盈余。但是，在当今世界各国中，财政盈余的很少，绝大多数国家政府出现的都是财政赤字。 财政赤字警戒线标准国际上衡量财政赤字有两条警戒线标准： 警戒线标准是财政赤字占GDP比重不能超过3%。如果超过了3%，就会出现财政风险。 警戒线标准是政府的财政赤字，不能超出财政总支出的15%。这指的是政府的钱不够花时可以借债支出，但不能借债太多，超出财政总支出的15%就有风险。 如何弥补财政赤字一般来讲，当一国财政出现赤字时有两种解决办法，一是透支，二是发行国债。 透支就是财政部在中央银行有一个账户，就像我们每个人在银行都有账户，只能取出自己存进银行的钱。如果钱不够，就需要找银行借钱，就等于账户里出现了“红字”，也就是负数，这叫透支。最后，政府只能打开印钞机，用印钞来填补窟窿。但新的问题随之而来，打开印钞机就意味着通货膨胀要来了。 国债透支有这么大的弊端，说明这种透支行为不可取。那还有什么办法能解决财政赤字问题？有，那就是发行国债。 发行国债好处 人们拿着自己手中的钱购买国债，就意味着原计划储蓄的部分借给了政府。一般情况下，国债利息比银行存款利息高，这也是百姓乐于购买国债的原因。也就是说，你不花的钱政府借去花了，这样并不会增加货币总量，只是改变了存量分配。 政府通过发行国债获得资金，用于基建投资，加大政府支出，拉动经济增长，从经济增长中获得更多税收，再用获得的税收来赎回国债，还上借的钱。这样，政府就不用多印钞票，也就不会造成通货膨胀。 国债分类国债分为内债和外债，还分为短期、中期和长期三种。我国政府在外债上发行是的长期国债，在内债上发行的是短期、中期和长期国债。 债务危机发行国债的用途十分重要。发行国债一定不能用于经常性支出，而要用于建设性支出上。有些国家发行国债去给公务人员发工资，这样借的债就永远还不上了。因为经常性支出是给公务人员发工资，它不产生收益，也回不到政府手里，持续下去就会产生债务危机。","link":"/2022/10/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E8%B4%A2%E6%94%BF%E8%B5%A4%E5%AD%97%E4%B8%8E%E5%9B%BD%E5%80%BA/"},{"title":"中央银行","text":"银行是信用的产物银行既是信用的产物，也是信心的象征。只要大家信心在，银行就不会垮。这里需要强调的是，公众持有货币是一种信心，把钱放到银行里更是一种信心，只要公众的信心在，就不会发生恐慌，银行就可以运转下去。 只要一直有人存钱，银行就不会出问题。国际上那些几百年老字号的银行都是靠着信誉维持到今天的。无论存款人还是贷款人都相信这家银行，那这家银行就永远可以正常运转下去。 但如果有一天，一个人去一家银行取钱，银行没钱支付给他，那么银行有可能因为对这一个储户失去信用，而遭受灭顶之灾。一旦信用的缺口打开了，会有越来越多的人不信任这家银行，人们开始涌入银行去提款。储户是有权随时提取存款的，但银行贷出去的钱却不可能随时收回。 因此，从理论上讲，再好的银行也难以承受挤兑。当一个国家经济萧条，银行发生挤兑时，就可能一圈一圈地迅速恶性扩散。如果政府不进行抢救，就会引发通货膨胀，经济进入恶性循环，甚至导致政府破产。 银行破产首先打消的是人们对银行的信心，当人们对银行的信心消失时，银行就会倒下。当人们都去抛出货币，这个国家的货币就会贬值，通货膨胀就会来临。那么，谁能让商业银行遵守信用呢？是中央银行。 中央银行的诞生美国在20世纪初还没有中央银行，那时美国的银行经常出现支付危机，挤兑现象时有发生。美国在没有中央银行时，银行出了问题，政府财政出了问题，是靠谁解决的？ 在19世纪末20世纪初，美国一位叫JP. 摩根的人扮演了中央银行的角色。在美国出现中央银行之前，摩根一个人起到了中央银行的作用。联邦政府财政出了问题，找他出面解决；大公司出现问题，找他出面调停；银行出现问题，也请他出面解决。但一个国家的财政和金融问题也仅靠一个人来解决，这也未免太脆弱了。于是，美国诞生了中央银行。 美国在没有中央银行之前，摩根一个人充当了中央银行的角色。摩根去世后，美国在1914年成立了中央银行，就是美国联邦储备委员会。 中央银行的性质中央银行是一国银行体系的总枢纽，由政府赋予许多特权，通常具有官方地位，它是政府管理商业银行的机构。中央银行不以营利为目的，不直接经营商业银行的业务，而是代表政府管理整个银行系统。它的责任是制定货币政策，保证币值稳定。 为什么中央银行不能经营存贷业务呢？因为它代表一国政府来管理商业银行，如果央行也经营存贷业务，那所有人都会选择这条最安全的途径——把钱都存入中央银行。这样一来，其他商业银行就无法生存了。所以，中央银行不经营存贷业务，它只能制定货币政策，保证货币的稳定。只要让货币足值，保障人们随时能取出存款即可。 目前，世界绝大多数国家都有自己的中央银行，也就是在一般银行之外，单独设立中央银行。例如，美国的联邦储备系统（简称美联储）、英国的英格兰银行、德国的德意志银行、我国的中国人民银行等，它们都是本国的中央银行。 中央银行的职能 保持货币的足值 独占货币的发行权。一国的钞票是由央行发行的，任何银行都不可以随便发行钞票。 保证币值稳定。央行把钞票发出去，它要对所有持票的人负责。 人们手里拿到1元钱，这1元钱要有1元钱的购买力，如果买不到价值1元钱的东西，这是中央银行的责任，因为是央行让货币贬值了。所以，央行最重要的是保证币值的稳定。 币值稳定是一国经济健康的重要指标。如果一国货币升值，说明该国经济良好。人们都要这种货币时，该国货币就会升值；如果人们都不要这种货币，该国货币就要贬值。所以，货币标志着一国的经济实力，它是一种信心的象征，人们愿意持有一国货币是因为它的足值和稳定。 它是银行的银行 为商业银行保存准备金。央行是所有商业银行的坚强后盾。商业银行必须接受央行的监督和控制，它负责保存商业银行的准备金。 央行统一办理全国各银行的结算。它是商业银行的结算中心。比如，跨行汇款业务，就需要通过中央银行去结算。 央行充当最终贷款者。如果商业银行哪一天出现支付危机，或者储户来提款银行没钱，商业银行就可以找央行贷款，以应付紧急情况。 政府的银行 为政府提供金融服务，是政府的一个理财机构。它跟财政部一样，财政部负责政府财政上的收入和支出；而央行负责制定货币政策，它负责管理国家的这些钱。 对金融体系进行管理，所有商业银行要服从央行的管理。 央行集中保管黄金和外汇储备。一国的黄金由央行保管，外汇储备也由央行管理。我国的外汇储备由央行下设的外汇管理局管理。我国的黄金也由央行管理。 制定和执行货币政策。央行通过制定货币政策，来控制全国的商业银行，控制货币的投放量，因为钞票是央行印发的。央行还代表国家出席国际金融会议等。 中央银行的相对独立性西方经济学认为，央行应该相对独立于政府之外，它不能完全听政府的。虽然央行和财政部都是政府的理财机构，但它和财政部不一样，财政部要听命于一国政府，而央行不能完全听命于一国政府。 央行最重要的职能是保证一国币值的稳定。比如，美国决定要加入一场战争，总统让财政部配合，扩大财政支出。财政如果有钱的话，可以加大政府支出；财政如果没钱的话，政府可以发行国债，那样就可以筹措到战争的款项。但美国政府可以命令美国的中央银行，让它增发钞票吗？不可以。 如果央行和政府穿一条裤子，该国的货币就会贬值，因为央行对它的发钞不负责任了。我们谁还敢持有美元呢？所以，央行不能随意听从政府的要求。它必须相对独立于政府之外，它要对本国货币负责，对本国经济增长负责，对银行体系的安全负责。","link":"/2022/10/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E4%B8%AD%E5%A4%AE%E9%93%B6%E8%A1%8C/"},{"title":"政府调控经济的政策","text":"政府拉动经济增长有三驾马车：一是消费，二是投资，三是出口。一国经济要想平衡发展，它的总供给一定要等于总需求。如果不相等，政府不是动左手，就是动右手，那这两只手究竟怎么动？政府调控经济有三大政策：一是财政政策，二是货币政策，三是对外经济政策。 财政政策财政政策，主要是财政的收入与支出。财政的收入主要来自税收，政府通过收税来调控经济；财政的支出分成两大块：一块用于经常性支出，一块用于建设性支出，财政支出的多少也是政府调控经济的手段。总结起来，财政包含财政的收入、财政的支出、政府的税收、国家的债务。政府会用税收和支出来刺激或收缩经济，用赤字和债务来拉动经济。 货币政策货币政策，主要是中央银行的作用。在走向市场经济的过程中，我国货币政策在经济生活中的作用越来越重要。货币政策有三招：准备金率，贴现率和公开市场业务。中央银行控制着货币供给的闸门，它可以给经济“踩刹车”和“踩油门”。比如，现在世界都在关注美国的央行美联储是否降息，美联储就是通过利率来调控美国经济的冷与热。 对外经济政策对外经济政策，主要表现为汇率和关税的作用。随着我国加入世贸组织WTO以来，我国努力加大出口、吸引外商投资。这些年我国是吸引外资最多的国家之一，甚至超过了美国。外资直接投资到中国，说明他们看好了中国经济的未来。 一国经济为何不能一直高速增长？经济学有个原理叫生产可能性边界。一国有多少自然资源、财力资源、人力资源，都是有一定限制的，超过了这个限制经济就不再增长，只有价格的增长。但是随着科技的发展，未来生产可能性边界也会向外扩展。 上述这个例子是想说明，任何一国在一定的生产阶段，它只能干这个阶段该干的事情。这是由我国资源的稀缺性决定的，当我国经济的发展超过这种生产可能性边界时，经济就不可能继续向前发展了，这时必须“踩刹车”。如果不刹车，经济就会出现硬着陆。东西少需求多，导致价格上升，通货膨胀就会来临。 经济太冷时，我国政府就会实施“踩油门”政策。在财政政策上，减少税收，增加支出；在货币政策上，降低利率，增加货币供给量。当经济太冷时，央行会打开货币供给的水龙头，把利率从高位降下来，就是我们常说的降息。当利率很低时，人们更愿意贷款去投资、去买房。当人们觉得贷款消费合适时，钱就会重新流入经济领域。当人们愿意投资、消费、生产，觉得有钱可赚的时候，经济就会从谷底回升，由冷变暖。","link":"/2022/11/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E6%94%BF%E5%BA%9C%E8%B0%83%E6%8E%A7%E7%BB%8F%E6%B5%8E%E7%9A%84%E6%94%BF%E7%AD%96/"},{"title":"货币供给和需求","text":"货币供给的计算方法 货币的数量就叫货币供给。经济学家计算的货币是从我们身边带的纸币和硬币开始的，离身边最近的就是最活跃的货币，离我们最远的就是不活跃的货币。经济学家提出多种衡量货币供给的方法，我们先来看看一般西方经济学家计算货币供给的方法。 一般把货币供给分为三类，也就是三种官方的货币计算标准，M1、M2、M3。M就是Money的首字母。 计算货币供给的第一种方法是M1，它是狭义的货币供给。 M1=现金+活期存款 计算货币供给的第二种方法是M2，它是广义的货币供给。 M2=M1+定期存款 计算货币供给的第三种方法是M3。 M3=M2+其他金融机构的存款，所以M3是更广义的货币供给。 我国计算货币供给的方法，也有三种。 流通中的货币，用M0来表示。现金是中国人民银行发行的钞票，就是通货。这是最活跃的货币，可以直接把它当钱来花。 M0=现金（通货） 狭义货币供给，用M1表示。 M1=M0+企业活期存款 广义货币供给，用M2表示。 M2=M1+企业定期存款+居民储蓄存款+财政存款我们通常使用的是M2，这是广义的货币供给。 经济学家之所以要使用几种不同的计算货币供给方法，是因为仅仅根据一种方法不足以预测经济活动水平的变化。比如，为什么有时货币供给特别多，这是因为经济中出现赚钱的机会，人们就会把M2变成M1，把定期存款变成活期存款，把活期存款变成现金，然后直接买房或买股票；相反，如果经济遇冷时，大家都不花钱，现金就会变成M1，M1变成M2，最后变成存在银行里的钱，所以钱就感觉少了。我们在实际研究中以M1作为货币供给的定义。 货币需求 那谁来决定货币供给的多与少呢？这由中央银行决定，因为钞票是央行发的，法定准备金是央行定的，公开市场业务是央行做的，央行控制着货币供给的总闸门。货币需求有流量和存量之分，人们每月得到的工资收入是一个流量，人们在手里或银行账户上所拥有的货币就是一个存量。我们讲的货币需求通常指的是存量，就是人们在某个时点愿意持有的货币量。 人们持有货币主要有三种需求：交易需求、预防需求、投机需求。 货币的交易需求和预防需求与收入正相关，与利率负相关；货币的投机需求与收入的关系不大，与市场利率关系很大。利率越高，投机的需求越少；利率越低，投机的货币需求越多。 货币的流通速度一国流通中客观上需要多少货币还取于货币的流通速度。什么叫货币的流通速度呢？就是1元货币一年周转多少次。货币周转次数越多，需要的货币量就越少，货币周转次数越少，需要的货币量就越多。 1982年，美国的每1美元一年转6.7次。我国在1980年时每1元转2.06次，到1991年为1.13次。所以我国的货币需求量就比美国要多。所以，货币流通速度的高低，与货币需求有很密切的关系。 均衡利率货币供给最终是由中央银行决定的。在货币政策不变时，货币供给量是一定的。货币需求由价格、GDP、利率三种因素决定。在既定的时点和既定的价格水平上，可以把GDP视为固定的，那么货币需求主要由利率决定。货币是一种存量，当供给的货币量等于需求的货币量时，货币供求就实现了平衡。均衡利率指的就是货币供求平衡时的利率。所以，利率的调整使货币供求实现了平衡，央行就是通过利率来调控宏观经济的。 基础货币基础货币=通货+准备金 通货就是流通领域的货币；准备金就是要交给中央银行的钱。放在你手里的钱都叫通货，放进中央银行的钱就变成了准备金。 基础货币的定义是指能够派生出信用货币的货币，它主要由央行对商业银行的再贷款形成。基础货币必须是中央银行的货币。换句话说，基础货币就是中央银行发行的钞票。","link":"/2022/10/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E8%B4%A7%E5%B8%81%E4%BE%9B%E7%BB%99%E5%92%8C%E9%9C%80%E6%B1%82/"},{"title":"货币政策工具","text":"法定准备金率实行存款准备金制度的最初目的是防止银行出现大量挤兑。后来演变为央行控制货币供给的一个重要工具。准备金率下调，意味着央行打开了货币供给的水龙头，商业银行可贷出的钱就多了。所以，当央行降低准备金率时，钱就从银行流了出来，它能够为经济提供更多的货币支撑。 什么情况下央行会提高准备金率？经济过热，放出去的贷款过多，快要产生通胀时，央行就会提高准备金率。把准备金率从5%提到15%，这样，原来商业银行可贷出95元，现在只能贷出85元了。假定一家商业银行持有1亿元人民币，按照5%的准备金率，它要缴存500万元准备金，可贷出9 500万元。准备金率提到15%，它的1亿元就只能贷出8 500万元了。商业银行要马上收回它多贷出去的10%的金额，它要从企业中把1 000万元收回来上缴央行，这会发生一系列追讨资金的行为。 提高准备金率就是把流通领域的钱抽走，经济中没了资金的流动性，很大一笔钱要被冻结起来放进中央银行，经济发展就会放缓。所以说，央行调整准备金率是一个非常强有力的手段 什么情况下央行会降低准备金率呢？在经济萧条时期，供过于求，所有的东西都卖不出去。央行就会打开货币供给的水龙头。 因此，我们说调整法定准备金率是一个非常强烈的手段，它只有在特殊情况下才能使用。 贴现率贴现率是指将未来支付改变为现值所使用的利率，或指持票人以没有到期的票据向银行要求兑现，银行将利息先行扣除所使用的利率。这种贴现率也指再贴现率，即各成员银行将已贴现过的票据作担保，作为向中央银行借款时所支付的利息。 如果央行货币政策是紧的，贴现率就高，说明央行不愿意放出钱来。如果央行给出一个低贴现率，说明央行愿意把钱放出来。所以，央行是通过贴现率来控制货币的闸门。事实上，中央银行对利率只有一个权利，就是它能够决定贴现率。 贴现率是由央行定的，那商业银行的利率是由谁来决定的？我们说，在市场经济国家，利率既不是政府定的也不是央行定的，利率是由市场来决定的。美元利率为什么有时高有时低呢？如果美国有商机，市场上好赚钱，大家都需要美元，美元的需求大于供给，美元的利率就高；相反，如果大家不看好美国经济，都不要美元，美元的供给大于需求，美元的利率就低。因此，利率是由市场供求决定的。 央行只能决定贴现率，在中国它叫再贷款利率，在美国它叫联邦基准利率。央行可以用贴现率来给市场降温或给市场加油。 比如，原来贴现率是5%，现在变成8%，就说明通胀严重，央行不准备把钱放出去。你想想看，央行给商业银行的贴现率是8%，商业银行贷出的利率就得高于8%。贷款利率过高，企业就不会去贷款投资了，人们不去贷款消费了，商品价格就会降下来，通胀率就被控制住了。 因此，我们说贴现率也是一个比较强硬的手段。但央行不能经常调整贴现率，因为利率杠杆一动，引起的市场波动太大。 公开市场业务公开市场业务是指央行在公开市场上进行操作，买进或卖出债券。这些债券有三个月期、半年期、一年期、三年期和五年期的不等。 央行发现经济冷了，它决定打开货币水龙头，就是在公开市场买进债券。当经济太冷时，市场需要现金。央行买进债券就放出了现金，这就打开了货币供给的水龙头。央行收购国债，把钱放出来，鼓励人们去消费、去投资。央行这样做的目的是刺激经济回升。 央行在哪种情况下会卖出国债呢？就是当央行发现经济需要降温，再热下去要出现泡沫，通胀率高了，央行就会在公开市场上卖出国债。央行给一个高利率吸引人们购买债券，让人们都愿意持有国债。当人们持有债券时，就没有钱去消费和投资了，市场上流动的现金减少了，经济就会适度降温。 公开市场操作可以频繁进行，它可以对经济进行微调。我们说，公开市场业务就是央行和百姓之间买卖国债，它是现金和债券的互换。央行通过债券的买卖控制货币供给的多与少。","link":"/2022/10/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96%E5%B7%A5%E5%85%B7/"},{"title":"货币职能与发行","text":"货币的职能货币具备四种职能。 交换媒介：我们每个人身上或多或少都要带些钱，用来购买商品和服务。货币就是交换的媒介，没有它，我们每天的交换几乎都无法完成。 贮藏：一种货币在一定时期内必须能够保值。否则人们将不再需要这种货币，宁愿把它换成商品或其他国家的足值货币。 计量单位：我们到商场买东西，不同的商品有不同的价格，相同商品在不同的商店价格也不同。 延期支付：你今天买了东西，以后再付钱的这种行为就叫延期支付。假定你经营一家企业，可供货的原材料厂商很多，选择的主动权就在你手上。这时你可以告诉供应商：“你先把东西放这儿，两个月后我再付钱给你。” 延期支付的信用问题因为货币具有延期支付的职能，人们之间就有了信用，接着就出现了赊欠行为。但并不是每个人都遵守承诺，很多人不守信用，到期不付钱，这样一来，商家就损失了。 这时银行出现了，银行说，商家之间不必相互赊账。谁想借钱就来找我，我负责借钱，负责追债，银行会让所有人都遵守信用制度。就这样，银行成了买卖双方的信用中介。 大家存钱到银行，借钱也到银行。银行是靠赚存款和贷款的差价来生存的。银行业就这样发展起来了。银行出现后，在更大的基础上创造了信用，使人类社会的发展加快了脚步。 准备金当一个储户把钱存进银行时，银行不能把这些钱全都贷出去。这是为了保证储户取钱时有钱，各个银行都要有一部分准备金。 为了避免部分银行准备金过少没有足够的钱支付储户取款从而出现挤兑现象各国中央银行都规定了一个法定准备金率。商业银行不能把储户的存款都贷出去，必须留下一部分钱作为准备金，强制性地存到中央银行，如果储户来提款，银行要有钱支付给他们。 我国的商业银行也要上交法定准备金。当储户到银行取钱时，银行一定得有钱给他，如果这家银行没有钱，它可以去中央银行或找其他银行拆借，无论如何银行都要把钱支付给储户，这是银行的信用。 商业银行为什么能找中央银行去借钱呢？因为它在中央银行存放了法定准备金。这时，又产生了一个新问题。就是说，现代社会的货币供给是由银行创造的。 银行创造货币的过程假定，我国的法定准备金率是20%，一个储户手里有1 000元钱，他把这笔钱存入了中国工商银行（简称工行），工行必须把200元留下交给中央银行（我国的中央银行是指中国人民银行），工行只能贷出800元。 此时，有人正好去工行借800元，他要买一台吸尘器。到了商场，他把钱交给柜台，商场又把这800元存入自己的开户行——中国农业银行（简称农行）。 当农行收到这笔钱时，这800元钱它也不能都贷出去，必须把160元上交中央银行，只能贷出640元。这时正好有人想买个榨汁机，就去农行借钱，当他借到640元后，到一家超市买了榨汁机，把640元钱交到收款台，这家超市又把这640元存入自己开户行——中国建设银行（简称建行）。 建行接到这笔钱后，要把20%的法定准备金交到中央银行，它只能贷出512元。如此下去，储户的这1 000元存款通过银行系统不断的存贷而被放大，最后变成多少钱了呢？ 我们看，账面上银行新增存款是5 000元，新增贷款是4 000元，货币总量增加了5000元，法定准备金是1 000元。 然而，中央银行并没有多印一张钞票，钱怎么就多出这么多呢？这是银行通过信用活动创造出来的。所以说，银行具有创造货币供给的功能。 货币乘数什么叫货币乘数？准备金率变化和存款最后变化之间的关系就叫货币乘数。 银行创造的货币与法定准备金率成反比。银行创造货币能力的大小，取决于准备金率的高与低。准备金率越高，货币乘数就越小，准备金率越低，货币的乘数就越大。 通货外流通货外流是指现实中并不是所有的银行放出去的贷款都能以准备金的形式再回到银行。某些贷款从银行体系中漏出去了，就叫通货外流。 比如，你今天到超市买东西，但超市没有把你的这笔钱存入银行，而是留下用于明天的进货。这笔钱进入了流通领域，它就不能创造货币供给增加。 由于通货外流，使现实中的货币乘数小于理论上的货币乘数。只有通过银行信贷活动创造的新存款，才能增加现有货币量。当人们把钱存进银行时，经济就开始加速了。 乘数效应人们把钱存进银行，银行把钱贷给他人，他人再放进银行，银行接着再贷出去。就这样，一笔钱一直存贷下去，货币供给量就会成倍增加，经济规模和增长速度也会成倍放大。这就是乘数效应。 当我们去银行取钱时，银行应该有钱，我们每个人都能取出来。这并不是纯粹数字的虚增，因为在每一个环节上都有新的财富创造出来。 让我们来思考一下，到银行存钱的人，他是从哪里得到这笔钱呢？ 因为他销售了产品，为别人提供了服务，获得了报酬；而那些从银行借钱的人，他也要通过自己的经营活动获得利润，才能把借银行的这笔钱还上。因此，我们说，这里的每一个环节都在创造财富，也都在增加财富。银行通过信用创造的货币供给是真实存在的。 由此，银行的信誉越好，它创造货币供给的能力就越大。一国的法定准备金率越低，银行创造的货币供给就越多。这就像货币的水龙头，法定准备金率降低时，水就会流出来；法定准备金率提高时，资金之水就会被抽走。 明白了这一点，我们就能知道为什么央行调整法定准备金率，能发挥出强大的调控经济作用。同时大家还会明白，现代社会经济是一环接一环扣在银行身上加速运行的。","link":"/2022/10/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E8%B4%A7%E5%B8%81%E7%9A%84%E8%81%8C%E8%83%BD/"},{"title":"金融市场","text":"什么是金融市场由于货币具有延期支付的职能，就产生了信用，在信用的基础上出现了银行，银行出现后，因为它具有创造货币的功能，就在更大的基础上创造了信用。这就涉及到了金融。 什么叫金融？金融就是由货币、信用和银行形成的资金融通，取中间两个字称为“金融”。凡是货币转移、票据交易、银行信贷、证券投资，都属于金融活动，为这些活动提供的场所叫金融市场。 在现代社会，有些人有钱不想投资，另一些人没钱但想投资。为了使储蓄者和投资者结合起来，就需要一条渠道，金融市场的作用就是提供渠道，实现资金从储蓄者向投资者转移。正是由于有不同需求，才有了金融市场。因此，金融市场是一个大的概念，它包括了所有的金融活动。 间接融资和直接融资的区别通过银行完成的信贷活动叫间接融资，通过证券市场完成的交易活动叫直接融资，区别就在于前者的风险在银行，后者的风险在个人。 间接融资，就是找银行借钱。 银行创造了资金的流动性，它可以贷出多笔资金，只要滚动着向前走即可，即使有少数贷款收不回来，还是能保证多数贷款按期还上。只要有资金不断流入，银行就能向前发展。当一些企业效益不好、出现问题时，银行会冻结并收回它们的贷款。银行可以把资金从夕阳产业转向朝阳产业，通过银行这只手，资金流向有利润、有前途的行业，这使得经济可以在良性循环的轨道上发展。 直接融资，就是到股市融资。 资金成本最低，除了上市费用和以后给股东分红外，上市公司不必归还本金。所以，找银行借钱叫间接融资，到证券市场发行股票叫直接融资。 我国目前正在努力拓宽直接融资的渠道，分散银行储蓄过多的压力，也分担银行贷款的负担。建立和完善我国股票市场和资本市场，这是我国政府面临的一项艰巨任务。 在过去那些年，我国经济活动中大量出现的都是间接融资，老百姓存钱只能到银行，投资者借钱也只有找银行。这样就使银行的负担过重。 相反，有很多新兴的、有潜力的企业不具备相当的规模和信誉，也够不上银行的贷款条件。所以企业到银行贷款就变得非常困难，银行还要承受支付储户利息的巨大压力。这使得很多银行贷款都流向了房地产市场。 我国金融体制改革的大趋势就是变间接融资为直接融资，而发展壮大我国的资本市场是大势所趋。 货币市场和资本市场什么是货币市场货币市场是在短期内(一年以内)的金融资产交易的市场，产品有短期国债、银行汇票等。在货币市场上进行的交易都具有期限短、风险小、流动性强的特点，在货币供应层次划分上在现金货币和存款货币之后，被称为准货币，所以被称为货币市场。货币市场可以解决借款者的短期资金需求的问题，也可以为暂时闲置的资金找到合适的安放渠道。 什么是资本市场资本市场是进行中长期(一年以上)资金借贷融通活动的市场，产品有股票、20年期公司债券等。在资本市场上进行的交易都具有融资期限长、风险大、流通性差的特点，但同时也具有长期稳定的收入，跟资本投入相似，所以被称为资本市场。 货币市场和资本市场有什么区别 特点不同。货币市场的特点是交易期限短、风险低、流动性强。而资本市场的特点是资金借贷量大、风险性强、流动性差、期限长 功能不同。货币市场可以解决流动资金、短期资金问题，同时是政府、银行的信用工具。资本市场为筹集资金提供场所，解决资本结构，长期资金问题，可以进行资源的合理配置，有利于企业重组。 子市场不同。货币市场由同行业拆借市场、票据市场等6个子市场构成。资本市场包括银行中长期存贷款市场和有效证券市场。 总而言之，货币市场与资本市场最大的区别，其实就是金融工具和期限的不同。但二者的区别并不仅仅在于此，它们的资金来源以及融资目的以及风险程度和收益水平都不同。","link":"/2022/10/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E9%87%91%E8%9E%8D%E5%B8%82%E5%9C%BA/"},{"title":"通货膨胀","text":"什么是通货膨胀什么是通货膨胀？一国物价总水平普遍而持续地上升，就叫通货膨胀。如果只有一种商品的价格上升，这不是通货膨胀，只有大多数商品的价格都上升，而且物价水平是持续上涨，这才是通货膨胀。 通货膨胀如何衡量通货膨胀怎么衡量呢？一般是用价格指数来衡量通货膨胀。因为通货膨胀最终要通过物价水平的上涨表现出来，所以物价总水平的持续上涨幅度，就成为通货膨胀的标志。各国都用价格指数来表示一国的通货膨胀率。 国外最常用的价格指数有三种：一是消费价格指数；二是生产价格指数；三是批发价格指数。 消费价格指数（CPI），它衡量的是一篮子消费品和劳务的市场成本。这一篮子里主要大类是食物、衣服、住房、燃料、交通和医疗。这里包括了人们的衣食住行。 生产价格指数用来测量生产者卖给批发商的商品价格水平。 生产价格指数用来测量生产者卖给批发商的商品价格水平。 为什么有这么多的价格指数呢？因为只有一种价格指数不足以衡量价格水平变化的趋势。当你看到生产价格指数涨了，批发价格指数也涨了，你就会知道消费价格指数很快就会跟着涨了。这些指数就是用来判断价格变化的趋势。 通货膨胀类型通货膨胀有三种类型：一是温和的通货膨胀；二是奔腾式的通货膨胀；三是恶性通货膨胀。 温和的通货膨胀是指年率低于10%的通货膨胀率，也叫1位数的通胀。凡是10%以下的都叫作温和的通货膨胀。 奔腾式的通货膨胀是指一国通货膨胀按照20%、100%甚至200%的年率上升，就是2位数或3位数的通胀。这时物价就控制不住了，由于货币价值损失得太快，人们都不愿意持有任何货币，金融市场消失了，人们囤积商品，购买房屋，谁都不会按照普通的利率贷出货币。在阿根廷和巴西都曾出现过100%的通货膨胀率。 当恶性通货膨胀来临时，经济将遭受巨大的灾难。“一战”后的德国就发生了恶性通货膨胀。由于德国政府无法借债也收不上税，于是德国政府就打开了印钞机，把货币和价格都推向了天文数字。一个德国人在1922年拥有一张价值3亿美元的债券，两年后，这张债券连一块橡皮糖都买不到。国民手里的钱都变成了废纸。 指数化尽管通货膨胀非常可恶，但当它被预计到时，通货膨胀带来的大部分经济成本便会消失。这里有一个概念叫指数化。 简单地说，如果人们预测到今年的通货膨胀率是10%，那么工资收入也要提高10%，这就是指数化。把工资收入和通货膨胀率挂钩。西方国家价格指数化比较普遍。如工资价格指数化、社会保障支付指数化、利息和利率指数化。由于指数化的出现，整个经济中通胀造成的损失减缓了。 通货膨胀受害者通货膨胀的受害者包括三类人：一是放贷者；二是退休者；三是现金持有者。 第一类受害者：放贷者。由于大多数的贷款没有指数化，通货膨胀上升，就意味着放款者从借款者那里收回的钱低于它借出时的价值。还有许多人把他们为退休准备的积蓄，大部分拿去买了债券或证券，如果通货膨胀发生，他们将蒙受损失。当通货膨胀突然出现，借给别人钱的人着急了，因为收回的钱贬值了，这时借款人合适了，他还的钱少了。通货膨胀有利于债务人，不利于债权人。 第二类受害者：退休者。退休后如果他们的收入一直都没有调整，依然保持原来的退休工资，那物价水平的上升会使退休者的生活水平变糟。许多退休者只拥有固定的养老金，为了满足退休生活的需要，他们储蓄了一生，但通货膨胀可能意味着他们的养老金收入将不足以使他们按照自己期望的方式生活。因此，在通货膨胀时期，最受打击的是退休者。 第三类受害者：现金持有者。因为手头的现金会随通货膨胀而贬值。所以，通货膨胀对持有现金的人来说就是一种税收。经济学家把它称为“通货膨胀税”。如果一国的通货膨胀率是5%，就相当于你手里的现金交了5%的税。所以，凡是持有现金者都得再缴一个“通货膨胀税”，这是政府对公众财富的一种掠夺。在我国，许多农民手中的钱放在手边或存在家中的，通货膨胀对他们的损失将是巨大的。","link":"/2022/11/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80/%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80/"}],"tags":[{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"回溯法","slug":"回溯法","link":"/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"自控力","slug":"自控力","link":"/tags/%E8%87%AA%E6%8E%A7%E5%8A%9B/"},{"name":"宏观经济通识课","slug":"宏观经济通识课","link":"/tags/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/"}],"categories":[{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"编程语言","slug":"计算机基础/编程语言","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Go","slug":"计算机基础/编程语言/Go","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/"},{"name":"数据库","slug":"计算机基础/数据库","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PHP","slug":"计算机基础/编程语言/PHP","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"数据结构","slug":"计算机基础/数据结构","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"计算机基础/算法","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/"},{"name":"计算机组成原理","slug":"计算机基础/计算机组成原理","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"计算机基础/数据库/MySQL","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"心理","slug":"读书笔记/心理","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%90%86/"},{"name":"经济理财","slug":"读书笔记/经济理财","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BB%8F%E6%B5%8E%E7%90%86%E8%B4%A2/"}],"pages":[]}