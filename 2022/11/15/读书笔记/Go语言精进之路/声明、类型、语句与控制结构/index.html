<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>声明、类型、语句与控制结构 - Kurisu&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kurisu&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kurisu&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="使用一致的变量声明形式 变量声明形式的选择上应尽量保持项目范围内一致。 Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。 就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用"><meta property="og:type" content="blog"><meta property="og:title" content="声明、类型、语句与控制结构"><meta property="og:url" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"><meta property="og:site_name" content="Kurisu&#039;s Blog"><meta property="og:description" content="使用一致的变量声明形式 变量声明形式的选择上应尽量保持项目范围内一致。 Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。 就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115213038800.png"><meta property="article:published_time" content="2022-11-15T12:17:37.000Z"><meta property="article:modified_time" content="2022-11-16T14:29:05.621Z"><meta property="article:author" content="Kurisu"><meta property="article:tag" content="Go"><meta property="article:tag" content="Go语言精进之路"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},"headline":"声明、类型、语句与控制结构","image":["https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png","https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115213038800.png"],"datePublished":"2022-11-15T12:17:37.000Z","dateModified":"2022-11-16T14:29:05.621Z","author":{"@type":"Person","name":"Kurisu"},"publisher":{"@type":"Organization","name":"Kurisu's Blog","logo":{"@type":"ImageObject","url":"https://mrcq.github.io/img/logo.svg"}},"description":"使用一致的变量声明形式 变量声明形式的选择上应尽量保持项目范围内一致。 Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。 就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用"}</script><link rel="canonical" href="https://mrcq.github.io/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto Serif Simplified Chinese:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ed68212360e83c07d191372605274f6e";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="D5E963705D472839D42E0AC1C65D96AB"><script src="https://www.googletagmanager.com/gtag/js?id=G-X1YWL675NS" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-X1YWL675NS');</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Kurisu&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>声明、类型、语句与控制结构</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2022-11-15T12:17:37.000Z" title="2022-11-15T12:17:37.000Z">2022-11-15</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-11-16T14:29:05.621Z" title="2022-11-16T14:29:05.621Z">2022-11-16</time></span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span><span class="level-item">1 小时读完 (大约6846个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><h2 id="使用一致的变量声明形式"><a href="#使用一致的变量声明形式" class="headerlink" title="使用一致的变量声明形式"></a>使用一致的变量声明形式</h2><ul>
<li>变量声明形式的选择上应尽量保持项目范围内一致。</li>
<li>Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。</li>
<li>就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合。</li>
<li>包级变量，只能使用 var 关键字的变量声明方式。</li>
<li>尽量在分支控制时应用短变量声明形式。<span id="more"></span></li>
</ul>
<p><img src="/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115202919317.png"></p>
<h2 id="使用无类型常量简化代码"><a href="#使用无类型常量简化代码" class="headerlink" title="使用无类型常量简化代码"></a>使用无类型常量简化代码</h2><ul>
<li>Go是对类型安全要求十分严格的编程语言。Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算。有类型常量给代码简化带来了麻烦，但这也是Go语言对类型安全严格要求的结果。</li>
<li>无类型常量也拥有自己的默认类型：无类型的布尔型常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对应的默认类型分别为bool、int、int32(rune)、float64、complex128和string。</li>
<li>所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。当操作数是常量时，在编译时也能发现一些运行时的错误，例如整数除零、字符串索引越界等。</li>
<li>无类型常量是Go语言推荐的实践，它拥有和字面值一样的灵活特性，可以直接用于更多的表达式而不需要进行显式类型转换，从而简化了代码编写。此外，按照Go官方语言规范的描述，数值型无类型常量可以提供比基础类型更高精度的算术运算，至少有256 bit的运算精度。</li>
</ul>
<h2 id="使用iota实现枚举常量"><a href="#使用iota实现枚举常量" class="headerlink" title="使用iota实现枚举常量"></a>使用iota实现枚举常量</h2><ul>
<li><p>Go的const语法提供了“隐式重复前一个非空表达式”的机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape</span><br><span class="line">    Pear, Watermelon</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>常量定义的后两行没有显式给予初始赋值，Go编译器将为其隐式使用第一行的表达式，这样上述定义等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Apple, Banana = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Strawberry, Grape  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">    Pear, Watermelon  = <span class="number">11</span>, <span class="number">22</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>iota是Go语言的一个预定义标识符，它表示的是const声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的iota自身也是一个无类型常量，可以像无类型常量那样自动参与不同类型的求值过程，而无须对其进行显式类型转换操作。</p>
</li>
<li><p>Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PI   = <span class="number">3.1415926</span>              <span class="comment">// π</span></span><br><span class="line">    PI_2 = <span class="number">3.1415926</span> / (<span class="number">2</span> * <span class="literal">iota</span>) <span class="comment">// π/2</span></span><br><span class="line">    PI_4                          <span class="comment">// π/4</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>使用有类型枚举常量保证类型安全:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/time/time.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weekday <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Sunday Weekday = <span class="literal">iota</span></span><br><span class="line">    Monday</span><br><span class="line">    Tuesday</span><br><span class="line">    Wednesday</span><br><span class="line">    Thursday</span><br><span class="line">    Friday</span><br><span class="line">    Saturday</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="尽量定义零值可用的类型"><a href="#尽量定义零值可用的类型" class="headerlink" title="尽量定义零值可用的类型"></a>尽量定义零值可用的类型</h2><ul>
<li><p>当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值。</p>
</li>
<li><p>Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）。</p>
<p>所有整型类型：0</p>
<p>浮点类型：0.0</p>
<p>布尔类型：false</p>
<p>字符串类型：””</p>
<p>指针、interface、切片（slice）、channel、map、function：nil</p>
<p>另外，Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。</p>
</li>
<li><p>Go中的切片类型具备零值可用的特性，我们可以直接对其进行append操作，而不会出现引用nil的错误。</p>
</li>
<li><p>Go标准库的设计者很贴心地将sync.Mutex结构体的零值设计为可用状态，让Mutex的调用者可以省略对Mutex的初始化而直接使用Mutex。</p>
</li>
<li><p>Go语言零值可用的理念给内置类型、标准库的使用者带来很多便利。不过Go并非所有类型都是零值可用的，并且零值可用也有一定的限制，比如：在append场景下，零值可用的切片类型不能通过下标形式操作数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">12</span>         <span class="comment">// 报错！</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>另外，像map这样的原生类型也没有提供对零值可用的支持：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;go&quot;</span>] = <span class="number">1</span> <span class="comment">// 报错！</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">m1[<span class="string">&quot;go&quot;</span>] = <span class="number">1</span> <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>另外零值可用的类型要注意尽量避免值复制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu1 := mu <span class="comment">// 错误: 避免值复制</span></span><br><span class="line">foo(mu) <span class="comment">// 错误: 避免值复制</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过指针方式传递类似Mutex这样的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">foo(&amp;mu) <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
<li><p>保持与Go一致的理念，给自定义的类型一个合理的零值，并尽量保持自定义类型的零值可用，这样我们的Go代码会更加符合Go语言的惯用法。</p>
</li>
</ul>
<h2 id="使用复合字面值作为初值构造器"><a href="#使用复合字面值作为初值构造器" class="headerlink" title="使用复合字面值作为初值构造器"></a>使用复合字面值作为初值构造器</h2><ul>
<li><p>Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;<span class="string">&quot;tony&quot;</span>, <span class="number">23</span>&#125;</span><br><span class="line">a := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>&#125;</span><br><span class="line">sl := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>&#125;</span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> &#123;<span class="number">1</span>:<span class="string">&quot;hello&quot;</span>, <span class="number">2</span>:<span class="string">&quot;gopher&quot;</span>, <span class="number">3</span>:<span class="string">&quot;!&quot;</span>&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>field:value形式的复合字面值初值构造器与普通复合字面值形式不同，field:value形式字面值中的字段可以以任意次序出现，未显式出现在字面值的结构体中的字段将采用其对应类型的零值。</p>
</li>
<li><p>复合字面值作为结构体值构造器的大量使用，使得即便采用类型零值时我们也会使用字面值构造器形式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := myStruct&#123;&#125; <span class="comment">// 常用</span></span><br><span class="line">s := <span class="built_in">new</span>(myStruct) <span class="comment">// 较少使用</span></span><br></pre></td></tr></table></figure></li>
<li><p>不允许将从其他包导入的结构体中的未导出字段作为复合字面值中的field，这会导致编译错误。</p>
</li>
<li><p>对于数组/切片类型而言，当元素为复合类型时，可以省去元素复合字面量中的类型，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">float64</span></span><br><span class="line">    y <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sl := []Point&#123;</span><br><span class="line">    &#123;<span class="number">1.2345</span>, <span class="number">6.2789</span>&#125;, <span class="comment">// Point&#123;1.2345, 6.2789&#125;</span></span><br><span class="line">    &#123;<span class="number">2.2345</span>, <span class="number">19.2789</span>&#125;, <span class="comment">// Point&#123;2.2345, 19.2789&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于key或value为指针类型的情况，也可以省略“&amp;T”：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]*Point&#123;</span><br><span class="line">    <span class="string">&quot;Persepolis&quot;</span>: &#123;<span class="number">29.935523</span>, <span class="number">52.891566</span>&#125;,   <span class="comment">// 相当于value为&amp;Point&#123;29.935523, 52.891566&#125;</span></span><br><span class="line">    <span class="string">&quot;Uluru&quot;</span>:      &#123;<span class="number">-25.352594</span>, <span class="number">131.034361</span>&#125;, <span class="comment">// 相当于value为&amp;Point&#123;-25.352594, 131.034361&#125;</span></span><br><span class="line">    <span class="string">&quot;Googleplex&quot;</span>: &#123;<span class="number">37.422455</span>, <span class="number">-122.084306</span>&#125;, <span class="comment">// 相当于value为&amp;Point&#123;37.422455, -122.084306&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m2) <span class="comment">// map[Googleplex:0xc0000ae050 Persepolis:0xc0000ae030 Uluru:0xc0000ae040]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="了解切片实现原理并高效使用"><a href="#了解切片实现原理并高效使用" class="headerlink" title="了解切片实现原理并高效使用"></a>了解切片实现原理并高效使用</h2><ul>
<li>Go数组是值语义的，这意味着一个数组变量表示的是整个数组，这点与C语言完全不同。在C语言中，数组变量可视为指向数组第一个元素的指针。而在Go语言中传递数组是纯粹的值拷贝，对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗。这时很多人会使用数组指针类型来定义函数参数，然后将数组地址传进函数，这样做的确可以避免性能损耗，但这是C语言的惯用法，在Go语言中，更地道的方式是使用切片。</li>
<li>切片可以提供比指针更为强大的功能，比如下标访问、边界溢出校验、动态扩容等。</li>
<li>通过语法u[low: high]形式进行数组切片化而创建的切片，一旦切片cap触碰到数组的上界，再对切片进行append操作，切片就会和原数组解除绑定。</li>
<li>重新分配底层数组并复制元素的操作代价很大，如果可以预估出切片底层数组需要承载的元素数量，强烈建议在创建切片时带上cap参数。</li>
</ul>
<h2 id="了解map实现原理并高效使用"><a href="#了解map实现原理并高效使用" class="headerlink" title="了解map实现原理并高效使用"></a>了解map实现原理并高效使用</h2><ul>
<li><p>map对value的类型没有限制，但是对key的类型有严格要求：key的类型应该严格定义了作为“==”和“!=”两个操作符的操作数时的行为，因此函数、map、切片不能作为map的key类型。</p>
</li>
<li><p>map类型不支持“零值可用”，未显式赋初值的map类型变量的零值为nil。对处于零值状态的map变量进行操作将会导致运行时panic。</p>
</li>
<li><p>和切片一样，map也是引用类型，将map类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对map变量的修改在函数外部也是可见的。</p>
</li>
<li><p>面对一个非nil的map类型变量，我们可以向其中插入符合map类型定义的任意键值对。Go运行时会负责map内部的内存管理，因此除非是系统内存耗尽，我们不用担心向map中插入数据的数量。如果key已经存在于map中，则该插入操作会用新值覆盖旧值。</p>
</li>
<li><p>map类型更多用在查找和数据读取场合。所谓查找就是判断某个key是否存在于某个map中。我们可以使用“comma ok”惯用法来进行查找：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, ok := m[<span class="string">&quot;key&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// &quot;key&quot;不在map中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果key不存在于map中，我们看到v仍然被赋予了一个“合法”值0，这个值是value类型int的零值。在这样的情况下，我们无法判定这个0是“key3”对应的值还是因“key3”不存在而返回的零值。为此我们还需要借助“comma ok”:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">m[<span class="string">&quot;key1&quot;</span>] = <span class="number">1</span></span><br><span class="line">m[<span class="string">&quot;key2&quot;</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">v := m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">v = m[<span class="string">&quot;key3&quot;</span>]</span><br><span class="line">fmt.Println(v) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
<li><p>即便要删除的数据在map中不存在，delete也不会导致panic。</p>
</li>
<li><p>对同一map做多次遍历，遍历的元素次序并不相同。这是因为Go运行时在初始化map迭代器时对起始位置做了随机处理。因此千万不要依赖遍历map所得到的元素次序。如果你需要一个稳定的遍历次序，那么一个比较通用的做法是使用另一种数据结构来按需要的次序保存key，比如切片。</p>
</li>
<li><p>充当map描述符角色的hmap实例自身是有状态的（hmap.flags）且对状态的读写是没有并发保护的，因此map实例不是并发写安全的，不支持并发读写。如果对map实例进行并发读写，程序运行时会发生panic。比如下面并发读写map的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter3/sources/map_concurrent_read_and_write.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doIteration</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        _ = fmt.Sprintf(<span class="string">&quot;[%d, %d] &quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWrite</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        m[k] = v + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">1</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="number">13</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">            doIteration(m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">            doWrite(m)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Go 1.9版本中引入了支持并发写安全的sync.Map类型，可以用来在并发读写的场景下替换掉map。另外考虑到map可以自动扩容，map中数据元素的value位置可能在这一过程中发生变化，因此Go不允许获取map中value的地址，这个约束是在编译期间就生效的。示例代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := m[key]  <span class="comment">// 无法获取m[key]的地址</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure></li>
<li><p>map底层结构如下：<img src="/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/image-20221115213038800.png"></p>
</li>
<li><p>和切片一样，尽量使用cap参数创建map避免频繁扩容降低性能。</p>
</li>
</ul>
<h2 id="了解string实现原理并高效使用"><a href="#了解string实现原理并高效使用" class="headerlink" title="了解string实现原理并高效使用"></a>了解string实现原理并高效使用</h2><ul>
<li><p>在Go语言中，无论是字符串常量、字符串变量还是代码中出现的字符串字面量，它们的类型都被统一设置为string。</p>
</li>
<li><p>string类型的数据是不可变的一旦声明了一个string类型的标识符，无论是常量还是变量，该标识符所指代的数据在整个程序的生命周期内便无法更改。对string进行切片化后，Go编译器会为切片变量重新分配底层存储而不是共用string的底层存储，因此对切片的修改并未对原string的数据产生任何影响。</p>
</li>
<li><p>通过unsafe指针指向string在运行时内部表示结构中的数据存储块的地址，然后通过指针修改那块内存中存储的数据是行不通的。对string的底层的数据存储区仅能进行只读操作，一旦试图修改那块区域的数据，便会得到SIGBUS的运行时错误。</p>
</li>
<li><p>Go string类型支持“零值可用”的理念。Go字符串无须像C语言中那样考虑结尾’\0’字符，因此其零值为””，长度为0。</p>
</li>
<li><p>Go string类型数据是不可变的，因此一旦有了初值，那块数据就不会改变，其长度也不会改变。Go将这个长度作为一个字段存储在运行时的string类型的内部表示结构中。这样获取string长度的操作，即len(s)实际上就是读取存储在运行时中的那个长度值，这是一个代价极低的O(1)操作。</p>
</li>
<li><p>由于Go string是不可变的，因此如果两个字符串的长度不相同，那么无须比较具体字符串数据即可断定两个字符串是不同的。如果长度相同，则要进一步判断数据指针是否指向同一块底层存储数据。如果相同，则两个字符串是等价的；如果不同，则还需进一步比对实际的数据内容。</p>
</li>
<li><p>Go语言源文件默认采用的Unicode字符集。Unicode字符集是目前市面上最流行的字符集，几乎囊括了所有主流非ASCII字符（包括中文字符）。Go字符串的每个字符都是一个Unicode字符，并且这些Unicode字符是以UTF-8编码格式存储在内存当中的。</p>
</li>
<li><p>在UTF-8中，大多数中文字符都使用三字节表示。</p>
</li>
<li><p>Go语言直接提供了通过反引号构造“所见即所得”的多行字符串的方法。</p>
</li>
<li><p>Go string在运行时表示为下面的结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/string.go</span></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在能预估出最终字符串长度的情况下，使用预初始化的strings.Builder连接构建字符串效率最高；strings.Join连接构建字符串的平均性能最稳定，如果输入的多个字符串是以[]string承载的，那么strings.Join也是不错的选择；使用操作符连接的方式最直观、最自然，在编译器知晓欲连接的字符串个数的情况下，使用此种方式可以得到编译器的优化处理；fmt.Sprintf虽然效率不高，但也不是一无是处，如果是由多种不同类型变量来构建特定格式的字符串，那么这种方式还是最适合的。</p>
</li>
<li><p>无论是string转slice还是slice转string，转换都是要付出代价的，这些代价的根源在于string是不可变的，运行时要为转换后的类型分配新内存。</p>
</li>
<li><p>slice类型是不可比较的，而string类型是可比较的，因此在日常Go编码中，我们会经常遇到将slice临时转换为string的情况。Go编译器为这样的场景提供了优化。在运行时中有一个名为slicebytetostringtmp的函数就是协助实现这一优化的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $GOROOT/src/runtime/string.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostringtmp</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> raceenabled &amp;&amp; <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        racereadrangepc(unsafe.Pointer(&amp;b[<span class="number">0</span>]),</span><br><span class="line">            <span class="type">uintptr</span>(<span class="built_in">len</span>(b)),</span><br><span class="line">            getcallerpc(),</span><br><span class="line">            funcPC(slicebytetostringtmp))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> msanenabled &amp;&amp; <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        msanread(unsafe.Pointer(&amp;b[<span class="number">0</span>]), <span class="type">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的“秘诀”就在于不为string新开辟一块内存，而是直接使用slice的底层存储。当然使用这个函数的前提是：在原slice被修改后，这个string不能再被使用了。因此这样的优化是针对以下几个特定场景的。</p>
<ul>
<li>string(b)用在map类型的key中</li>
<li>string(b)用在字符串连接语句中</li>
<li>string(b)用在字符串比较中</li>
</ul>
<p>Go编译器对用在for-range循环中的string到[]byte的转换也有优化处理，它不会为[]byte进行额外的内存分配，而是直接使用string的底层数据。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter3/sources/string_for_range_covert_optimize.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;中国欢迎您，北京欢迎您&quot;</span></span><br><span class="line">    sl := []<span class="type">byte</span>(s)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> sl &#123;</span><br><span class="line">        _ = v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertWithOptimize</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;中国欢迎您，北京欢迎您&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> []<span class="type">byte</span>(s) &#123;</span><br><span class="line">        _ = v</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(testing.AllocsPerRun(<span class="number">1</span>, convert))</span><br><span class="line">    fmt.Println(testing.AllocsPerRun(<span class="number">1</span>, convertWithOptimize))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">go run string_for_range_covert_optimize.go</span></span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>



<h2 id="理解Go语言的包导入"><a href="#理解Go语言的包导入" class="headerlink" title="理解Go语言的包导入"></a>理解Go语言的包导入</h2><ul>
<li><p>Go要求每个源文件在开头处显式地列出所有依赖的包导入，这样Go编译器不必读取和处理整个文件就可以确定其依赖的包列表。</p>
</li>
<li><p>Go要求包之间不能存在循环依赖，这样一个包的依赖关系便形成了一张有向无环图。由于无环，包可以被单独编译，也可以并行编译。</p>
</li>
<li><p>已编译的Go包对应的目标文件（file_name.o或package_name.a）中不仅记录了该包本身的导出符号信息，还记录了其所依赖包的导出符号信息。这样，Go编译器在编译某包P时，针对P依赖的每个包导入（比如导入包Q），只需读取一个目标文件即可（比如：Q包编译成的目标文件中已经包含Q包的依赖包的导出信息），而无须再读取其他文件中的信息。</p>
</li>
<li><p>源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段也不是包名。不过Go语言有一个惯用法，那就是包导入路径的最后一段目录名最好与包名一致。</p>
</li>
<li><p>当包名与包导入路径中的最后一个目录名不同时，最好用下面的语法将包名显式放入包导入语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app2/main.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    mypkg2 <span class="string">&quot;github.com/bigwhite/effective-go-book/chapter3-demo1/pkg/pkg2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mypkg2.Func1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Go编译器在编译过程中必然要使用的是编译单元（一个包）所依赖的包的源码。</p>
</li>
<li><p>Go编译器的包源码搜索路径由基本搜索路径和包导入路径组成，两者结合在一起后，编译器便可确定一个包的所有依赖包的源码路径的集合，这个集合构成了Go编译器的源码搜索路径空间。</p>
</li>
<li><p>同一源码文件的依赖包在同一源码搜索路径空间下的包名冲突问题可以由显式指定包名的方式解决。</p>
</li>
</ul>
<h2 id="理解Go语言表达式的求值顺序"><a href="#理解Go语言表达式的求值顺序" class="headerlink" title="理解Go语言表达式的求值顺序"></a>理解Go语言表达式的求值顺序</h2><ul>
<li><p>包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高。</p>
</li>
<li><p>表达式操作数中的函数、方法及channel操作按普通求值顺序，即从左到右的次序进行求值。</p>
</li>
<li><p>赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按从左到右的顺序对变量进行赋值。</p>
</li>
<li><p>switch-case语句中的表达式求值属于“惰性求值”范畴。惰性求值指的就是需要进行求值时才会对表达值进行求值，这样做的目的是让计算机少做事，从而降低程序的消耗，对性能提升有一定帮助。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter3/sources/evaluation_order_7.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Expr</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> Expr(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> Expr(<span class="number">1</span>), Expr(<span class="number">2</span>), Expr(<span class="number">3</span>):</span><br><span class="line">            fmt.Println(<span class="string">&quot;enter into case1&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">        <span class="keyword">case</span> Expr(<span class="number">4</span>):</span><br><span class="line">            fmt.Println(<span class="string">&quot;enter into case2&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">go run evaluation_order_7.go</span></span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">enter into case1</span><br><span class="line">enter into case2</span><br></pre></td></tr></table></figure></li>
<li><p>我们再来看看select-case语句的求值。Go语言中的select为我们提供了一种在多个channel间实现“多路复用”的机制，是编写Go并发程序最常用的并发原语之一。我们通过一个例子直观看一下select-case语句中表达式的求值规则：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chapter3/sources/evaluation_order_8.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAReadOnlyChannel</span><span class="params">()</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;invoke getAReadOnlyChannel&quot;</span>)</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">        c &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getASlice</span><span class="params">()</span></span> *[<span class="number">5</span>]<span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;invoke getASlice&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getAWriteOnlyChannel</span><span class="params">()</span></span> <span class="keyword">chan</span>&lt;- <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;invoke getAWriteOnlyChannel&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getANumToChannel</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;invoke getANumToChannel&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 从channel接收数据</span></span><br><span class="line">    <span class="keyword">case</span> (getASlice())[<span class="number">0</span>] = &lt;-getAReadOnlyChannel():</span><br><span class="line">       fmt.Println(<span class="string">&quot;recv something from a readonly channel&quot;</span>)</span><br><span class="line">    <span class="comment">// 将数据发送到channel</span></span><br><span class="line">    <span class="keyword">case</span> getAWriteOnlyChannel() &lt;- getANumToChannel():</span><br><span class="line">        fmt.Println(<span class="string">&quot;send something to a writeonly channel&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">go run evaluation_order_8.go</span></span><br><span class="line">invoke getAReadOnlyChannel</span><br><span class="line">invoke getAWriteOnlyChannel</span><br><span class="line">invoke getANumToChannel</span><br><span class="line"></span><br><span class="line">invoke getASlice</span><br><span class="line">recv something from a readonly channel</span><br></pre></td></tr></table></figure>

<p>如果选择要执行的是一个从channel接收数据的case，那么该case等号左边的表达式在接收前才会被求值。比如在上面的例子中，在getAReadOnlyChannel创建的goroutine在3s后向channel中写入一个int值后，select选择了第一个case执行，此时对等号左侧的表达式(getASlice())[0]进行求值，输出“invoke getASlice”，这也算是一种惰性求值。</p>
</li>
</ul>
<h2 id="理解Go语言代码块与作用域"><a href="#理解Go语言代码块与作用域" class="headerlink" title="理解Go语言代码块与作用域"></a>理解Go语言代码块与作用域</h2><ul>
<li>Go语言中的代码块是包裹在一对大括号内部的声明和语句，且代码块支持嵌套。如果一对大括号之间没有任何语句，那么称这个代码块为空代码块。代码块是代码执行流流转的基本单元，代码执行流总是从一个代码块跳到另一个代码块。</li>
<li>Go语言中有两类代码块，一类是我们在代码中直观可见的由一堆大括号包裹的显式代码块，比如函数的函数体、for循环的循环体、if语句的某个分支等另一类则是没有大括号包裹的隐式代码块。</li>
<li>Go规范定义了如下几种隐式代码块。宇宙（Universe）代码块：所有Go源码都在该隐式代码块中，就相当于所有Go代码的最外层都存在一对大括号。包代码块：每个包都有一个包代码块，其中放置着该包的所有Go源码。文件代码块：每个文件都有一个文件代码块，其中包含着该文件中的所有Go源码。每个if、for和switch语句均被视为位于其自己的隐式代码块中。switch或select语句中的每个子句都被视为一个隐式代码块。</li>
<li>Go标识符的作用域是基于代码块定义的，作用域规则描述了标识符在哪些代码块中是有效的。</li>
</ul>
<h2 id="了解Go语言控制语句惯用法及使用注意事项"><a href="#了解Go语言控制语句惯用法及使用注意事项" class="headerlink" title="了解Go语言控制语句惯用法及使用注意事项"></a>了解Go语言控制语句惯用法及使用注意事项</h2><ul>
<li><p>当出现错误时，快速返回。</p>
</li>
<li><p>成功逻辑不要嵌入if-else语句中。</p>
</li>
<li><p>for range的惯用法是使用短变量声明方式（:=）在for的initStmt中声明迭代变量（iteration variable）。但需要注意的是，这些迭代变量在for range的每次循环中都会被重用，而不是重新声明。这是因为根据上一条Go语言代码块和作用域规则中的说明，我们可以将for range进行等价转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可等价转换为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">    i, v := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, v = <span class="keyword">range</span> m &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以清晰地看到迭代变量的重用。</p>
</li>
<li><p>for range语句中，range后面接受的表达式的类型可以是数组、指向数组的指针、切片、字符串、map和channel（至少需具有读权限），但参与循环的是range表达式的副本。</p>
</li>
<li><p>for range对于string来说，每次循环的单位是一个rune，而不是一个byte，返回的第一个值为迭代字符码点的第一字节的位置。</p>
</li>
<li><p>当channel作为range表达式类型时，for range最终以阻塞读的方式阻塞在channel表达式上，即便是带缓冲的channel亦是如此：当channel中无数据时，for range也会阻塞在channel上，直到channel关闭。</p>
</li>
<li><p>Go语言规范中明确规定break语句（不接label的情况下）结束执行并跳出的是同一函数内break语句所在的最内层的for、switch或select的执行。要修正这一问题，可以利用Go语言为for提供的一项高级能力：break [label]。</p>
</li>
<li><p>通过case接表达式列表的方式要比使用fallthrough更加简洁和易读。因此，在程序中使用fallthrough关键字前，先想想能否使用更为简洁、清晰的case表达式列表替代。</p>
</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>声明、类型、语句与控制结构</p><p><a href="https://mrcq.github.io/2022/11/15/读书笔记/Go语言精进之路/声明、类型、语句与控制结构/">https://mrcq.github.io/2022/11/15/读书笔记/Go语言精进之路/声明、类型、语句与控制结构/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Kurisu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-11-15</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-11-16</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Go/">Go, </a><a class="link-muted" rel="tag" href="/tags/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/">Go语言精进之路 </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/11/16/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">双指针算法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E5%AE%B9%E5%BF%8D%E7%BD%AA%E6%81%B6/"><span class="level-item">容忍罪恶</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Kurisu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Kurisu</p><p class="is-size-6 is-block">水滴石穿，聚沙成塔</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">57</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/mrcq" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/mrcq"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#使用一致的变量声明形式"><span class="level-left"><span class="level-item">1</span><span class="level-item">使用一致的变量声明形式</span></span></a></li><li><a class="level is-mobile" href="#使用无类型常量简化代码"><span class="level-left"><span class="level-item">2</span><span class="level-item">使用无类型常量简化代码</span></span></a></li><li><a class="level is-mobile" href="#使用iota实现枚举常量"><span class="level-left"><span class="level-item">3</span><span class="level-item">使用iota实现枚举常量</span></span></a></li><li><a class="level is-mobile" href="#尽量定义零值可用的类型"><span class="level-left"><span class="level-item">4</span><span class="level-item">尽量定义零值可用的类型</span></span></a></li><li><a class="level is-mobile" href="#使用复合字面值作为初值构造器"><span class="level-left"><span class="level-item">5</span><span class="level-item">使用复合字面值作为初值构造器</span></span></a></li><li><a class="level is-mobile" href="#了解切片实现原理并高效使用"><span class="level-left"><span class="level-item">6</span><span class="level-item">了解切片实现原理并高效使用</span></span></a></li><li><a class="level is-mobile" href="#了解map实现原理并高效使用"><span class="level-left"><span class="level-item">7</span><span class="level-item">了解map实现原理并高效使用</span></span></a></li><li><a class="level is-mobile" href="#了解string实现原理并高效使用"><span class="level-left"><span class="level-item">8</span><span class="level-item">了解string实现原理并高效使用</span></span></a></li><li><a class="level is-mobile" href="#理解Go语言的包导入"><span class="level-left"><span class="level-item">9</span><span class="level-item">理解Go语言的包导入</span></span></a></li><li><a class="level is-mobile" href="#理解Go语言表达式的求值顺序"><span class="level-left"><span class="level-item">10</span><span class="level-item">理解Go语言表达式的求值顺序</span></span></a></li><li><a class="level is-mobile" href="#理解Go语言代码块与作用域"><span class="level-left"><span class="level-item">11</span><span class="level-item">理解Go语言代码块与作用域</span></span></a></li><li><a class="level is-mobile" href="#了解Go语言控制语句惯用法及使用注意事项"><span class="level-left"><span class="level-item">12</span><span class="level-item">了解Go语言控制语句惯用法及使用注意事项</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Kurisu&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Kurisu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>