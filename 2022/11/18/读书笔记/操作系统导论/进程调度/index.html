<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>进程调度 - Kurisu&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Kurisu&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Kurisu&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="如何开发调度策略工作负载假设探讨可能的策略范围之前，我们先做一些简化假设。这些假设与系统中运行的进程有关，有时候统称为工作负载（workload）。确定工作负载是构建调度策略的关键部分。工作负载了解得越多，你的策略就越优化。 我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：  每一个工作运行相同的时间。 所有的工作同时到达。 一旦开始，每个工作保持运行直到完成。 所有的工作只是用CP"><meta property="og:type" content="blog"><meta property="og:title" content="进程调度"><meta property="og:url" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><meta property="og:site_name" content="Kurisu&#039;s Blog"><meta property="og:description" content="如何开发调度策略工作负载假设探讨可能的策略范围之前，我们先做一些简化假设。这些假设与系统中运行的进程有关，有时候统称为工作负载（workload）。确定工作负载是构建调度策略的关键部分。工作负载了解得越多，你的策略就越优化。 我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：  每一个工作运行相同的时间。 所有的工作同时到达。 一旦开始，每个工作保持运行直到完成。 所有的工作只是用CP"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225454867.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225707741.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225948623.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118230116392.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118230735402.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118231516587.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118231421696.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118232122011.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118232319463.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118233730259.png"><meta property="og:image" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118233858215.png"><meta property="article:published_time" content="2022-11-18T13:35:49.000Z"><meta property="article:modified_time" content="2022-11-18T15:53:08.991Z"><meta property="article:author" content="Kurisu"><meta property="article:tag" content="操作系统"><meta property="article:tag" content="操作系统导论"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225454867.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"},"headline":"进程调度","image":["https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225454867.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225707741.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225948623.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118230116392.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118230735402.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118231516587.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118231421696.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118232122011.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118232319463.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118233730259.png","https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118233858215.png"],"datePublished":"2022-11-18T13:35:49.000Z","dateModified":"2022-11-18T15:53:08.991Z","author":{"@type":"Person","name":"Kurisu"},"publisher":{"@type":"Organization","name":"Kurisu's Blog","logo":{"@type":"ImageObject","url":"https://mrcq.github.io/img/logo.svg"}},"description":"如何开发调度策略工作负载假设探讨可能的策略范围之前，我们先做一些简化假设。这些假设与系统中运行的进程有关，有时候统称为工作负载（workload）。确定工作负载是构建调度策略的关键部分。工作负载了解得越多，你的策略就越优化。 我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：  每一个工作运行相同的时间。 所有的工作同时到达。 一旦开始，每个工作保持运行直到完成。 所有的工作只是用CP"}</script><link rel="canonical" href="https://mrcq.github.io/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto Serif Simplified Chinese:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ed68212360e83c07d191372605274f6e";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><meta name="msvalidate.01" content="D5E963705D472839D42E0AC1C65D96AB"><script src="https://www.googletagmanager.com/gtag/js?id=G-X1YWL675NS" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-X1YWL675NS');</script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Kurisu&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">时间轴</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>进程调度</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2022-11-18T13:35:49.000Z" title="2022-11-18T13:35:49.000Z">2022-11-18</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="2022-11-18T15:53:08.991Z" title="2022-11-18T15:53:08.991Z">2022-11-18</time></span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span> / </span><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span><span class="level-item">38 分钟读完 (大约5715个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><h2 id="如何开发调度策略"><a href="#如何开发调度策略" class="headerlink" title="如何开发调度策略"></a>如何开发调度策略</h2><h3 id="工作负载假设"><a href="#工作负载假设" class="headerlink" title="工作负载假设"></a>工作负载假设</h3><p>探讨可能的策略范围之前，我们先做一些简化假设。这些假设与系统中运行的进程有关，有时候统称为工作负载（workload）。确定工作负载是构建调度策略的关键部分。工作负载了解得越多，你的策略就越优化。</p>
<p>我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设：</p>
<ol>
<li>每一个工作运行相同的时间。</li>
<li>所有的工作同时到达。</li>
<li>一旦开始，每个工作保持运行直到完成。</li>
<li>所有的工作只是用CPU（即它们不执行IO操作）。</li>
<li>每个工作的运行时间是已知的。<span id="more"></span></li>
</ol>
<h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><p>除了做出工作负载假设之外，还需要一个东西能让我们比较不同的调度策略：调度指标。</p>
<p>现在，让我们简化一下生活，只用一个指标：周转时间（turnaround time）。任务的周转时间定义为任务完成时间减去任务到达系统的时间。更正式的周转时间定义T周转时间是：</p>
<p>T周转时间 = T完成时间 − T到达时间</p>
<h2 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a>先进先出（FIFO）</h2><p>我们可以实现的最基本的算法，被称为先进先出（First In First Out或FIFO）调度，有时候也称为先到先服务（First Come First Served 或FCFS）。</p>
<p>我们一起看一个简单的例子。想象一下，3个工作A、B和C在大致相同的时间（T到达时间 = 0）到达系统。因为FIFO必须将某个工作放在前面，所以我们假设当它们都同时到达时，A比B早一点点，然后B比C早到达一点点。假设每个工作运行10s。这些工作的平均周转时间（average turnaround time）是多少？</p>
<p>从图可以看出，A在10s时完成，B在20s时完成，C在30s时完成。因此，这3个任务的平均周转时间就是（10 + 20 + 30）/ 3 = 20。</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225454867.png"></p>
<p>现在让我们放宽假设。具体来说，让我们放宽假设1，因此<strong>不再认为每个任务的运行时间相同</strong>。如图所示，A先运行100s，B或C才有机会运行。因此，系统的平均周转时间是比较高的：令人不快的110s（（100 + 110 + 120）/ 3 = 110）。</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225707741.png"></p>
<h2 id="最短任务优先（SJF）"><a href="#最短任务优先（SJF）" class="headerlink" title="最短任务优先（SJF）"></a>最短任务优先（SJF）</h2><p>一个非常简单的方法解决了这个问题，这个新的调度准则被称为最短任务优先（Shortest Job First，SJF），该名称应该很容易记住，因为它完全描述了这个策略：先运行最短的任务，然后是次短的任务，如此下去。</p>
<p>我们用上面的例子，但以SJF作为调度策略。图中展示的是运行A、B和C的结果。它清楚地说明了为什么在考虑平均周转时间的情况下，SJF调度策略更好。仅通过在A之前运行B和C，SJF将平均周转时间从110s降低到50s（（10 + 20 + 120）/3= 50）。</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118225948623.png"></p>
<p>现在让我们放宽另一个假设。具体来说，我们可以针对假设2，现在假设工作可以随时到达，而不是同时到达。这导致了什么问题？</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118230116392.png"></p>
<p>从图中可以看出，即使B和C在A之后不久到达，它们仍然被迫等到A完成，从而遭遇同样的护航问题。这3项工作的平均周转时间为103.33s，即（100+（110−10）+（120−10））/3。</p>
<blockquote>
<p>护航效应（convoy effect），一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。</p>
</blockquote>
<h2 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h2><p>为了解决这个问题，需要放宽假设条件（工作必须保持运行直到完成）。SJF是一种非抢占式（non-preemptive）调度程序，因此存在上述问题。幸运的是，有一个调度程序完全就是这样做的：向SJF添加抢占，称为最短完成时间优先（Shortest Time-to-Completion First，STCF）或抢占式最短作业优先（Preemptive Shortest Job First ，PSJF）调度程序。每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118230735402.png"></p>
<p>从图中可以看出平均周转时间大大提高：50s。和以前一样，考虑到我们的新假设，STCF可证明是最优的。考虑到如果所有工作同时到达，SJF是最优的，那么你应该能够看到STCF的最优性是符合直觉的。</p>
<h2 id="新度量指标：响应时间"><a href="#新度量指标：响应时间" class="headerlink" title="新度量指标：响应时间"></a>新度量指标：响应时间</h2><p>因此，如果我们知道任务长度，而且任务只使用CPU，而我们唯一的衡量是周转时间，STCF将是一个很好的策略。事实上，对于许多早期批处理系统，这些类型的调度算法有一定的意义。然而，引入分时系统改变了这一切。现在，用户将会坐在终端前面，同时也要求系统的交互性好。因此，一个新的度量标准诞生了：响应时间（response time）。</p>
<p>响应时间定义为从任务到达系统到首次运行的时间。更正式的定义是：</p>
<p>T响应时间= T首次运行−T到达时间　</p>
<p>STCF和相关方法在响应时间上并不是很好。例如，如果3个工作同时到达，第三个工作必须等待前两个工作全部运行后才能运行。这种方法虽然有很好的周转时间，但对于响应时间和交互性是相当糟糕的。假设你在终端前输入，不得不等待10s才能看到系统的回应，只是因为其他一些工作已经在你之前被调度：你肯定不太开心。因此，我们还有另一个问题：如何构建对响应时间敏感的调度程序？</p>
<h2 id="轮转"><a href="#轮转" class="headerlink" title="轮转"></a>轮转</h2><p>为了解决这个问题，我们将介绍一种新的调度算法，通常被称为轮转（Round-Robin，RR）调度。基本思想很简单：RR在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。因此，RR有时被称为时间切片（time-slicing）。请注意，时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每10ms中断一次，则时间片可以是10ms、20ms或10ms的任何其他倍数。</p>
<p>SJF：</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118231516587.png"></p>
<p>轮转：</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118231421696.png"></p>
<p>RR的平均响应时间是：（0 + 1 + 2）/3 = 1; SJF 算法平均响应时间是：（0 + 5+ 10）/ 3 = 5。</p>
<p>如你所见，时间片长度对于RR是至关重要的。越短，RR在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应。</p>
<blockquote>
<p>请注意，上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在CPU高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本。</p>
</blockquote>
<p>我们开发了两种调度程序。第一种类型（SJF、STCF）优化周转时间，但对响应时间不利。第二种类型（RR）优化响应时间，但对周转时间不利。我们还有两个假设需要放宽：假设4（作业没有I/O）和假设5（每个作业的运行时间是已知的）。接下来我们来解决这些假设。</p>
<h2 id="结合I-O"><a href="#结合I-O" class="headerlink" title="结合I/O"></a>结合I/O</h2><p>调度程序显然要在工作发起I/O请求时做出决定，因为当前正在运行的作业在I/O期间不会使用CPU，它被阻塞等待I/O完成。如果将I/O发送到硬盘驱动器，则进程可能会被阻塞几毫秒或更长时间，具体取决于驱动器当前的I/O负载。因此，这时调度程序应该在CPU上安排另一项工作。</p>
<p>调度程序还必须在I/O完成时做出决定。发生这种情况时，会产生中断，操作系统运行并将发出I/O的进程从阻塞状态移回就绪状态。</p>
<p>假设有两项工作A和B，每项工作需要50ms的CPU时间。但是，有一个明显的区别：A运行10ms，然后发出I/O请求（假设I/O每个都需要10ms），而B只是使用CPU 50ms，不执行I/O。调度程序先运行A，然后运行B。</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118232122011.png"></p>
<p>假设我们正在尝试构建STCF调度程序。显然，仅仅运行一个工作，然后运行另一个工作，而不考虑如何考虑I/O是没有意义的。</p>
<p>一种常见的方法是将A的每个10ms的子工作视为一项独立的工作。因此，当系统启动时，它的选择是调度10ms的A，还是50ms的B。对于STCF，选择是明确的：选择较短的一个，在这种情况下是A。然后，A的工作已完成，只剩下B，并开始运行。然后提交A的一个新子工作，它抢占B并运行10ms。这样做可以实现重叠（overlap），一个进程在等待另一个进程的I/O完成时使用CPU，系统因此得到更好的利用。</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118232319463.png"></p>
<p>这样我们就看到了调度程序可能如何结合I/O。通过将每个CPU突发作为一项工作，调度程序确保“交互”的进程经常运行。当这些交互式作业正在执行I/O时，其他CPU密集型作业将运行，从而更好地利用处理器。</p>
<h2 id="多级反馈队列（MLFQ）"><a href="#多级反馈队列（MLFQ）" class="headerlink" title="多级反馈队列（MLFQ）"></a>多级反馈队列（MLFQ）</h2><p>多级反馈队列（Multi-level Feedback Queue，MLFQ）是一种著名的调度方法。1962年，Corbato首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。</p>
<p>多级反馈队列需要解决两方面的问题。首先，它要<strong>优化周转时间</strong>。这通过先执行短工作来实现。然而，操作系统通常不知道工作要运行多久，而这又是SJF（或STCF）等算法所必需的。其次，MLFQ希望给交互用户（如用户坐在屏幕前，等着进程结束）很好的交互体验，因此需要<strong>降低响应时间</strong>。然而，像轮转这样的算法虽然降低了响应时间，周转时间却很差。</p>
<h3 id="MLFQ：基本规则"><a href="#MLFQ：基本规则" class="headerlink" title="MLFQ：基本规则"></a>MLFQ：基本规则</h3><p>MLFQ中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ总是优先执行较高优先级的工作（即在较高级队列中的工作）。</p>
<p>当然，每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。</p>
<p>至此，我们得到了MLFQ的两条基本规则。</p>
<p>● 规则1：如果A的优先级 &gt; B的优先级，运行A（不运行B）。</p>
<p>● 规则2：如果A的优先级 = B的优先级，轮转运行A和B。</p>
<p>如果要在某个特定时刻展示队列，最高优先级有两个工作（A和B），工作C位于中等优先级，而D的优先级最低。按刚才介绍的基本规则，由于A和B有最高优先级，调度程序将交替的调度他们，可怜的C和D永远都没有机会运行，太气人了！</p>
<h3 id="尝试1：如何改变优先级"><a href="#尝试1：如何改变优先级" class="headerlink" title="尝试1：如何改变优先级"></a>尝试1：如何改变优先级</h3><p>我们必须决定，在一个工作的生命周期中，MLFQ如何改变其优先级（在哪个队列中）。要做到这一点，我们必须记得工作负载：既有运行时间很短、频繁放弃CPU的交互型工作，也有需要很多CPU时间、响应时间却不重要的长时间计算密集型工作。下面是我们第一次尝试优先级调整算法。</p>
<p> ●规则3：工作进入系统时，放在最高优先级（最上层队列）。</p>
<p>● 规则4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。</p>
<p>● 规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变。</p>
<p>看一个较复杂的例子，看看MLFQ如何近似SJF。在这个例子中，有两个工作：A是一个长时间运行的CPU密集型工作，B是一个运行时间很短的交互型工作。假设A执行一段时间后B到达。会发生什么呢？对B来说，MLFQ会近似于SJF吗？</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118233730259.png"></p>
<p>通过这个例子，你大概可以体会到这个算法的一个主要目标：如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF。</p>
<p>假设交互型工作中有大量的I/O操作（比如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃CPU。在这种情况下，我们不想处罚它，只是保持它的优先级不变。</p>
<p><img src="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20221118233858215.png"></p>
<h3 id="当前MLFQ的一些问题"><a href="#当前MLFQ的一些问题" class="headerlink" title="当前MLFQ的一些问题"></a>当前MLFQ的一些问题</h3><p>首先，会有饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用CPU，导致长工作永远无法得到CPU（它们饿死了）。即使在这种情况下，我们希望这些长工作也能有所进展。</p>
<p>其次，聪明的用户会重写程序，愚弄调度程序（game the scheduler）。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个I/O操作（比如访问一个无关的文件），从而主动释放CPU。如此便可以保持在高优先级，占用更多的CPU时间。做得好时（比如，每运行99%的时间片时间就主动放弃一次CPU），工作可以几乎独占CPU。</p>
<p>最后，一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间表现为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。</p>
<h3 id="尝试2：提升优先级"><a href="#尝试2：提升优先级" class="headerlink" title="尝试2：提升优先级"></a>尝试2：提升优先级</h3><p>一个简单的思路是周期性地提升（boost）所有工作的优先级。可以有很多方法做到，但我们就用最简单的：将所有工作扔到最高优先级队列。于是有了如下的新规则。</p>
<p>● 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。</p>
<p>新规则一下解决了两个问题。首先，进程不会饿死——在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享CPU，从而最终获得执行。其次，如果一个CPU密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。</p>
<p>当然，添加时间段S导致了明显的问题：S的值应该如何设置？德高望重的系统研究员 John Ousterhout[O11]曾将这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果S设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的CPU时间比例。</p>
<h3 id="尝试3：更好的计时方式"><a href="#尝试3：更好的计时方式" class="headerlink" title="尝试3：更好的计时方式"></a>尝试3：更好的计时方式</h3><p>现在还有一个问题要解决：如何阻止调度程序被愚弄？可以看出，这里的元凶是规则4a和4b，导致工作在时间片以内释放CPU，就保留它的优先级。那么应该怎么做？</p>
<p>这里的解决方案，是为MLFQ的每层队列提供更完善的CPU计时方式（accounting）。调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆成很多次用完。因此，我们重写规则4a和4b。</p>
<p>● 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。</p>
<h3 id="MLFQ调优及其他问题"><a href="#MLFQ调优及其他问题" class="headerlink" title="MLFQ调优及其他问题"></a>MLFQ调优及其他问题</h3><p>关于MLFQ调度算法还有一些问题。其中一个大问题是如何配置一个调度程序，例如，配置多少队列？每一层队列的时间片配置多大？为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。</p>
<p>例如，大多数的MLFQ变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如10ms或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是CPU密集型工作，配置更长的时间片会取得更好的效果。</p>
<p>最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的建议（advice），比如通过命令行工具nice，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看man手册。</p>
<h2 id="比例份额"><a href="#比例份额" class="headerlink" title="比例份额"></a>比例份额</h2><p>比例份额（proportional-share）调度程序，有时也称为公平份额（fair-share）调度程序。比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。</p>
<p>比例份额由于一些原因，并没有作为CPU调度程序被广泛使用。一个原因是这两种方式都不能很好地适合I/O；另一个原因是其中最难的票数分配问题并没有确定的解决方式，例如，如何知道浏览器进程应该拥有多少票数？通用调度程序（像前面讨论的MLFQ及其他类似的Linux调度程序）做得更好，因此得到了广泛的应用。比例份额调度程序只有在这些问题可以相对容易解决的领域更有用（例如容易确定份额比例）。例如在虚拟（virtualized）数据中心中，你可能会希望分配1/4的CPU周期给Windows虚拟机，剩余的给Linux系统，比例分配的方式可以更简单高效。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>进程调度</p><p><a href="https://mrcq.github.io/2022/11/18/读书笔记/操作系统导论/进程调度/">https://mrcq.github.io/2022/11/18/读书笔记/操作系统导论/进程调度/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Kurisu</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-11-18</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-11-18</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统, </a><a class="link-muted" rel="tag" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/">操作系统导论 </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/02/01/%E5%B7%A5%E5%85%B7/tcpdump/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">tcpdump笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E5%87%BA%E5%94%AE%E6%9C%AA%E6%9D%A5/"><span class="level-item">出售未来</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Kurisu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Kurisu</p><p class="is-size-6 is-block">水滴石穿，聚沙成塔</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">29</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/mrcq" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/mrcq"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#如何开发调度策略"><span class="level-left"><span class="level-item">1</span><span class="level-item">如何开发调度策略</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#工作负载假设"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">工作负载假设</span></span></a></li><li><a class="level is-mobile" href="#调度指标"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">调度指标</span></span></a></li></ul></li><li><a class="level is-mobile" href="#先进先出（FIFO）"><span class="level-left"><span class="level-item">2</span><span class="level-item">先进先出（FIFO）</span></span></a></li><li><a class="level is-mobile" href="#最短任务优先（SJF）"><span class="level-left"><span class="level-item">3</span><span class="level-item">最短任务优先（SJF）</span></span></a></li><li><a class="level is-mobile" href="#最短完成时间优先（STCF）"><span class="level-left"><span class="level-item">4</span><span class="level-item">最短完成时间优先（STCF）</span></span></a></li><li><a class="level is-mobile" href="#新度量指标：响应时间"><span class="level-left"><span class="level-item">5</span><span class="level-item">新度量指标：响应时间</span></span></a></li><li><a class="level is-mobile" href="#轮转"><span class="level-left"><span class="level-item">6</span><span class="level-item">轮转</span></span></a></li><li><a class="level is-mobile" href="#结合I-O"><span class="level-left"><span class="level-item">7</span><span class="level-item">结合I/O</span></span></a></li><li><a class="level is-mobile" href="#多级反馈队列（MLFQ）"><span class="level-left"><span class="level-item">8</span><span class="level-item">多级反馈队列（MLFQ）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MLFQ：基本规则"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">MLFQ：基本规则</span></span></a></li><li><a class="level is-mobile" href="#尝试1：如何改变优先级"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">尝试1：如何改变优先级</span></span></a></li><li><a class="level is-mobile" href="#当前MLFQ的一些问题"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">当前MLFQ的一些问题</span></span></a></li><li><a class="level is-mobile" href="#尝试2：提升优先级"><span class="level-left"><span class="level-item">8.4</span><span class="level-item">尝试2：提升优先级</span></span></a></li><li><a class="level is-mobile" href="#尝试3：更好的计时方式"><span class="level-left"><span class="level-item">8.5</span><span class="level-item">尝试3：更好的计时方式</span></span></a></li><li><a class="level is-mobile" href="#MLFQ调优及其他问题"><span class="level-left"><span class="level-item">8.6</span><span class="level-item">MLFQ调优及其他问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#比例份额"><span class="level-left"><span class="level-item">9</span><span class="level-item">比例份额</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Kurisu&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Kurisu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>