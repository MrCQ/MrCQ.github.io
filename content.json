{"posts":[{"title":"待办清单","text":"Go 测试 整理Go学习笔记 map底层实现 strings构造函数 练手项目中标准库的使用 算法 完善滑动窗口 完善双指针算法","link":"/2022/11/17/%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"},{"title":"PHP速成","text":"这份教程所使用的版本是 PHP 5+. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614&lt;?php // PHP必须被包围于 &lt;?php ? &gt; 之中// 如果你的文件中只有php代码，那么最好省略结束括号标记// 这是单行注释的标志# 井号也可以，但是//更常见/* 这是多行注释*/// 使用 &quot;echo&quot; 或者 &quot;print&quot; 来输出信息到标准输出print('Hello '); // 输出 &quot;Hello &quot; 并且没有换行符// () 对于echo和print是可选的echo &quot;World\\n&quot;; // 输出 &quot;World&quot; 并且换行// (每个语句必须以分号结尾)// 在 &lt;?php 标签之外的语句都被自动输出到标准输出?&gt;Hello World Again!&lt;?php/************************************ * 类型与变量 */// 变量以$开始// 变量可以以字母或者下划线开头，后面可以跟着数字、字母和下划线// 布尔值是大小写无关的$boolean = true; // 或 TRUE 或 True$boolean = false; // 或 FALSE 或 False// 整型$int1 = 12; // =&gt; 12$int2 = -12; // =&gt; -12$int3 = 012; // =&gt; 10 (0开头代表八进制数)$int4 = 0x0F; // =&gt; 15 (0x开头代表十六进制数)// 浮点型 (即双精度浮点型)$float = 1.234;$float = 1.2e3;$float = 7E-10;// 算数运算$sum = 1 + 1; // 2$difference = 2 - 1; // 1$product = 2 * 2; // 4$quotient = 2 / 1; // 2// 算数运算的简写$number = 0;$number += 1; // $number 自增1echo $number++; // 输出1 (运算后自增)echo ++$number; // 输出3 (自增后运算)$number /= $float; // 先除后赋值给 $number// 字符串需要被包含在单引号之中$sgl_quotes = '$String'; // =&gt; '$String'// 如果需要在字符串中引用变量，就需要使用双引号$dbl_quotes = &quot;This is a $sgl_quotes.&quot;; // =&gt; 'This is a $String.'// 特殊字符只有在双引号中有用$escaped = &quot;This contains a \\t tab character.&quot;;$unescaped = 'This just contains a slash and a t: \\t';// 可以把变量包含在一对大括号中$money = &quot;I have $${number} in the bank.&quot;;// 自 PHP 5.3 开始, nowdocs 可以被用作多行非计算型字符串$nowdoc = &lt;&lt;&lt;'END'Multi linestringEND;// 而Heredocs则可以用作多行计算型字符串$heredoc = &lt;&lt;&lt;ENDMulti line$sgl_quotesEND;// 字符串需要用 . 来连接echo 'This string ' . 'is concatenated';/******************************** * 数组 */// PHP 中的数组都是关联型数组，也就是某些语言中的哈希表或字典// 在所有PHP版本中均适用：$associative = array('One' =&gt; 1, 'Two' =&gt; 2, 'Three' =&gt; 3);// PHP 5.4 中引入了新的语法$associative = ['One' =&gt; 1, 'Two' =&gt; 2, 'Three' =&gt; 3];echo $associative['One']; // 输出 1// 声明为列表实际上是给每个值都分配了一个整数键（key）$array = ['One', 'Two', 'Three'];echo $array[0]; // =&gt; &quot;One&quot;/******************************** * 输出 */echo('Hello World!');// 输出到标准输出// 此时标准输出就是浏览器中的网页print('Hello World!'); // 和echo相同// echo和print实际上也属于这个语言本身，所以我们省略括号echo 'Hello World!';print 'Hello World!'; $paragraph = 'paragraph';echo 100; // 直接输出标量echo $paragraph; // 或者输出变量// 如果你配置了短标签，或者使用5.4.0及以上的版本// 你就可以使用简写的echo语法?&gt;&lt;p&gt;&lt;?= $paragraph ?&gt;&lt;/p&gt;&lt;?php$x = 1;$y = 2;$x = $y; // $x 现在和 $y 的值相同$z = &amp;$y;// $z 现在持有 $y 的引用. 现在更改 $z 的值也会更改 $y 的值，反之亦然// 但是改变 $y 的值不会改变 $x 的值echo $x; // =&gt; 2echo $z; // =&gt; 2$y = 0;echo $x; // =&gt; 2echo $z; // =&gt; 0/******************************** * 逻辑 */$a = 0;$b = '0';$c = '1';$d = '1';// 如果assert的参数为假，就会抛出警告// 下面的比较都为真，不管它们的类型是否匹配assert($a == $b); // 相等assert($c != $a); // 不等assert($c &lt;&gt; $a); // 另一种不等的表示assert($a &lt; $c);assert($c &gt; $b);assert($a &lt;= $b);assert($c &gt;= $d);// 下面的比较只有在类型相同、值相同的情况下才为真assert($c === $d);assert($a !== $d);assert(1 === '1');assert(1 !== '1');// 变量可以根据其使用来进行类型转换$integer = 1;echo $integer + $integer; // =&gt; 2$string = '1';echo $string + $string; // =&gt; 2 (字符串在此时被转化为整数)$string = 'one';echo $string + $string; // =&gt; 0// 输出0，因为'one'这个字符串无法被转换为整数// 类型转换可以将一个类型视作另一种类型$boolean = (boolean) 1; // =&gt; true$zero = 0;$boolean = (boolean) $zero; // =&gt; false// 还有一些专用的函数来进行类型转换$integer = 5;$string = strval($integer);$var = null; // 空值/******************************** * 控制结构 */if (true) { print 'I get printed';}if (false) { print 'I don\\'t';} else { print 'I get printed';}if (false) { print 'Does not get printed';} elseif(true) { print 'Does';}// 三目运算符print (false ? 'Does not get printed' : 'Does');$x = 0;if ($x === '0') { print 'Does not print';} elseif($x == '1') { print 'Does not print';} else { print 'Does print';}// 下面的语法常用于模板中:?&gt;&lt;?php if ($x): ?&gt;This is displayed if the test is truthy.&lt;?php else: ?&gt;This is displayed otherwise.&lt;?php endif; ?&gt;&lt;?php// 用switch来实现相同的逻辑switch ($x) { case '0': print 'Switch does type coercion'; break; // 在case中必须使用一个break语句， // 否则在执行完这个语句后会直接执行后面的语句 case 'two': case 'three': // 如果$variable是 'two' 或 'three'，执行这里的语句 break; default: // 其他情况}// While, do...while 和 for 循环$i = 0;while ($i &lt; 5) { echo $i++;}; // 输出 &quot;01234&quot;echo &quot;\\n&quot;;$i = 0;do { echo $i++;} while ($i &lt; 5); // 输出 &quot;01234&quot;echo &quot;\\n&quot;;for ($x = 0; $x &lt; 10; $x++) { echo $x;} // 输出 &quot;0123456789&quot;echo &quot;\\n&quot;;$wheels = ['bicycle' =&gt; 2, 'car' =&gt; 4];// Foreach 循环可以遍历数组foreach ($wheels as $wheel_count) { echo $wheel_count;} // 输出 &quot;24&quot;echo &quot;\\n&quot;;// 也可以同时遍历键和值foreach ($wheels as $vehicle =&gt; $wheel_count) { echo &quot;A $vehicle has $wheel_count wheels&quot;;}echo &quot;\\n&quot;;$i = 0;while ($i &lt; 5) { if ($i === 3) { break; // 退出循环 } echo $i++;} // 输出 &quot;012&quot;for ($i = 0; $i &lt; 5; $i++) { if ($i === 3) { continue; // 跳过此次遍历 } echo $i;} // 输出 &quot;0124&quot;/******************************** * 函数 */// 通过&quot;function&quot;定义函数:function my_function () { return 'Hello';}echo my_function(); // =&gt; &quot;Hello&quot;// 函数名需要以字母或者下划线开头, // 后面可以跟着任意的字母、下划线、数字.function add ($x, $y = 1) { // $y 是可选参数，默认值为 1 $result = $x + $y; return $result;}echo add(4); // =&gt; 5echo add(4, 2); // =&gt; 6// $result 在函数外部不可访问// print $result; // 抛出警告// 从 PHP 5.3 起我们可以定义匿名函数$inc = function ($x) { return $x + 1;};echo $inc(2); // =&gt; 3function foo ($x, $y, $z) { echo &quot;$x - $y - $z&quot;;}// 函数也可以返回一个函数function bar ($x, $y) { // 用 'use' 将外部的参数引入到里面 return function ($z) use ($x, $y) { foo($x, $y, $z); };}$bar = bar('A', 'B');$bar('C'); // 输出 &quot;A - B - C&quot;// 你也可以通过字符串调用函数$function_name = 'add';echo $function_name(1, 2); // =&gt; 3// 在通过程序来决定调用哪个函数时很有用// 或者，使用 call_user_func(callable $callback [, $parameter [, ... ]]);/******************************** * 导入 */&lt;?php// 被导入的php文件也必须以php开标签开始include 'my-file.php';// 现在my-file.php就在当前作用域中可见了// 如果这个文件无法被导入（比如文件不存在），会抛出警告include_once 'my-file.php';// my-file.php中的代码在其他地方被导入了，那么就不会被再次导入// 这会避免类的多重定义错误require 'my-file.php';require_once 'my-file.php';// 和include功能相同，只不过如果不能被导入时，会抛出错误// my-include.php的内容:&lt;?phpreturn 'Anything you like.';// 文件结束// Include和Require函数也有返回值$value = include 'my-include.php';// 被引入的文件是根据文件路径或者include_path配置来查找到的// 如果文件最终没有被找到，那么就会查找当前文件夹。之后才会报错/* *//******************************** * 类 */// 类是由class关键字定义的class MyClass{ const MY_CONST = 'value'; // 常量 static $staticVar = 'static'; // 属性必须声明其作用域 public $property = 'public'; public $instanceProp; protected $prot = 'protected'; // 当前类和子类可访问 private $priv = 'private'; // 仅当前类可访问 // 通过 __construct 来定义构造函数 public function __construct($instanceProp) { // 通过 $this 访问当前对象 $this-&gt;instanceProp = $instanceProp; } // 方法就是类中定义的函数 public function myMethod() { print 'MyClass'; } final function youCannotOverrideMe() { } public static function myStaticMethod() { print 'I am static'; }}echo MyClass::MY_CONST; // 输出 'value';echo MyClass::$staticVar; // 输出 'static';MyClass::myStaticMethod(); // 输出 'I am static';// 通过new来新建实例$my_class = new MyClass('An instance property');// 如果不传递参数，那么括号可以省略// 用 -&gt; 来访问成员echo $my_class-&gt;property; // =&gt; &quot;public&quot;echo $my_class-&gt;instanceProp; // =&gt; &quot;An instance property&quot;$my_class-&gt;myMethod(); // =&gt; &quot;MyClass&quot;// 使用extends来生成子类class MyOtherClass extends MyClass{ function printProtectedProperty() { echo $this-&gt;prot; } // 方法覆盖 function myMethod() { parent::myMethod(); print ' &gt; MyOtherClass'; }}$my_other_class = new MyOtherClass('Instance prop');$my_other_class-&gt;printProtectedProperty(); // =&gt; 输出 &quot;protected&quot;$my_other_class-&gt;myMethod(); // 输出 &quot;MyClass &gt; MyOtherClass&quot;final class YouCannotExtendMe{}// 你可以使用“魔法方法”来生成getter和setter方法class MyMapClass{ private $property; public function __get($key) { return $this-&gt;$key; } public function __set($key, $value) { $this-&gt;$key = $value; }}$x = new MyMapClass();echo $x-&gt;property; // 会使用 __get() 方法$x-&gt;property = 'Something'; // 会使用 __set() 方法// 类可以是被定义成抽象类 (使用 abstract 关键字) 或者// 去实现接口 (使用 implements 关键字).// 接口需要通过interface关键字来定义interface InterfaceOne{ public function doSomething();}interface InterfaceTwo{ public function doSomethingElse();}// 接口可以被扩展interface InterfaceThree extends InterfaceTwo{ public function doAnotherContract();}abstract class MyAbstractClass implements InterfaceOne{ public $x = 'doSomething';}class MyConcreteClass extends MyAbstractClass implements InterfaceTwo{ public function doSomething() { echo $x; } public function doSomethingElse() { echo 'doSomethingElse'; }}// 一个类可以实现多个接口class SomeOtherClass implements InterfaceOne, InterfaceTwo{ public function doSomething() { echo 'doSomething'; } public function doSomethingElse() { echo 'doSomethingElse'; }}/******************************** * 特征 */// 特征 从 PHP 5.4.0 开始包括，需要用 &quot;trait&quot; 这个关键字声明trait MyTrait{ public function myTraitMethod() { print 'I have MyTrait'; }}class MyTraitfulClass{ use MyTrait;}$cls = new MyTraitfulClass();$cls-&gt;myTraitMethod(); // 输出 &quot;I have MyTrait&quot;/******************************** * 命名空间 */// 这部分是独立于这个文件的// 因为命名空间必须在一个文件的开始处。&lt;?php// 类会被默认的放在全局命名空间中，可以被一个\\来显式调用$cls = new \\MyClass();// 为一个文件设置一个命名空间namespace My\\Namespace;class MyClass{}// (或者从其他文件中)$cls = new My\\Namespace\\MyClass;//或者从其他命名空间中namespace My\\Other\\Namespace;use My\\Namespace\\MyClass;$cls = new MyClass();// 你也可以为命名空间起一个别名namespace My\\Other\\Namespace;use My\\Namespace as SomeOtherNamespace;$cls = new SomeOtherNamespace\\MyClass();*/","link":"/2022/10/20/PHP/PHP%E9%80%9F%E6%88%90/"},{"title":"GO面试题","text":"基础简单介绍一下Golang？1谷歌开发的一种系统编程语言。它具有内置的垃圾收集机制并支持并发。代码可以编译成单个可执行二进制文件，不需要添加库或运行时环境即可在服务器上执行。 go格式化输出%v、%+v、%#v 的区别？123451、%v 只输出所有的值2、%+v 先输出字段属性，再输出该字段的值3、%#v 先输出结构体名字值，再输出结构体（字段属性+字段的值） Go语言局部变量分配在栈还是堆？1Go语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析，当发现变量的作用域没有跑出函数范围，就可以在栈上，反之则必须分配在堆。 参考: go语言局部变量分配在栈还是堆 如果函数内同时声明defer跟panic，会怎么执行？123一个函数内defer的执行顺序与其声明顺序相反出现panic语句时，会先执行defer后执行panic出现panic语句时，声明在panic后面的任何代码不再执行 123456789101112package mainimport( &quot;fmt&quot;)func main(){ defer func(){fmt.Println(&quot;打印前&quot;)}() defer func(){fmt.Println(&quot;打印中&quot;)}() defer func(){fmt.Println(&quot;打印后&quot;)}() panic(&quot;结束&quot;)} 12345$ go run main.go 打印后打印中打印前panic: 结束 Go语言中怎么捕获错误而不中断程序的执行？1panic + defer + recover() 12345678910111213141516171819202122package mainimport( &quot;fmt&quot; &quot;time&quot;)func main(){ go func(){ defer CatchErr() panic(&quot;test&quot;) }() time.Sleep(time.Second) fmt.Println(&quot;主线程正常退出&quot;)}func CatchErr(){ if err := recover();err !=nil{ fmt.Println(err) }} 123$ go run main.go test主线程正常退出 for range 循环的时候 是 创建每个元素的副本，还是使用元素的引用？123for range 循环的时候会创建每个元素的副本，而不是元素的引用所以 m[key] = &amp;val 取的都是变量 val 的地址所以最后 map 中的所有元素的值都是变量 val 的地址，因为最后 val 被赋值为3，所有输出都是3 123456789101112131415161718package mainimport( &quot;fmt&quot;)func main(){ slice := []int{0,1,2,3} m := make(map[int]*int) for key,val := range slice { m[key] = &amp;val } for k,v := range m { fmt.Println(k,&quot;-&gt;&quot;,*v) } } 12345$ go run main.go 0 -&gt; 31 -&gt; 32 -&gt; 33 -&gt; 3 下面这段代码有什么缺陷123func funcMui(x, y int) (sum int, error) { return x + y, nil} 123在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值必须加上括号()；如果只有一个返回值且命名也必须加上括号()。这里的第一个返回值有命名 sum，第二个没有命名，所以错误。 new() 与 make() 的区别？1234567func main(){ s1 := new([]int) s2 := make([]int, 0) fmt.Println(s1) fmt.Println(s2)} 123$ go run main.go &amp;[][] 1new(T) 是为一个 T 类型的新值分配空间, 并将此空间初始化为 T 的零值, 并返回这块内存空间的地址, 也就是 T 类型的指针 T, 该指针指向 T 类型值占用的那块内存. make(T) 返回的是初始化之后的 T, 且只能用于 slice, map, channel 三种类型. make(T, args) 返回初始化之后 T 类型的值, 且此新值并不是 T 类型的零值, 也不是 T 类型的指针 T, 而是 T 类型值经过初始化之后的引用. 参考1: Go中make和new的区别 参考2: Go中make()和new()的区别 下面这段代码能否通过编译，不能的话原因是什么；如果能，输出什么？12345func main() { list := new([]int) list = append(list, 1) fmt.Println(list)} 12345678// 不能通过编译，new([]int) 之后的 list 是一个 *[]int 类型的指针，// 不能对指针执行 append 操作。// 可以改写为:func main() { list := new([]int) *list = append(*list, 1) fmt.Println(*list)} 123456func main() { s1 := []int{1, 2, 3} s2 := []int{4, 5} s1 = append(s1, s2) fmt.Println(s1)} 12不能通过编译。append() 的第二个参数不能直接使用 slice，需使用 … 操作符，将一个切片追加到另一个切片上：append(s1,s2…)。或者直接跟上元素，形如：append(s1,1,2,3)。 12345678var( size := 1024 max_size = size*2)func main() { fmt.Println(size,max_size)} 12不能通过编译。变量声明的简短模式，形如：x := 100。有限制：只能在函数内部使用简短模式 结构体能比较吗？如果能的话需要什么条件？1在 Go 语言中，Go 结构体有时候并不能直接比较，当其基本类型包含：slice、map、function 时，是不能比较的。若强行比较，就会导致出现例子中的直接报错的情况。 参考：Go 面试题：Go 结构体（struct）是否可以比较？ select是随机的还是顺序的?1select会随机选择一个可用通道做收发操作 Sliceslice 扩容机制1234567891011121314151617GO1.17版本及之前当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；当原 slice 容量 &lt; 1024 的时候，新 slice 容量变成原来的 2 倍；当原 slice 容量 &gt; 1024，进入一个循环，每次容量变成原来的1.25倍,直到大于期望容量。 GO1.18之后当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；当原 slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的 2 倍；当原 slice 容量 &gt; threshold，进入一个循环，每次容量增加（旧容量+3*threshold）/4。 slice的深浅拷贝12345深浅拷贝都是进行复制，区别在于复制出来的新对象与原来的对象在它们发生改变时，是否会相互影响，本质区别就是复制出来的对象与原对象是否会指向同一个地址。在Go语言，切片拷贝有三种方式：使用=操作符拷贝切片，这种就是浅拷贝使用[:]下标的方式复制切片，这种也是浅拷贝使用Go语言的内置函数copy()进行切片拷贝，这种就是深拷贝 初始化容量为2的切片append 3个元素后打印，切片内容、len、cap 分别是什么？12345func main() { s := make([]int, 2) s = append(s, 1, 2, 3) fmt.Printf(&quot;slice:%v len:%v cap:%v&quot;, s, len(s), cap(s))} 12$ go run main.go slice:[0 0 1 2 3] len:5 cap:6","link":"/2022/11/03/Go/GO%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"Go语言速成","text":"发明Go语言是出于更好地完成工作的需要。Go不是计算机科学的最新发展潮流，但它却提供了解决现实问题的最新最快的方法。 Go拥有命令式语言的静态类型，编译很快，执行也很快，同时加入了对于目前多核CPU的并发计算支持，也有相应的特性来实现大规模编程。 Go语言有非常棒的标准库，还有一个充满热情的社区。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371// 单行注释/* 多行 注释 */// 导入包的子句在每个源文件的开头。// Main比较特殊，它用来声明可执行文件，而不是一个库。package main// Import语句声明了当前文件引用的包。import ( &quot;fmt&quot; // Go语言标准库中的包 &quot;io/ioutil&quot; // 包含一些输入输出函数 m &quot;math&quot; // 数学标准库，在此文件中别名为m &quot;net/http&quot; // 一个web服务器包 &quot;os&quot; // 系统底层函数，如文件读写 &quot;strconv&quot; // 字符串转换)// 函数声明：main是程序执行的入口。// 不管你喜欢还是不喜欢，反正Go就用了花括号来包住函数体。func main() { // 往标准输出打印一行。 // 用包名fmt限制打印函数。 fmt.Println(&quot;你好世界&quot;) // 调用当前包的另一个函数。 beyondHello()}// 函数可以在括号里加参数。// 如果没有参数的话，也需要一个空括号。func beyondHello() { var x int // 变量声明，变量必须在使用之前声明。 x = 3 // 变量赋值。 // 可以用:=来偷懒，它自动把变量类型、声明和赋值都搞定了。 y := 4 sum, prod := learnMultiple(x, y) // 返回多个变量的函数 fmt.Println(&quot;sum:&quot;, sum, &quot;prod:&quot;, prod) // 简单输出 learnTypes() // 少于y分钟，学的更多！}/* &lt;- 快看快看我是跨行注释_(:з」∠)_Go语言的函数可以有多个参数和 *多个* 返回值。在这个函数中， `x`、`y` 是参数，`sum`、`prod` 是返回值的标识符（可以理解为名字）且类型为int*/func learnMultiple(x, y int) (sum, prod int) { return x + y, x * y // 返回两个值}// 内置变量类型和关键词func learnTypes() { // 短声明给你所想。 str := &quot;少说话多读书!&quot; // String类型 s2 := `这是一个可以换行的字符串` // 同样是String类型 // 非ascii字符。Go使用UTF-8编码。 g := 'Σ' // rune类型，int32的别名，使用UTF-8编码 f := 3.14195 // float64类型，IEEE-754 64位浮点数 c := 3 + 4i // complex128类型，内部使用两个float64表示 // var变量可以直接初始化。 var u uint = 7 // unsigned 无符号变量，但是实现依赖int型变量的长度 var pi float32 = 22. / 7 // 字符转换 n := byte('\\n') // byte是uint8的别名 // 数组（Array）类型的大小在编译时即确定 var a4 [4] int // 有4个int变量的数组，初始为0 a3 := [...]int{3, 1, 5} // 有3个int变量的数组，同时进行了初始化 // Array和slice各有所长，但是slice可以动态的增删，所以更多时候还是使用slice。 s3 := []int{4, 5, 9} // 回去看看 a3 ，是不是这里没有省略号？ s4 := make([]int, 4) // 分配4个int大小的内存并初始化为0 var d2 [][]float64 // 这里只是声明，并未分配内存空间 bs := []byte(&quot;a slice&quot;) // 进行类型转换 // 切片（Slice）的大小是动态的，它的长度可以按需增长 // 用内置函数 append() 向切片末尾添加元素 // 要增添到的目标是 append 函数第一个参数， // 多数时候数组在原内存处顺次增长，如 s := []int{1, 2, 3} // 这是个长度3的slice s = append(s, 4, 5, 6) // 再加仨元素，长度变为6了 fmt.Println(s) // 更新后的数组是 [1 2 3 4 5 6] // 除了向append()提供一组原子元素（写死在代码里的）以外，我们 // 还可以用如下方法传递一个slice常量或变量，并在后面加上省略号， // 用以表示我们将引用一个slice、解包其中的元素并将其添加到s数组末尾。 s = append(s, []int{7, 8, 9}...) // 第二个参数是一个slice常量 fmt.Println(s) // 更新后的数组是 [1 2 3 4 5 6 7 8 9] p, q := learnMemory() // 声明p,q为int型变量的指针 fmt.Println(*p, *q) // * 取值 // Map是动态可增长关联数组，和其他语言中的hash或者字典相似。 m := map[string]int{&quot;three&quot;: 3, &quot;four&quot;: 4} m[&quot;one&quot;] = 1 // 在Go语言中未使用的变量在编译的时候会报错，而不是warning。 // 下划线 _ 可以使你“使用”一个变量，但是丢弃它的值。 _, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs // 通常的用法是，在调用拥有多个返回值的函数时， // 用下划线抛弃其中的一个参数。下面的例子就是一个脏套路， // 调用os.Create并用下划线变量扔掉它的错误代码。 // 因为我们觉得这个文件一定会成功创建。 file, _ := os.Create(&quot;output.txt&quot;) fmt.Fprint(file, &quot;这句代码还示范了如何写入文件呢&quot;) file.Close() // 输出变量 fmt.Println(s, c, a4, s3, d2, m) learnFlowControl() // 回到流程控制}// 和其他编程语言不同的是，go支持有名称的变量返回值。// 声明返回值时带上一个名字允许我们在函数内的不同位置// 只用写return一个词就能将函数内指定名称的变量返回func learnNamedReturns(x, y int) (z int) { z = x * y return // 隐式返回z，因为前面指定了它。}// Go全面支持垃圾回收。Go有指针，但是不支持指针运算。// 你会因为空指针而犯错，但是不会因为增加指针而犯错。func learnMemory() (p, q *int) { // 返回int型变量指针p和q p = new(int) // 内置函数new分配内存 // 自动将分配的int赋值0，p不再是空的了。 s := make([]int, 20) // 给20个int变量分配一块内存 s[3] = 7 // 赋值 r := -2 // 声明另一个局部变量 return &amp;s[3], &amp;r // &amp; 取地址}func expensiveComputation() int { return 1e6}func learnFlowControl() { // if需要花括号，括号就免了 if true { fmt.Println(&quot;这句话肯定被执行&quot;) } // 用go fmt 命令可以帮你格式化代码，所以不用怕被人吐槽代码风格了， // 也不用容忍别人的代码风格。 if false { // pout } else { // gloat } // 如果太多嵌套的if语句，推荐使用switch x := 1 switch x { case 0: case 1: // 隐式调用break语句，匹配上一个即停止 case 2: // 不会运行 } // 和if一样，for也不用括号 for x := 0; x &lt; 3; x++ { // ++ 自增 fmt.Println(&quot;遍历&quot;, x) } // x在这里还是1。为什么？ // for 是go里唯一的循环关键字，不过它有很多变种 for { // 死循环 break // 骗你的 continue // 不会运行的 } // 用range可以枚举 array、slice、string、map、channel等不同类型 // 对于channel，range返回一个值， // array、slice、string、map等其他类型返回一对儿 for key, value := range map[string]int{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3} { // 打印map中的每一个键值对 fmt.Printf(&quot;索引：%s, 值为：%d\\n&quot;, key, value) } // 如果你只想要值，那就用前面讲的下划线扔掉没用的 for _, name := range []string{&quot;Bob&quot;, &quot;Bill&quot;, &quot;Joe&quot;} { fmt.Printf(&quot;你是。。 %s\\n&quot;, name) } // 和for一样，if中的:=先给y赋值，然后再和x作比较。 if y := expensiveComputation(); y &gt; x { x = y } // 闭包函数 xBig := func() bool { return x &gt; 100 // x是上面声明的变量引用 } fmt.Println(&quot;xBig:&quot;, xBig()) // true （上面把y赋给x了） x /= 1e5 // x变成10 fmt.Println(&quot;xBig:&quot;, xBig()) // 现在是false // 除此之外，函数体可以在其他函数中定义并调用， // 满足下列条件时，也可以作为参数传递给其他函数： // a) 定义的函数被立即调用 // b) 函数返回值符合调用者对类型的要求 fmt.Println(&quot;两数相加乘二: &quot;, func(a, b int) int { return (a + b) * 2 }(10, 2)) // Called with args 10 and 2 // =&gt; Add + double two numbers: 24 // 当你需要goto的时候，你会爱死它的！ goto lovelove: learnFunctionFactory() // 返回函数的函数多棒啊 learnDefer() // 对defer关键字的简单介绍 learnInterfaces() // 好东西来了！}func learnFunctionFactory() { // 空行分割的两个写法是相同的，不过第二个写法比较实用 fmt.Println(sentenceFactory(&quot;原谅&quot;)(&quot;当然选择&quot;, &quot;她！&quot;)) d := sentenceFactory(&quot;原谅&quot;) fmt.Println(d(&quot;当然选择&quot;, &quot;她！&quot;)) fmt.Println(d(&quot;你怎么可以&quot;, &quot;她？&quot;))}// Decorator在一些语言中很常见，在go语言中，// 接受参数作为其定义的一部分的函数是修饰符的替代品func sentenceFactory(mystring string) func(before, after string) string { return func(before, after string) string { return fmt.Sprintf(&quot;%s %s %s&quot;, before, mystring, after) // new string }}func learnDefer() (ok bool) { // defer表达式在函数返回的前一刻执行 defer fmt.Println(&quot;defer表达式执行顺序为后进先出（LIFO）&quot;) defer fmt.Println(&quot;\\n这句话比上句话先输出，因为&quot;) // 关于defer的用法，例如用defer关闭一个文件， // 就可以让关闭操作与打开操作的代码更近一些 return true}// 定义Stringer为一个接口类型，有一个方法Stringtype Stringer interface { String() string}// 定义pair为一个结构体，有x和y两个int型变量。type pair struct { x, y int}// 定义pair类型的方法，实现Stringer接口。func (p pair) String() string { // p被叫做“接收器” // Sprintf是fmt包中的另一个公有函数。 // 用 . 调用p中的元素。 return fmt.Sprintf(&quot;(%d, %d)&quot;, p.x, p.y)}func learnInterfaces() { // 花括号用来定义结构体变量，:=在这里将一个结构体变量赋值给p。 p := pair{3, 4} fmt.Println(p.String()) // 调用pair类型p的String方法 var i Stringer // 声明i为Stringer接口类型 i = p // 有效！因为p实现了Stringer接口（类似java中的塑型） // 调用i的String方法，输出和上面一样 fmt.Println(i.String()) // fmt包中的Println函数向对象要它们的string输出，实现了String方法就可以这样使用了。 // （类似java中的序列化） fmt.Println(p) // 输出和上面一样，自动调用String函数。 fmt.Println(i) // 输出和上面一样。 learnVariadicParams(&quot;great&quot;, &quot;learning&quot;, &quot;here!&quot;)}// 有变长参数列表的函数func learnVariadicParams(myStrings ...interface{}) { // 枚举变长参数列表的每个参数值 // 下划线在这里用来抛弃枚举时返回的数组索引值 for _, param := range myStrings { fmt.Println(&quot;param:&quot;, param) } // 将可变参数列表作为其他函数的参数列表 fmt.Println(&quot;params:&quot;, fmt.Sprintln(myStrings...)) learnErrorHandling()}func learnErrorHandling() { // &quot;, ok&quot;用来判断有没有正常工作 m := map[int]string{3: &quot;three&quot;, 4: &quot;four&quot;} if x, ok := m[1]; !ok { // ok 为false，因为m中没有1 fmt.Println(&quot;别找了真没有&quot;) } else { fmt.Print(x) // 如果x在map中的话，x就是那个值喽。 } // 错误可不只是ok，它还可以给出关于问题的更多细节。 if _, err := strconv.Atoi(&quot;non-int&quot;); err != nil { // _ discards value // 输出&quot;strconv.ParseInt: parsing &quot;non-int&quot;: invalid syntax&quot; fmt.Println(err) } // 待会再说接口吧。同时， learnConcurrency()}// c是channel类型，一个并发安全的通信对象。func inc(i int, c chan int) { c &lt;- i + 1 // &lt;-把右边的发送到左边的channel。}// 我们将用inc函数来并发地增加一些数字。func learnConcurrency() { // 用make来声明一个slice，make会分配和初始化slice，map和channel。 c := make(chan int) // 用go关键字开始三个并发的goroutine，如果机器支持的话，还可能是并行执行。 // 三个都被发送到同一个channel。 go inc(0, c) // go is a statement that starts a new goroutine. go inc(10, c) go inc(-805, c) // 从channel中读取结果并打印。 // 打印出什么东西是不可预知的。 fmt.Println(&lt;-c, &lt;-c, &lt;-c) // channel在右边的时候，&lt;-是读操作。 cs := make(chan string) // 操作string的channel cc := make(chan chan string) // 操作channel的channel go func() { c &lt;- 84 }() // 开始一个goroutine来发送一个新的数字 go func() { cs &lt;- &quot;wordy&quot; }() // 发送给cs // Select类似于switch，但是每个case包括一个channel操作。 // 它随机选择一个准备好通讯的case。 select { case i := &lt;-c: // 从channel接收的值可以赋给其他变量 fmt.Println(&quot;这是……&quot;, i) case &lt;-cs: // 或者直接丢弃 fmt.Println(&quot;这是个字符串！&quot;) case &lt;-cc: // 空的，还没作好通讯的准备 fmt.Println(&quot;别瞎想&quot;) } // 上面c或者cs的值被取到，其中一个goroutine结束，另外一个一直阻塞。 learnWebProgramming() // Go很适合web编程，我知道你也想学！}// http包中的一个简单的函数就可以开启web服务器。func learnWebProgramming() { // ListenAndServe第一个参数指定了监听端口，第二个参数是一个接口，特定是http.Handler。 go func() { err := http.ListenAndServe(&quot;:8080&quot;, pair{}) fmt.Println(err) // 不要无视错误。 }() requestServer()}// 使pair实现http.Handler接口的ServeHTTP方法。func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) { // 使用http.ResponseWriter返回数据 w.Write([]byte(&quot;Y分钟golang速成!&quot;))}func requestServer() { resp, err := http.Get(&quot;http://localhost:8080&quot;) fmt.Println(err) defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) fmt.Printf(&quot;\\n服务器消息： `%s`&quot;, string(body))}","link":"/2022/10/19/Go/Go%E8%AF%AD%E8%A8%80%E9%80%9F%E6%88%90/"},{"title":"String库函数","text":"判断是不是以某个字符串开头1234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.HasPrefix(str, &quot;http://&quot;) res1 := strings.HasPrefix(str, &quot;hello&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is falseres1 is true 判断是不是以某个字符串结尾1234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.HasSuffix(str, &quot;http://&quot;) res1 := strings.HasSuffix(str, &quot;world&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is falseres1 is true 判断str在s中首次出现的位置，如果没有返回-11234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.Index(str, &quot;o&quot;) res1 := strings.Index(str, &quot;i&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出: res0 is 4res1 is -1 判断str在s中最后一次出现的位置，如果没有返回-11234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world&quot; res0 := strings.LastIndex(str, &quot;o&quot;) res1 := strings.LastIndex(str, &quot;i&quot;) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is 7res1 is -1 字符串替换123456789101112131415package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world world&quot; res0 := strings.Replace(str, &quot;world&quot;, &quot;golang&quot;, 2) res1 := strings.Replace(str, &quot;world&quot;, &quot;golang&quot;, 1) //trings.Replace(&quot;原字符串&quot;, &quot;被替换的内容&quot;, &quot;替换的内容&quot;, 替换次数) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1)} 输出： res0 is hello golang golangres1 is hello golang world 求str含s的次数1234567891011121314package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world world&quot; countTime0 := strings.Count(str, &quot;o&quot;) countTime1 := strings.Count(str, &quot;i&quot;) fmt.Printf(&quot;countTime0 is %v\\n&quot;, countTime0) fmt.Printf(&quot;countTime1 is %v\\n&quot;, countTime1)} 输出： countTime0 is 3countTime1 is 0 重复 n 次 str1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world &quot; res0 := strings.Repeat(str, 0) res1 := strings.Repeat(str, 1) res2 := strings.Repeat(str, 2) // strings.Repeat(&quot;原字符串&quot;, 重复次数) fmt.Printf(&quot;res0 is %v\\n&quot;, res0) fmt.Printf(&quot;res1 is %v\\n&quot;, res1) fmt.Printf(&quot;res2 is %v\\n&quot;, res2)} 输出： res0 isres1 is hello worldres2 is hello world hello world str 转为大写12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world &quot; res := strings.ToUpper(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is HELLO WORLD str 转为小写12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;HELLO WORLD &quot; res := strings.ToLower(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is hello world 去掉 str 首尾的空格12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot; hello world &quot; res := strings.TrimSpace(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出:res is hello world 去掉字符串首尾指定的字符12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hi , hello world , hi&quot; res := strings.Trim(str, &quot;hi&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is , hello world , 去掉字符串首指定的字符12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hi , hello world , hi&quot; res := strings.TrimLeft(str, &quot;hi&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is , hello world , hi 去掉字符串尾指定的字符12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hi , hello world , hi&quot; res := strings.TrimRight(str, &quot;hi&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is hi , hello world , 返回str空格分隔的所有子串的slice12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world ，hello golang&quot; res := strings.Fields(str) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is [hello world ，hello golang] 返回str 指定字符分隔的所有子串的slice12345678910111213package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := &quot;hello world ，hello golang&quot; res := strings.Split(str, &quot;o&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res)} 输出： res is [hell w rld ，hell g lang] 用指定字符将 string 类型的 slice 中所有元素链接成一个字符串12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;strings&quot;)func main() { str := []string{&quot;hello&quot;, &quot;world&quot;, &quot;hello&quot;, &quot;golang&quot;} res := strings.Join(str, &quot;++&quot;) fmt.Printf(&quot;res is %v\\n&quot;, res) /* num := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0} res1 := strings.Join(num, &quot;++&quot;) // cannot use num (type []int) as type []string in argument to strings.Join fmt.Println(res1) */} 输出： res is hello++world++hello++golang","link":"/2022/10/28/Go/String%E5%BA%93%E5%87%BD%E6%95%B0/"},{"title":"defer","text":"什么是deferdefer是Go语言提供的一种用于注册延迟调用的机制：让函数或语句可以在当前函数执行完毕后（包括通过return正常结束或者panic导致的异常结束）执行。 defer语句通常用于一些成对操作的场景：打开连接/关闭连接；加锁/释放锁；打开文件/关闭文件等。 defer在一些需要回收资源的场景非常有用，可以很方便地在函数结束前做一些清理操作。在打开资源语句的下一行，直接一句defer就可以在函数返回前关闭资源，可谓相当优雅。 12f, _ := os.Open(&quot;defer.txt&quot;)defer f.Close() 注意：以上代码，忽略了err, 实际上应该先判断是否出错，如果出错了，直接return. 接着再判断f是否为空，如果f为空，就不能调用f.Close()函数了，会直接panic的。 为什么需要defer程序员在编程的时候，经常需要打开一些资源，比如数据库连接、文件、锁等，这些资源需要在用完之后释放掉，否则会造成内存泄漏。 但是程序员都是人，是人就会犯错。因此经常有程序员忘记关闭这些资源。Golang直接在语言层面提供defer关键字，在打开资源语句的下一行，就可以直接用defer语句来注册函数结束后执行关闭资源的操作。因为这样一颗“小小”的语法糖，程序员忘写关闭资源语句的情况就大大地减少了。 怎样合理使用deferdefer的使用其实非常简单： 12345678f,err := os.Open(filename)if err != nil { panic(err)}if f != nil { defer f.Close()} 在打开文件的语句附近，用defer语句关闭文件。这样，在函数结束之前，会自动执行defer后面的语句来关闭文件。 当然，defer会有小小地延迟，对时间要求特别特别特别高的程序，可以避免使用它，其他一般忽略它带来的延迟。 defer的执行顺序多个defer出现的时候，它是一个“栈”的关系，也就是先进后出。一个函数中，写在前面的defer会比写在后面的defer调用的晚。哪怕函数或某个延迟调用发生错误，这些调用依旧会被执行。 1234567891011func test(x int) { defer println(&quot;a&quot;) defer println(&quot;b&quot;) defer func() { println(100 / x) // div0 异常未被捕获，逐步往外传递，最终终⽌止进程。 }() defer println(&quot;c&quot;)}func main() { test(0)} 输出： c b a panic: runtime error: integer divide by zero defer与return执行的先后顺序 多个defer的执行顺序为“后进先出” defer、return、返回值三者的执行逻辑应该是：return最先执行，return负责将结果写入返回值中；接着defer开始执行一些收尾工作；最后函数携带当前返回值退出。 如果函数的返回值是无名的（不带命名返回值），则go语言会在执行return的时候会执行一个类似创建一个临时变量作为保存return值的动作，而有名返回值的函数，由于返回值在函数定义的时候已经将该变量进行定义，在执行return的时候会先执行返回值保存操作，而后续的defer函数会改变这个返回值(虽然defer是在return之后执行的，但是由于使用的函数定义的变量，所以执行defer操作后对该变量的修改会影响到return的值 不带命名返回值的函数： 1234567891011121314151617181920package main import &quot;fmt&quot; func main() { fmt.Println(&quot;return:&quot;, test())// defer 和 return之间的顺序是先返回值, i=0，后defer} func test() int {//这里返回值没有命名 var i int defer func() { i++ fmt.Println(&quot;defer1&quot;, i) //作为闭包引用的话，则会在defer函数执行时根据整个上下文确定当前的值。i=2 }() defer func() { i++ fmt.Println(&quot;defer2&quot;, i) //作为闭包引用的话，则会在defer函数执行时根据整个上下文确定当前的值。i=1 }() return i} test() 先返回 i=0 defer2先于defer1执行 输出结果为: defer2 1 defer1 2 return: 0 带命名返回值的函数： 12345678910111213141516171819package main import &quot;fmt&quot; func main() { fmt.Println(&quot;return:&quot;, test())} func test() (i int) { //返回值命名i defer func() { i++ fmt.Println(&quot;defer1&quot;, i) }() defer func() { i++ fmt.Println(&quot;defer2&quot;, i) }() return i} 输出结果为: defer2 1 defer1 2 return: 2 理解return 返回值的运行机制:为了弄清上述两种情况的区别，我们首先要理解return 返回值的运行机制:return 并非原子操作，分为赋值，和返回值两步操作。eg1 : 实际上return 执行了两步操作，因为返回值没有命名，所以return 默认指定了一个返回值（假设为s），首先将i赋值给s,后续的操作因为是针对i,进行的，所以不会影响s, 此后因为s不会更新，所以return s 不会改变相当于：var i ints := ireturn seg2 : 同上，s 就相当于 命名的变量i, 因为所有的操作都是基于命名变量i(s),返回值也是i, 所以每一次defer操作，都会更新返回值i defer函数中带返回值defer后面的函数里面只要有return语句，则只有这个return的语句才会在原函数结束时执行。 12345678910111213141516171819202122package mainimport ( &quot;log&quot; &quot;time&quot;)func main(){ bigSlowOperation()}func bigSlowOperation() { defer trace(&quot;bigSlowOperation&quot;)() // don't forget the extra parentheses // ...lots of work... time.Sleep(10 * time.Second) // simulate slow operation by sleeping}func trace(msg string) func() { log.Printf(&quot;enter %s&quot;, msg) start := time.Now() return func() { log.Printf(&quot;exit %s (%s)&quot;, msg, time.Since(start)) }} 输出： 2022/10/29 17:55:00 enter bigSlowOperation2022/10/29 17:55:10 exit bigSlowOperation (10.0108435s)","link":"/2022/10/29/Go/defer/"},{"title":"三个点用法","text":"函数可变数量参数可变参数是函数最右边的参数，普通参数放在左侧。 12345678910111213141516package mainimport &quot;fmt&quot;func main() { //multiParam 可以接受可变数量的参数 multiParam(&quot;jerry&quot;, 1) multiParam(&quot;php&quot;, 1, 2)}func multiParam(name string, args ...int) { fmt.Println(name) //参数放在args切片中 for _, e := range args { fmt.Println(e) }} 展开slice 通过append合并两个slice。 1234stooges := []string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;}lang := []string{&quot;php&quot;, &quot;golang&quot;, &quot;java&quot;}stooges = append(stooges, lang...)fmt.Println(stooges) 作为可变参数时，实际上是将slice打散展开。 数组元素数量如果忽略数组[]中的数字不设置大小，…指定的长度等于数组中元素的数量，Go语言会根据元素的个数设置数组的大小。 1234stooges := [...]string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;} //等价于stooges := [3]string{&quot;Moe&quot;, &quot;Larry&quot;, &quot;Curly&quot;}arr := [...]int{1, 2, 3}fmt.Println(len(stooges))fmt.Println(len(arr)) go命令go描述软件包列表时，命令使用三个点作为通配符。 此命令测试当前目录及其子目录中的所有软件包。 1go test ./...","link":"/2022/10/29/Go/%E4%B8%89%E4%B8%AA%E7%82%B9%E7%94%A8%E6%B3%95/"},{"title":"函数","text":"函数定义 不支持 嵌套 (nested)、重载 (overload) 和 默认参数 (default parameter)。 无需声明原型。 支持不定长变参。 支持多返回值。 支持命名返回参数。 支持匿名函数和闭包。 使用关键字 func 定义函数，左大括号依旧不能另起一行。 1234func test(x, y int, s string) (int, string) { // 类型相同的相邻参数可合并。 n := x + y // 多返回值必须用括号。 return n, fmt.Sprintf(s, n)} 函数是第一类对象，可作为参数传递。建议将复杂签名定义为函数类型，以便于阅读。 12345678910111213141516func test(fn func() int) int { return fn()}type FormatFunc func(s string, x, y int) string // 定义函数类型。func format(fn FormatFunc, s string, x, y int) string { return fn(s, x, y)}func main() { s1 := test(func() int { return 100 }) // 直接将匿名函数当参数。 s2 := format(func(s string, x, y int) string { return fmt.Sprintf(s, x, y) }, &quot;%d, %d&quot;, 10, 20) println(s1) println(s2)} 输出： 100 10, 20 有返回值的函数，必须有明确的终止语句，否则会引发编译错误。 在函数中定义的返回值变量，会自动赋为 zero-value 。也就是说变量会自动进行初始化 int 类型初始化为 0，string 初始化为 &quot;&quot; , 结构体则根据其组成部分初始化。 如果函数中已定义返回值，return会将结果写入返回值中，并返回返回值。 1234567891011121314151617func Test() (v int) { println(`v_address:`, &amp;v) v = 1 vv := 5 defer func() { println(`defer v_address:`, &amp;v) v++ fmt.Println(`defer v:`, v) fmt.Println(`defer vv:`, vv) }() println(`vv_address:`, &amp;vv) return vv}func main() { fmt.Println(`TestDefer:`, Test())} 输出： v_address: 0xc000119e78vv_address: 0xc000119e70defer v_address: 0xc000119e78defer v: 6defer vv: 5TestDefer: 6 变参 变参本质上就是 slice。只能有一个，且必须是最后一个。 12345678910func test(s string, n ...int) string { var x int for _, i := range n { x += i } return fmt.Sprintf(s, x)}func main() { println(test(&quot;sum: %d&quot;, 1, 2, 3))} 使用 slice 对象做变参时，必须展开。 1234func main() { s := []int{1, 2, 3} println(test(&quot;sum: %d&quot;, s...))} 返回值 不能用容器对象接收多返回值。只能用多个变量，或 “_” 忽略。 123456789func test() (int, int) { return 1, 2}func main() { // s := make([]int, 2) // s = test() // Error: multiple-value test() in single-value context x, _ := test() println(x)} 多返回值可直接作为其他函数调用实参。 1234567891011121314151617func test() (int, int) { return 1, 2}func add(x, y int) int { return x + y}func sum(n ...int) int { var x int for _, i := range n { x += i } return x}func main() { println(add(test())) println(sum(test()))} 命名返回参数可看做与形参类似的局部变量，最后由 return 隐式返回。 1234567func add(x, y int) (z int) { z = x + y return}func main() { println(add(1, 2))} 命名返回参数可被同名局部变量遮蔽，此时需要显式返回。 12345678910111213func add(x, y int) (z int) { println(&amp;z) { // 不能在一个级别，引发 &quot;z redeclared in this block&quot; 错误。 var z = x + y // return // Error: result parameter z not in scope at return println(&amp;z) return z // 必须显式返回。 }}func main() { println(add(1, 1))} 输出： 0xc000059f300xc000059f282 命名返回参数允许 defer 延迟调用通过闭包读取和修改。更多defer相关 12345678910func add(x, y int) (z int) { defer func() { z += 100 }() z = x + y return}func main() { println(add(1, 2)) // 输出: 103} 显式 return 返回前，会先修改命名返回参数。 12345678910func add(x, y int) (z int) { defer func() { println(z) // 输出: 203 }() z = x + y return z + 200 // 执行顺序: (z = z + 200) -&gt; (call defer) -&gt; (ret)}func main() { println(add(1, 2)) // 输出: 203}","link":"/2022/10/29/Go/%E5%87%BD%E6%95%B0/"},{"title":"匿名函数和闭包","text":"匿名函数 未指定函数名的函数被称为匿名函数。 赋值给函数变量1234567func main() { sumFun := func(num1, num2 int) int { return num1 + num2 } sum := sumFun(10, 20) fmt.Println(sum)} 输出： 30 1234567func main() { fns := [](func(x int) int){ func(x int) int { return x + 1 }, func(x int) int { return x + 2 }, } println(fns[1](100))} 输出： 102 匿名结构体123456789func main() { d := struct { fn func() string }{ fn: func() string { return &quot;Hello, World!&quot; }, } println(d.fn())} 直接执行12345func main() { func(name string) { fmt.Println(&quot;Hello&quot;, name) }(&quot;TOMOCAT&quot;)} 输出： Hello TOMOCAT 作为函数参数可以定义一个接收匿名函数参数的函数，实现回调的效果。 1234567891011121314151617181920212223242526/* 求和并调用callback函数对结果进行特殊处理*/func sumWorker(data []int, callback func(int)) { sum := 0 for _, num := range data { sum += num } callback(sum)}func main() { // 打印出求和结果 sumWorker([]int{1, 2, 3, 4}, func(a int) { fmt.Println(&quot;sum:&quot;, a) }) // 判断求和结果是否大于100 sumWorker([]int{1, 2, 3, 4}, func(a int) { if a &gt; 100 { fmt.Println(&quot;sum &gt; 100&quot;) } else { fmt.Println(&quot;sum &lt;= 100&quot;) } })} 输出： sum: 10sum &lt;= 100 多个匿名函数 123456789101112131415func main() { f1,f2:=F(1,2) fmt.Println(f1(4)) fmt.Println(f2())}func F(x, y int)(func(int)int,func()int) { f1 := func(z int) int { return (x + y) * z / 2 } f2 := func() int { return 2 * (x + y) } return f1,f2} 输出： 66 闭包闭包是由函数及其相关引用环境组成的实体，可以理解为一个函数“捕获”了和它处于同一作用域的其他变量。说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕。 Golang中所有的匿名函数都是闭包。 理解“捕获”的概念“捕获”的本质就是引用传递而非值传递。 1234567891011func main() { i := 0 // 闭包: i是引用传递 defer func() { fmt.Println(&quot;defer closure i:&quot;, i) }() // 非闭包: i是值传递 defer fmt.Println(&quot;defer i:&quot;, i) // 修改i的值 i = 100} 输出： defer i: 0defer closure i: 100 匿名函数与自由变量组成闭包下面这个例子中实现了Go中常见的闭包场景，我们通过Adder()返回一个匿名函数，这个匿名函数和自由变量x组成闭包，只要匿名函数的实例closure没有消亡，那么x都是引用传递。 123456789101112131415161718192021222324252627/* 返回匿名函数的函数 1) x是自由变量 2) 匿名函数和x自由变量共同组成闭包*/func Adder(x int) func(int) int { return func(y int) int { x += y fmt.Printf(&quot;x addr %p, x value %d\\n&quot;, &amp;x, x) return x }}func main() { fmt.Println(&quot;----------------Adder()返回的匿名函数实例1----------------&quot;) closure := Adder(1) closure(100) closure(1000) closure(10000) fmt.Println(&quot;----------------Adder()返回的匿名函数实例2----------------&quot;) closure2 := Adder(10) closure2(1) closure2(1) closure2(1) closure2(1)} 输出： —————-Adder()返回的匿名函数实例1—————-x addr 0xc000018088, x value 101x addr 0xc000018088, x value 1101x addr 0xc000018088, x value 11101—————-Adder()返回的匿名函数实例2—————-x addr 0xc0000180c0, x value 11x addr 0xc0000180c0, x value 12x addr 0xc0000180c0, x value 13x addr 0xc0000180c0, x value 14 闭包中使用值传递由于闭包的存在，Golang中使用匿名函数的时候要特别注意区分清楚引用传递和值传递。根据实际需要，我们在不需要引用传递的地方通过匿名函数参数赋值的方式实现值传递。 1234567891011121314151617func main() { fmt.Println(&quot;----------------引用传递----------------&quot;) for i := 0; i &lt; 10; i++ { go func() { fmt.Println(i) }() } time.Sleep(10 * time.Millisecond) fmt.Println(&quot;----------------值传递----------------&quot;) for i := 0; i &lt; 10; i++ { go func(x int) { fmt.Println(x) }(i) } time.Sleep(10 * time.Millisecond) return} 输出： —————-引用传递—————-35910101010101010 —————-值传递—————-0143285697 总结 匿名函数及其“捕获”的自由变量被称为闭包 被闭包捕获的变量称为“自由变量”，在匿名函数实例未消亡时共享同个内存地址 同一个匿名函数可以构造多个实例，每个实例内的自由变量地址不同 匿名函数内部的局部变量在每次执行匿名函数时地址都是变换的 通过匿名函数参数赋值的方式可以实现值传递","link":"/2022/10/29/Go/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"},{"title":"垃圾回收","text":"什么是 GC，有什么作用？GC，全称 Garbage Collection，即垃圾回收，是一种自动内存管理的机制。 当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请时候复用，或者将其归还给操作系统，这种针对内存级别资源的自动回收过程，即为垃圾回收。而负责垃圾回收的程序组件，即为垃圾回收器。 Golang GC发展过程 Go V1.3之前的标记-清除(mark and sweep)算法 Go V1.3之前的标记-清扫(mark and sweep)的缺点 Go V1.5的三色并发标记法 Go V1.5的三色标记为什么需要STW Go V1.5的三色标记为什么需要屏障机制(“强-弱” 三色不变式、插入屏障、删除屏障 ) Go V1.8混合写屏障机制 Go V1.8混合写屏障机制的全场景分析 参考：https://www.jianshu.com/p/4c5a303af470 参考：https://juejin.cn/post/7040737998014513183","link":"/2022/11/07/Go/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"},{"title":"数据","text":"Array 数组是值类型，赋值和传参会复制整个数组，而不是指针。 数组长度必须是常量，且是类型的组成部分。[2]int 和 [3]int 是不同类型。 支持 “==”、”!=” 操作符，因为内存总是被初始化过的。 指针数组 [n]*T，数组指针 *[n]T。因为数组指针是一个指针，所以在定义时，先写 *， 表示定义一个指针，后面接数据类型 可用复合语句初始化。 12345678910a := [3]int{1, 2} // 未初始化元素值为 0。b := [...]int{1, 2, 3, 4} // 通过初始化值确定数组长度。c := [5]int{2: 100, 4: 200} // 使用索引号初始化元素。d := [...]struct { name string age uint8}{ {&quot;user1&quot;, 10}, // 可省略元素类型。 {&quot;user2&quot;, 20}, // 别忘了最后一行的逗号。} 支持多维数组。 12a := [2][3]int{{1, 2, 3}, {4, 5, 6}}b := [...][2]int{{1, 1}, {2, 2}, {3, 3}} // 第 2 纬度不能用 &quot;...&quot;。 值拷贝行为会造成性能问题，通常会建议使用 slice，或数组指针。 12345678910func test(x [2]int) { fmt.Printf(&quot;x: %p\\n&quot;, &amp;x) x[1] = 1000}func main() { a := [2]int{} fmt.Printf(&quot;a: %p\\n&quot;, &amp;a) test(a) fmt.Println(a)} 输出： a: 0xc0000a6070x: 0xc0000a60a0[0 0] 内置函数 len 和 cap 都返回数组长度 (元素数量)。 12a := [2]int{}println(len(a), cap(a)) // 2, 2 Slice 需要说明，slice 并不是数组或数组指针。它通过内部指针和相关属性引用数组片段，以实现变长方案。 12345type slice struct { array unsafe.Pointer len int cap int} 引用类型。但自身是结构体，值拷贝传递。 array 是切片所指向的底层数组数据 属性 len 表示可用元素数量，读写操作不能超过该限制。 属性 cap 表示最大扩张容量，不能超出数组限制。 如果 slice == nil，那么 len、cap 结果都等于 0。 12 data := [...]int{0, 1, 2, 3, 4, 5, 6}slice := data[1:4:5] // [low : high : max] 创建表达式使用的是元素索引号，而非数量。 如果 max 要求获取的容量大于旧数据容量. 那会 panic 读写操作实际目标是底层数组，只需注意索引号的差别。 123456data := [...]int{0, 1, 2, 3, 4, 5}s := data[2:4]s[0] += 100s[1] += 200fmt.Println(s)fmt.Println(data) 输出： [102 203][0 1 102 203 4 5] 可直接创建 slice 对象，自动分配底层数组。 123456s1 := []int{0, 1, 2, 3, 8: 100} // 通过初始化表达式构造，可使用索引号。fmt.Println(s1, len(s1), cap(s1))s2 := make([]int, 6, 8) // 使用 make 创建，指定 len 和 cap 值。fmt.Println(s2, len(s2), cap(s2))s3 := make([]int, 6) // 省略 cap，相当于 cap = len。fmt.Println(s3, len(s3), cap(s3)) 输出： [0 1 2 3 0 0 0 0 100] 9 9[0 0 0 0 0 0] 6 8[0 0 0 0 0 0] 6 6 使用 make 动态创建 slice，避免了数组必须用常量做长度的麻烦。还可用指针直接访问底层数组，退化成普通数组操作。 1234s := []int{0, 1, 2, 3}p := &amp;s[2] // *int, 获取底层数组元素指针。*p += 100fmt.Println(s) 输出： [0 1 102 3] 至于 [][]T，是指元素类型为 []T 。 12345data := [][]int{ []int{1, 2, 3}, []int{100, 200}, []int{11, 22, 33, 44},} 可直接修改 struct array/slice 成员。 12345678d := [5]struct { x int}{}s := d[:]d[1].x = 10s[2].x = 20fmt.Println(d)fmt.Printf(&quot;%p, %p\\n&quot;, &amp;d, &amp;d[0]) 输出： [{0} {10} {20} {0} {0}]0x20819c180, 0x20819c180 reslice 所谓 reslice，是基于已有 slice 创建新 slice 对象，以便在 cap 允许范围内调整属性。 1234s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s1 := s[2:5] // [2 3 4]s2 := s1[2:6:7] // [4 5 6 7]s3 := s2[3:6] // Error 新对象依旧指向原底层数组。 123456s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s1 := s[2:5] // [2 3 4]s1[2] = 100s2 := s1[2:6] // [100 5 6 7]s2[3] = 200fmt.Println(s) 输出： [0 1 2 3 100 5 6 200 8 9] append 向 slice 尾部添加数据，返回新的 slice 对象。 12345s := make([]int, 0, 5)fmt.Printf(&quot;%p\\n&quot;, &amp;s)s2 := append(s, 1) // 值拷贝 fmt.Printf(&quot;%p\\n&quot;, &amp;s2)fmt.Println(s, s2) 输出： 0x2102300000x210230040[] [1] 简单点说，就是在 array[slice.high] 写数据。 123456data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s := data[:3]s2 := append(s, 100, 200) // 添加多个值。fmt.Println(data)fmt.Println(s)fmt.Println(s2) 输出： [0 1 2 100 200 5 6 7 8 9][0 1 2][0 1 2 100 200] 一旦超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。 12345data := [...]int{0, 1, 2, 3, 4, 10: 0}s := data[:2:3]s = append(s, 100, 200) // 一次 append 两个值，超出 s.cap 限制。fmt.Println(s, data) // 重新分配底层数组，与原数组⽆无关。fmt.Println(&amp;s[0], &amp;data[0]) // 比对底层数组起始指针。 输出： [0 1 100 200] [0 1 2 3 4 0 0 0 0 0 0]0x20819c180 0x20817c0c0 从输出结果可以看出，append 后的 s 重新分配了底层数组，并复制数据。如果只追加一个值，则不会超过 s.cap 限制，也就不会重新分配。 通常以 2 倍容量重新分配底层数组。在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够⻓长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。 123456789s := make([]int, 0, 1)c := cap(s)for i := 0; i &lt; 50; i++ { s = append(s, i) if n := cap(s); n &gt; c { fmt.Printf(&quot;cap: %d -&gt; %d\\n&quot;, c, n) c = n }} 输出： cap: 1 -&gt; 2 cap: 2 -&gt; 4 cap: 4 -&gt; 8 cap: 8 -&gt; 16 cap: 16 -&gt; 32 cap: 32 -&gt; 64 copy 它只能用于切片，不能用于 map 等任何其他类型 它返回结果为一个 int 型值，表示 copy 的长度 切片 dst 需要先初始化长度 1func copy(dst, src []Type) int 如果 dst 长度小于 src 的长度，则 copy 部分。 如果大于，则全部拷贝过来，只是没占满 dst 的坑位而已，不会扩大被复制的cap。 相等时刚好不多不少 copy 过来。 函数 copy 在两个 slice 间复制数据，复制长度以 len 小的为准。两个 slice 可指向同一底层数组，允许元素区间重叠。 123456data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}s := data[8:]s2 := data[:5]copy(s2, s) // dst:s2, src:sfmt.Println(s2)fmt.Println(data) 输出： [8 9 2 3 4][8 9 2 3 4 5 6 7 8 9] 应及时将所需数据 copy 到较小的 slice，以便释放超大号底层数组内存。 源切片中元素类型为引用类型时，拷贝的是引用 1234567891011func wrongCopyMatrix() { matA := [][]int{ {0, 1, 1, 0}, {0, 1, 1, 1}, {1, 1, 1, 0}, } matB := make([][]int, len(matA)) copy(matB, matA) fmt.Printf(&quot;%p, %p\\n&quot;, matA, matA[0]) // 0xc0000c0000, 0xc0000c2000 fmt.Printf(&quot;%p, %p\\n&quot;, matB, matB[0]) // 0xc0000c0050, 0xc0000c2000} 如果想 copy 多维切片中的每一个切片类型的元素，那么你需要将每个切片元素进行 初始化 并 拷贝。注意是两步：先 初始化，再 拷贝。 正确的拷贝一个多维数组： 1234567891011121314func rightCopyMatrix() { matA := [][]int{ {0, 1, 1, 0}, {0, 1, 1, 1}, {1, 1, 1, 0}, } matB := make([][]int, len(matA)) for i := range matA { matB[i] = make([]int, len(matA[i])) // 注意初始化长度 copy(matB[i], matA[i]) } fmt.Printf(&quot;%p, %p\\n&quot;, matA, matA[0]) // 0xc00005c050, 0xc000018560 fmt.Printf(&quot;%p, %p\\n&quot;, matB, matB[0]) // 0xc00005c0a0, 0xc0000185c0}","link":"/2022/10/30/Go/%E6%95%B0%E6%8D%AE/"},{"title":"数组与切片","text":"数组 数组是由相同类型元素的集合组成的数据结构 数组大小在初始化之后就无法改变 数组创建可以显式指定数组的大小,也可以根据源代码自定推断数组的大小,不过后者在编译期间会被转换前一种 切片 切片其实就是动态数组,长度不固定","link":"/2022/11/01/Go/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"title":"数组与切片有什么异同","text":"slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。 数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。 而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。 数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。 123456// runtime/slice.gotype slice struct { array unsafe.Pointer // 元素指针 len int // 长度 cap int // 容量} slice 的数据结构如下： 注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。 【引申1】 [3]int 和 [4]int 是同一个类型吗？不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。 【引申2】 下面的代码输出是什么？123456789101112131415161718package mainimport &quot;fmt&quot;func main() { slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} s1 := slice[2:5] s2 := s1[2:6:7] //注意这个7表示是2-&gt;7 也就是容量开始和结束位置 s2 = append(s2, 100) s2 = append(s2, 200) s1[2] = 20 fmt.Println(s1) fmt.Println(s2) fmt.Println(slice)} 结果： 123[2 3 20][4 5 6 7 100 200][0 1 2 3 20 5 6 7 100 9] s1 从 slice 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 s2 从 s1 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。 接着，向 s2 尾部追加一个元素 100： 1s2 = append(s2, 100) s2 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 s1 都可以看得到。 再次向 s2 追加元素200： 1s2 = append(s2, 100) 这时，s2 的容量不够用，该扩容了。于是，s2 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 append 带来的再一次扩容，s2 会在此次扩容的时候多留一些 buffer，将新的容量将扩大为原始容量的2倍，也就是10了。 最后，修改 s1 索引为2位置的元素： 1s1[2] = 20 这次只会影响原始数组相应位置的元素。它影响不到 s2 了，人家已经远走高飞了。 再提一点，打印 s1 的时候，只会打印出 s1 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。","link":"/2022/10/17/Go/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C/"},{"title":"类型","text":"变量 Go 是静态类型语言，不能在运行期改变变量类型。 使用关键字 var 定义变量，自动初始化为零值。如果提供初始化值，可省略变量类型，由编译器自动推断。 123var x intvar f float32 = 1.6var s = &quot;abc&quot; 全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。 在函数内部，可用更简略的 “:=” 方式定义变量。 123func main() { x := 123 // 注意检查，是定义新局部变量，还是修改全局变量。该方式容易造成错误。} 多变量赋值时，先计算所有相关值，然后再从左到右依次赋值。 12data, i := [3]int{0, 1, 2}, 0i, data[i] = 2, 100 // (i = 0) -&gt; (i = 2), (data[0] = 100) 特殊只写变量 “_”，用于忽略值占位。 12345678func test() (int, string) { return 1, &quot;abc&quot;}func main() { _, s := test() println(s)} 编译器会将未使用的局部变量当做错误。 1234var s string // 全局变量没问题。func main() { i := 0 // Error: i declared and not used。(可使用 &quot;_ = i&quot; 规避)} 注意重新赋值与定义新同名变量的区别。 123456789101112func main() { s := &quot;abc&quot; println(&amp;s) s, y := &quot;hello&quot;, 20 // 重新赋值: 与前 s 在同一层次的代码块中，且有新的变量被定义。 println(&amp;s, y) // 通常函数多返回值 err 会被重复使⽤用。 { s, z := 1000, 30 // 定义新同名变量: 不在同一层次代码块。 println(&amp;s, z) }} 常量 常量值必须是编译期可确定的数字、字符串、布尔值。 1234567891011const x, y int = 1, 2 // 多常量初始化const s = &quot;Hello, World!&quot; // 类型推断const ( // 常量组 a, b = 10, 100 c bool = false)func main() { const x = &quot;xxx&quot; // 未使用局部常量不会引发编译错误。} 在常量组中，如不提供类型和初始化值，那么视作与上一常量相同。 1234const ( s = &quot;abc&quot; x // x = &quot;abc&quot;) 常量值还可以是 len、cap、unsafe.Sizeof 等编译期可确定结果的函数返回值。 12345const ( a = &quot;abc&quot; b = len(a) c = unsafe.Sizeof(b)) 如果常量类型足以存储初始化值，那么不会引发溢出错误。 1234const ( a byte = 100 // int to byte b int = 1e20 // float64 to int, overflows) 常量不能使用 “:=” 语法定义。 枚举 关键字 iota 定义常量组中从 0 开始按行计数的自增枚举值。 123456789const ( Sunday = iota // 0 Monday // 1，通常省略后续行表达式。 Tuesday // 2 Wednesday // 3 Thursday // 4 Friday // 5 Saturday // 6) 1234567const ( _ = iota // iota = 0 KB int64 = 1 &lt;&lt; (10 * iota) // iota = 1 MB // 与 KB 表达式相同，但 iota = 2 GB TB) 在同一常量组中，可以提供多个 iota，它们各自增长。 1234const ( A, B = iota, iota &lt;&lt; 10 // 0, 0 &lt;&lt; 10 C, D // 1, 1 &lt;&lt; 10) 如果 iota 自增被打断，须显式恢复。 12345678const ( A = iota // 0 B // 1 C = &quot;c&quot; // c D // c，与上一⾏行相同。 E = iota // 4，显式恢复。注意计数包含了 C、D 两行。 F // 5) 可通过自定义类型来实现枚举类型限制。 12345678910111213141516type Color intconst ( Black Color = iota Red Blue)func test(c Color) {}func main() { c := Black test(c) x := 1 test(x) // Error: cannot use x (type int) as type Color in function argument test(1) // 常量会被编译器自动转换。} 基本类型 更明确的数字类型命名，支持 Unicode，支持常用数据结构。 支持八进制、十六进制，以及科学记数法。标准库 math 定义了各数字类型取值范围。 1a, b, c, d := 071, 0x1F, 1e9, math.MinInt16 空指针值 nil，而非 C/C++ NULL。 引用类型 引用类型包括 slice、map 和 channel。它们有复杂的内部结构，除了申请内存外，还需要初始化相关属性。 内置函数 new 计算类型大小，为其分配零值内存，返回指针。而 make 会被编译器翻译成具体的创建函数，由其分配内存和初始化成员结构，返回对象而非指针。 12345678a := []int{0, 0, 0} // 提供初始化表达式。a[1] = 10b := make([]int, 3) // makesliceb[1] = 10c := new([]int)c[1] = 10 // Error: invalid operation: c[1] (index of type *[]int)d := new(int)*d = 10 类型转换 不支持隐式类型转换，即便是从窄向宽转换也不行。 123var b byte = 100// var n int = b // Error: cannot use b (type byte) as type int in assignmentvar n int = int(b) // 显式转换 使用括号避免优先级错误。 1234*Point(p) // 相当于 *(Point(p))(*Point)(p)&lt;-chan int(c) // 相当于 &lt;-(chan int(c))(&lt;-chan int)(c) 同样不能将其他类型当 bool 值使用。 1234a := 100if a { // Error: non-bool a (type int) used as if condition println(&quot;true&quot;)} 字符串 字符串是不可变值类型，内部用指针指向 UTF-8 字节数组。 默认值是空字符串 “”。 用索引号访问某字节，如 s[i]。 不能用序号获取字节元素指针，&amp;s[i] 非法。 不可变类型，无法修改字节数组。 字节数组尾部不包含 NULL。 在go中源代码src/builtin/builtin.go中定义了string标准概念： 1234// string is the set of all strings of 8-bit bytes, conventionally but not// necessarily representing UTF-8-encoded text. A string may be empty, but// not nil. Values of string type are immutable.type string string string是8bit字节的集合，通常是但并不一定非得是UTF-8编码的文本。 string可以为空(长度为0)，但不会是nil。 string对象不可以修改。 在go源代码src/runtime/string.go:stringStruct中定义了string的数据结构： 1234type stringStruct struct { str unsafe.Pointer //字符串首地址，指向底层字节数组的指针 len int //字符串长度} 使用 “`” 定义不做转义处理的原始字符串，支持跨行。 123456func main() { s := `ab\\r\\n\\x00c` println(s)} 输出： ab\\r\\n\\x00c 连接跨行字符串时，”+” 必须在上一行末尾，否则导致编译错误。 1234s := &quot;Hello, &quot; +&quot;World!&quot;s2 := &quot;Hello, &quot;+ &quot;World!&quot; // Error: invalid operation: + untyped string 单引号字符常量表示 Unicode Code Point，支持 \\uFFFF、\\U7FFFFFFF、\\xFF 格式。对应 rune 类型，UCS-4。 12345func main() { fmt.Printf(&quot;%T\\n&quot;, 'a') var c1, c2 rune = '\\u6211', '们' println(c1 == '我', string(c2) == &quot;\\xe4\\xbb\\xac&quot;)} 输出： int32 // rune 是 int32 的别名true true 要修改字符串，可先将其转换成 []rune 或 []byte，完成后再转换为 string。无论哪种转换，都会重新分配内存，并复制字节数组。 12345678910func main() { s := &quot;abcd&quot; bs := []byte(s) bs[1] = 'B' println(string(bs)) u := &quot;电脑&quot; us := []rune(u) us[1] = '话' println(string(us))} 输出： aBcd电话 用 for 循环遍历字符串时，也有 byte 和 rune 两种方式。 12345678910func main() { s := &quot;abc汉字&quot; for i := 0; i &lt; len(s); i++ { // byte fmt.Printf(&quot;%c,&quot;, s[i]) } fmt.Println() for _, r := range s { // rune fmt.Printf(&quot;%c,&quot;, r) }} 输出： a,b,c,æ,±,,å,­,,a,b,c,汉,字, 指针 支持指针类型 *T，指针的指针 **T，以及包含包名前缀的 *.T。 默认值 nil，没有 NULL 常量。 操作符 “&amp;” 取变量地址，”*” 透过指针访问目标对象。 不支持指针运算，不支持 “-&gt;” 运算符，直接用 “.” 访问目标成员。 不能对指针做加减法等运算。 123x := 1234p := &amp;xp++ // Error: invalid operation: p += 1 (mismatched types *int and int) 可以在 unsafe.Pointer 和任意类型指针间进行转换。 12345678func main() { x := 0x12345678 p := unsafe.Pointer(&amp;x) // *int -&gt; Pointer n := (*[4]byte)(p) // Pointer -&gt; *[4]byte for i := 0; i &lt; len(n); i++ { fmt.Printf(&quot;%X &quot;, n[i]) }} 输出： 78 56 34 12 返回局部变量指针是安全的，编译器会根据需要将其分配在 GC Heap 上。 1234func test() *int { x := 100 return &amp;x // 在堆上分配 x 内存。但在内联时，也可能直接分配在目标栈。} 将 Pointer 转换成 uintptr，可变相实现指针运算。 123456789101112func main() { d := struct { s string x int }{&quot;abc&quot;, 100} p := uintptr(unsafe.Pointer(&amp;d)) // *struct -&gt; Pointer -&gt; uintptr p += unsafe.Offsetof(d.x) // uintptr + offset p2 := unsafe.Pointer(p) // uintptr -&gt; Pointer px := (*int)(p2) // Pointer -&gt; *int *px = 200 // d.x = 200 fmt.Printf(&quot;%#v\\n&quot;, d)} 输出： struct { s string; x int }{s:”abc”, x:200} 注意：GC 把 uintptr 当成普通整数对象，它无法阻止 “关联” 对象被回收。 自定义类型 可将类型分为命名和未命名两大类。命名类型包括 bool、int、string 等，而 array、slice、map 等和具体元素类型、长度等有关，属于未命名类型。 具有相同声明的未命名类型被视为同一类型。 具有相同基类型的指针。 具有相同元素类型和长度的 array。 具有相同元素类型的 slice。 具有相同键值类型的 map。 具有相同元素类型和传送方向的 channel。 具有相同字段序列 (字段名、类型、标签、顺序) 的匿名 struct。 签名相同 (参数和返回值，不包括参数名称) 的 function。 方法集相同 (方法名、方法签名相同，和次序无关) 的 interface。 可用 type 在全局或函数内定义新类型。 12345func main() { type bigint int64 var x bigint = 100 println(x)} 新类型不是原类型的别名，除拥有相同数据存储结构外，它们之间没有任何关系，不会持有原类型任何信息。除非目标类型是未命名类型，否则必须显式转换。 12345x := 1234var b bigint = bigint(x) // 必须显式转换，除⾮非是常量。var b2 int64 = int64(b)var s myslice = []int{1, 2, 3} // 未命名类型，隐式转换。var s2 []int = s","link":"/2022/10/27/Go/%E7%B1%BB%E5%9E%8B/"},{"title":"表达式","text":"保留字 语言设计简练，保留字不多。 运算符 全部运算符、分隔符，以及其他符号。 运算符结合律全部从左到右。 简单位运算演示。 如果运算符右侧数值的第 i 位为 1，那么计算结果中的第 i 位为 0；如果运算符右侧数值的第 i 位为 0，那么计算结果中的第 i 位为运算符左侧数值的第 i 位的值。 标志位操作。 1234a := 0a |= 1 &lt;&lt; 2 // 0000100: 在 bit2 设置标志位。a |= 1 &lt;&lt; 6 // 1000100: 在 bit6 设置标志位a = a &amp;^ (1 &lt;&lt; 6) // 0000100: 清除 bit6 标志位。 不支持运算符重载。尤其需要注意，”++”、”–” 是语句而非表达式。 123456789n := 0p := &amp;n// b := n++ // syntax error// if n++ == 1 {} // syntax error// ++n // syntax errorn++*p++ // (*p)++ 没有 “~”，取反运算也用 “^”。 12x := 1x, ^x // 0001, -0010 初始化 初始化复合对象，必须使用类型标签，且左大括号必须在类型尾部。 1234567// var a struct { x int } = { 100 } // syntax error// var b []int = { 1, 2, 3 } // syntax error// c := struct {x int; y string} // syntax error: unexpected semicolon or newline// {// }var a = struct{ x int }{100}var b = []int{1, 2, 3} 初始化值以 “,” 分隔。可以分多行，但最后一行必须以 “,” 或 “}” 结尾。 1234567891011a := []int{ 1, 2 // Error: need trailing comma before newline in composite literal}a := []int{ 1, 2, // ok}b := []int{ 1, 2 } // ok 控制流IF 可省略条件表达式括号。 支持初始化语句，可定义代码块局部变量。 代码块左大括号必须在条件表达式尾部。 1234567891011x := 0// if x &gt; 10 // Error: missing condition in if statement// {// }if n := &quot;abc&quot;; x &gt; 0 { // 初始化语句未必就是定义变量，比如 println(&quot;init&quot;) 也是可以的。 println(n[2])} else if x &lt; 0 { // 注意 else if 和 else 左大括号位置。 println(n[1])} else { println(n[0])} 不支持三元操作符 “a &gt; b ? a : b”。 For 支持三种循环方式，包括类 while 语法。 123456789101112s := &quot;abc&quot;for i, n := 0, len(s); i &lt; n; i++ { // 常见的 for 循环，支持初始化语句。 println(s[i])}n := len(s)for n &gt; 0 { // 替代 while (n &gt; 0) {} println(s[n-1]) // 替代 for (; n &gt; 0;) {} n--}for { // 替代 while (true) {} println(s) // 替代 for (;;) {}} 不要期望编译器能理解你的想法，在初始化语句中计算出全部结果是个好主意。 12345678910func length(s string) int { println(&quot;call length.&quot;) return len(s)}func main() { s := &quot;abcd&quot; for i, n := 0, length(s); i &lt; n; i++ { // 避免多次调⽤用 length 函数。 println(i, s[i]) }} 输出： call length.0 971 982 993 100 Range 类似迭代器操作，返回 (索引, 值) 或 (键, 值)。 可忽略不想要的返回值，或用 “_” 这个特殊变量。 1234567891011121314s := &quot;abc&quot;for i := range s { // 忽略 2nd value，支持 string/array/slice/map。println(s[i])}for _, c := range s { // 忽略 index。println(c)}for range s { // 忽略全部返回值，仅迭代。...}m := map[string]int{&quot;a&quot;: 1, &quot;b&quot;: 2}for k, v := range m { // 返回 (key, value)。println(k, v)} 注意，range 会复制对象。 123456789a := [3]int{0, 1, 2}for i, v := range a { // index、value 都是从复制品中取出。 if i == 0 { // 在修改前，我们先修改原数组。 a[1], a[2] = 999, 999 fmt.Println(a) // 确认修改有效，输出 [0, 999, 999]。 } a[i] = v + 100 // 使用复制品中取出的 value 修改原数组。}fmt.Println(a) // 输出 [100, 101, 102]。 建议改用引用类型，其底层数据不会被复制。 12345678s := []int{1, 2, 3, 4, 5}for i, v := range s { // 复制 struct slice { pointer, len, cap }。 if i == 0 { s = s[:3] // 对 slice 的修改，不会影响 range。 s[2] = 100 // 对底层数据的修改。 } println(i, v)} 输出： 0 11 22 1003 44 5 Switch 分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。 12345678910x := []int{1, 2, 3}i := 2switch i {case x[1]: println(&quot;a&quot;)case 1, 3: println(&quot;b&quot;)default: println(&quot;c&quot;)} 输出： a 如需要继续下一分支，可使用 fallthrough，但不再判断条件。 12345678x := 10switch x {case 10: println(&quot;a&quot;) fallthroughcase 0: println(&quot;b&quot;)} 输出： a b 省略条件表达式，可当 if…else if…else 使用。 1234567891011121314151617x := []int{1, 2, 3}switch {case x[1] &gt; 0: println(&quot;a&quot;)case x[1] &lt; 0: println(&quot;b&quot;)default: println(&quot;c&quot;)}switch i := x[2]; { // 带初始化语句case i &gt; 0: println(&quot;a&quot;)case i &lt; 0: println(&quot;b&quot;)default: println(&quot;c&quot;)} Goto, Break, Continue 支持在函数内 goto 跳转。标签名区分大小写，未使用标签引发错误。 12345678910111213func main() { var i int for { println(i) i++ if i &gt; 2 { goto BREAK } }BREAK: println(&quot;break&quot;)EXIT: // Error: label EXIT defined and not used} break用来结束最里面的for/select/switch的语句，如果这里有标签，那么它必须在for/select/switch的正上面。 配合标签，break 和 continue 可在多级嵌套循环中跳出。 12345678910111213141516func main() {L1: for x := 0; x &lt; 3; x++ { L2: for y := 0; y &lt; 5; y++ { if y &gt; 2 { continue L2 } if x &gt; 1 { break L1 } print(x, &quot;:&quot;, y, &quot; &quot;) } println() }} 输出： 0:0 0:1 0:21:0 1:1 1:2 break 可用于 for、switch、select，而 continue 仅能用于 for 循环。","link":"/2022/10/28/Go/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"错误处理","text":"Go语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种异常，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，才使用Go中引入的Exception处理：defer, panic, recover。 panic 内建函数 panic是内建函数.panic会中断函数F的正常执行流程, 从F函数中跳出来, 跳回到F函数的调用者. 对于调用者来说, F看起来就是一个panic, 所以调用者会继续向上跳出, 直到当前goroutine返回. 在跳出的过程中, 进程会保持这个函数栈. 当goroutine退出时, 程序会crash F函数中的defer函数会正常执行 除了主动调用panic之外, 其他的任何运行时错误, 例如数组越界都会造成panic panic 只会触发当前 Goroutine 的延迟函数调用 12345678910111213141516171819package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { // 主线程中的defer函数并不会执行，因为子协程 panic后，主线程中的defer并不会执行 defer println(&quot;in main&quot;) go func() { defer println(&quot;in goroutine&quot;) fmt.Println(&quot;子协程running&quot;) panic(&quot;子协程崩溃&quot;) }() time.Sleep(1 * time.Second)} 输出： 子协程runningin goroutinepanic: 子协程崩溃 延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获 123456789101112131415func test() { defer func() { fmt.Println(recover()) }() defer func() { panic(&quot;defer1 panic&quot;) }() defer func() { panic(&quot;defer2 panic&quot;) }() panic(&quot;test panic&quot;)}func main() { test()} 输出： defer1 panic recover 内建函数 recover如果想起作用的话, 必须在defer函数中使用 直接调用时无效 1234func main() { recover() panic(1)} 直接 defer 调用也是无效 1234func main() { defer recover() panic(1)} defer 调用时多层嵌套依然无效 123456func main() { defer func() { func() { recover() }() }() panic(1)} 必须在 defer 函数中直接调用才有效 123456func main() { defer func() { recover() }() panic(1)} 或下面这样也是有效的 1234567func except() { recover()}func test() { defer except() panic(&quot;test panic&quot;)} 在正常函数执行过程中, 调用recover没有任何作用, 他会返回nil. 如这样:fmt.Println(recover()) // nil 如果当前的goroutine panic了, 那么recover将会捕获这个panic的值, 并且让程序正常执行下去, 不会让程序crash 在当前goroutine的中, recover会捕获recover所在的函数产生的的panic, 由于panic会让当前函数返回, 但是对于其调用者来说, 这个panic已经不存在了, 所以程序还是会按照正常的执行流程执行下去 1234567891011121314151617181920212223242526272829package mainimport &quot;fmt&quot;func main() { f() fmt.Println(&quot;Returned normally from f.&quot;)}func f() { defer func() { if r := recover(); r != nil { fmt.Println(&quot;Recovered in f&quot;, r) } }() fmt.Println(&quot;Calling g.&quot;) g(0) fmt.Println(&quot;Returned normally from g.&quot;)}func g(i int) { if i &gt; 3 { fmt.Println(&quot;Panicking!&quot;) panic(fmt.Sprintf(&quot;%v&quot;, i)) } defer fmt.Println(&quot;Defer in g&quot;, i) fmt.Println(&quot;Printing in g&quot;, i) g(i + 1)} 输出：（**fmt.Println(&quot;Returned normally from g.&quot;)没有打印, 而fmt.Println(&quot;Returned normally from f.&quot;)打印了**） Calling g.Printing in g 0Printing in g 1Printing in g 2Printing in g 3Panicking!Defer in g 3Defer in g 2Defer in g 1Defer in g 0Recovered in f 4Returned normally from f. 如果需要保护代码片段，可将代码块重构成匿名函数，如此可确保后续代码被执行 12345678910111213func test(x, y int) { var z int func() { defer func() { if recover() != nil { z = 0 } }() z = x / y return }() println(&quot;x / y =&quot;, z)} 由于 panic、recover 参数类型为 interface{}，因此可抛出任何类型对象 error error：可预见的错误 panic：不可预见的异常 需要注意的是，你应该尽可能地使用error，而不是使用 panic 和 recover。只有当程序不能继续运行的时候，才应该使用 panic 和 recover 机制。 go中的error是一个接口类型 12345// The error built-in interface type is the conventional interface for// representing an error condition, with the nil value representing no error.type error interface { Error() string} 从定义看出，Go中的error是一个简单的接口，接口定义了一个Error()方法，其返回值为string。 12345678910111213// src/errors/errors.gofunc New(text string) error { return &amp;errorString{text}}type errorString struct { s string}func (e *errorString) Error() string { return e.s} 使用 New 函数创建出来的 error 类型实际上是 errors 包里未导出的 errorString 类型，它包含唯一的一个字段 s，并且实现了唯一的方法：Error() string。 为什么是返回指针，不是返回结构体对象本身呢？ 就是为了避免定义两个同样错误内容的不同自定义错误做==判定的时候会相等，但是指针的话，就是比较两个不一样的地址，就不会相等。 举个使用的例子： 12345678910111213141516var ErrDivByZero = errors.New(&quot;division by zero&quot;)func div(x, y int) (int, error) { if y == 0 { return 0, ErrDivByZero } return x / y, nil}func main() { switch z, err := div(10, 0); err { case nil: println(z) case ErrDivByZero: panic(err) }} go中的错误处理，是通过返回值的形式来出来，要么你忽略，要么你处理（处理也可以是继续返回给调用者），对于golang这种设计方式，我们会在代码中写大量的if判断，以便做出决定。 12345678func main() { conent,err:=ioutil.ReadFile(&quot;filepath&quot;) if err !=nil{ //错误处理 }else { fmt.Println(string(conent)) }} 对于err如果是nil就代表没有错误，如果不是nil就代表程序出问题了，需要对错误进行处理了。","link":"/2022/10/30/Go/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"title":"MySQL面试题","text":"基础执行一条 select 语句，期间发生了什么？ 如何查看 MySQL 服务被多少个客户端连接了？ 空闲连接会一直占用着吗？ MySQL 的连接数有限制吗？ 怎么解决长连接占用内存的问题？ 12345678910连接器：建立连接，管理连接、校验用户身份；查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；执行 SQL：执行 SQL 共有三个阶段： 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划； 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端； 参考：执行一条 select 语句，期间发生了什么？","link":"/2022/11/05/MySQL/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"hexo踩坑——修改样式","text":"记录使用hexo修改样式时遇到的问题 在使用hexo时发现目录无法粘性定位，阅读文章时中间正文很窄需要修改样式等问题，所以找了找修改方案 修改样式需要以源码形式安装icarus参考文章修改源码后发现不生效，发现因为是用npm以包安装形式安装的，需要改成源码形式安装，卸载包后以源码形式安装 https://ppoffice.github.io/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#install-source 参考修改方案https://www.alphalxy.com/2019/03/customize-icarus/ https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/#more https://ppoffice.github.io/hexo-theme-icarus/tags/Icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/","link":"/2022/10/08/hexo/hexo%E8%B8%A9%E5%9D%912/"},{"title":"hexo踩坑——插入图片","text":"记录使用hexo时插入图片遇到的问题 在使用Typora+hexo插入图片时，图片加载失败，发现url路径存在问题 采用官方解决方案搜索之后发现官方有相应解决方案，但是官方的方案和markdown兼容差，所以放弃 参考： https://cloud.tencent.com/developer/article/1702112 https://hexo.io/zh-cn/docs/asset-folders.html 采用插件可以通过hexo-asset-image插件解决markdown兼容问题，但hexo-asset-image也存在图片路径存在多余域名导致无法解析的新问题，需要修改插件代码 参考： https://blog.csdn.net/weixin_44999716/article/details/112401495 https://wangwei1237.github.io/2020/02/05/handle-the-bug-of-hexo-asset-image-plugin/","link":"/2022/10/05/hexo/hexo%E8%B8%A9%E5%9D%911/"},{"title":"hexo踩坑——字体和计数","text":"修改正文字体修改themes\\icarus\\layout\\common\\head.jsx中fontCssUrl的字体，由于默认使用Google CDN，直接到fonts.google.com中找想要的字体再填入即可 12345const fontCssUrl = { //default: fontcdn('Ubuntu:wght@400;600&amp;family=Source+Code+Pro', 'css2'), default: fontcdn('Noto+Sans+SC:wght@400;600&amp;family=Roboto+Mono', 'css2'), cyberpunk: fontcdn('Oxanium:wght@300;400;600&amp;family=Roboto+Mono', 'css2')}; 参考：http://www.anticme.com/2021/03/26/icarus%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE/ 修改代码字体修改themes\\icarus\\include\\style\\base.styl中family-code的字体 12$family-sans-serif ?= Ubuntu, Roboto, 'Open Sans', 'Microsoft YaHei', sans-serif$family-code ?= 'Noto Serif Simplified Chinese' family-sans-serif: 正文字体family-code: 代码字体没有办法通过设置单独修改每个元素的字体。想改只能在代码层面改。 参考：https://github.com/ppoffice/hexo-theme-icarus/discussions/913 不蒜子计数与live2d冲突参考：https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-live2-busuanzi-err/fluid-live2-busuanzi-err/","link":"/2022/10/28/hexo/hexo%E8%B8%A9%E5%9D%913/"},{"title":"二叉树","text":"什么是二叉树二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。 相关术语结点：包含一个数据元素及若干指向子树分支的信息。 结点的度：一个结点拥有子树的数据成为结点的度。 叶子结点：也称为终端结点，没有子树的结点或者度为零的结点。 分支结点：也称为非终端结点，度不为零的结点成为非终端结点。 结点的层次：从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推。 树的度：树中所有结点的度的最大值。 树的深度：树中结点的最大层次。 二叉树的种类满二叉树如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 完全二叉树在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1) 个节点。 二叉搜索树（二叉排序树、二叉查找树） 左子树的所有节点的值均小于它的根节点的值 右子树的所有节点的值均大于它的根节点的值 它的左右子树也分别为二叉搜索树 平衡二叉树（AVL树）平衡二叉树具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 红黑树——TODOB树——TODO堆——TODO二叉树的存储方式二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。 链式存储 顺序存储 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。 但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。 二叉树遍历二叉树主要有两种遍历方式： 深度优先遍历：先往深走，遇到叶子节点再往回走。 广度优先遍历：一层一层的去遍历。 深度优先遍历 前序遍历 中序遍历 后序遍历 深度优先遍历经常使用递归的方式来实现，栈其实就是递归的一种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。 这里前中后，其实指的就是中间节点的遍历顺序，只要记住 前中后序指的就是中间节点的位置就可以了。 广度优先遍历 层次遍历 广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。 二叉树定义C++123456struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}}; Python12345class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None Go12345type TreeNode struct { Val int Left *TreeNode Right *TreeNode} 例题二叉树遍历 —— 二叉树遍历模板 144. 二叉树的前序遍历 145. 二叉树的后序遍历 94. 二叉树的中序遍历 102. 二叉树的层序遍历 107. 二叉树的层次遍历II 199. 二叉树的右视图 637. 二叉树的层平均值 429. N叉树的层序遍历 515. 在每个树行中找最大值 116. 填充每个节点的下一个右侧节点指针 117. 填充每个节点的下一个右侧节点指针II 104. 二叉树的最大深度 111. 二叉树的最小深度","link":"/2022/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"二叉树遍历","text":"深度优先遍历前序遍历迭代 python 12345678910111213141516171819class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] st= [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: #右 st.append(node.right) if node.left: #左 st.append(node.left) st.append(node) #中 st.append(None) else: node = st.pop() result.append(node.val) return result 递归 python 1234567891011121314class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: # 保存结果 result = [] def traversal(root: TreeNode): if root == None: return result.append(root.val) # 前序 traversal(root.left) # 左 traversal(root.right) # 右 traversal(root) return result 中序遍历迭代 python 123456789101112131415161718192021class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: if node.right: #添加右节点（空节点不入栈） st.append(node.right) st.append(node) #添加中节点 st.append(None) #中节点访问过，但是还没有处理，加入空节点做为标记。 if node.left: #添加左节点（空节点不入栈） st.append(node.left) else: #只有遇到空节点的时候，才将下一个节点放进结果集 node = st.pop() #重新取出栈中元素 result.append(node.val) #加入到结果集 return result 递归 python 12345678910111213class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] def traversal(root: TreeNode): if root == None: return traversal(root.left) # 左 result.append(root.val) # 中序 traversal(root.right) # 右 traversal(root) return result 后序遍历迭代 python 1234567891011121314151617181920class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] st = [] if root: st.append(root) while st: node = st.pop() if node != None: st.append(node) #中 st.append(None) if node.right: #右 st.append(node.right) if node.left: #左 st.append(node.left) else: node = st.pop() result.append(node.val) return result 递归 python 12345678910111213class Solution: def postorderTraversal(self, root: TreeNode) -&gt; List[int]: result = [] def traversal(root: TreeNode): if root == None: return traversal(root.left) # 左 traversal(root.right) # 右 result.append(root.val) # 后序 traversal(root) return result 广度优先遍历迭代 python 1234567891011121314151617181920212223class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: results = [] if not root: return results from collections import deque que = deque([root]) while que: size = len(que) result = [] for _ in range(size): cur = que.popleft() result.append(cur.val) if cur.left: que.append(cur.left) if cur.right: que.append(cur.right) results.append(result) return results 递归 python 1234567891011class Solution: def levelOrder(self, root: TreeNode) -&gt; List[List[int]]: res = [] def helper(root, depth): if not root: return [] if len(res) == depth: res.append([]) # start the current depth res[depth].append(root.val) # fulfil the current depth if root.left: helper(root.left, depth + 1) # process child nodes for the next depth if root.right: helper(root.right, depth + 1) helper(root, 0) return res","link":"/2022/10/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/"},{"title":"原码,反码,补码","text":"机器数和真值在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念. 机器数一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1. 比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。 那么，这里的 00000011 和 10000011 就是机器数。 真值 因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。 例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1 原码, 反码, 补码的基础概念和计算方法在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式. 原码原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制: [+1]原 = 0000 0001 [-1]原 = 1000 0001 第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是: [1111 1111 , 0111 1111] 即 [-127 , 127] 原码是人脑最容易理解和计算的表示方式. 反码反码的表示方法是: 正数的反码是其本身 负数的反码是在其原码的基础上, 符号位不变，其余各个位取反. [+1] = [00000001]原 = [00000001]反 [-1] = [10000001]原 = [11111110]反 可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算. 补码补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 为何要使用原码, 反码和补码在开始深入学习前, 我的学习建议是先”死记硬背”上面的原码, 反码和补码的表示方式以及计算方法. 现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同: [+1] = [00000001]原 = [00000001]反 = [00000001]补 所以不需要过多解释. 但是对于负数: [-1] = [10000001]原 = [11111110]反 = [11111111]补 可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢? 首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了. 于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数. 为了解决原码做减法的问题, 出现了反码: 计算十进制的表达式: 1-1=0 1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0 发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0. 于是补码的出现, 解决了0的符号以及两个编码的问题: 1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原 这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128: (-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补 -1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的) 使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]. 因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值. 1的取反为什么是-2 先求取1的取反，也就是将1的二进制数1变成0，0变成1. 1的源码为 00000000 0000000 0000000 00000001 1的取反为 11111111 11111111 11111111 11111110 接下来就是对1取反的数进行分析 11111111 11111111 11111111 11111110这个数我们不知道是那个数，但我们知道它是一个负数，因为最左侧为1是符号位，表示负数。而在计算机中，无论正数还是负数都是以补码的形式进行加减运算的，也就是说11111111 11111111 11111111 11111110在这里是一个补码，我们需要将它转换为源码，才知道这个整数。 减一后得到反码为 11111111 11111111 11111111 11111101取反后得到源码为 10000000 00000000 00000000 00000010 也就是源码为-2最终答案1的取反为-2","link":"/2022/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/"},{"title":"tcpdump笔记","text":"tcpdump介绍及常用命令tcpdump是linux上自带的一个抓包软件(mac也有)，功能强大，也可以抓取经过指定网卡的所有协议包。由于是命令行工具，tcpdump抓取到的包不易于分析，一个常见的做法是将tcpdump抓到的包输出到某个文件，然后将文件拷贝下来用wireshark分析。 12345678910111213141516# -i 参数表示抓取指定网卡的内容。具体网卡可以通过 ifconfig 命令查看# 如果不指定网卡，默认tcpdump只会监视第一个网络接口tcpdump -i en0# 打印所有www.baidu.com相关的包,这个host后面可以填 域名，也可以填iptcpdump host www.baidu.comtcpdump host 192.168.0.1# 打印 nn1和nn2或nn3 主机间通信的包，这里可以替换成iptcpdump host nn1 and \\( nn2 or nn3 \\)# 打印nn1和非nn2之间的ip数据包tcpdump ip host nn1 and not nn2# 发送者是nn1的数据包tcpdump -i en0 src host nn1# 接受者是nn1的数据包tcpdump -i en0 dst host nn1# 抓取指定网卡的包输出到test.cap，之后我们可以把test.cap直接用wireshark打开，就可以很直观的分析包了。tcpdump -i en0 -w test.cap 优缺点 优点： 1、功能强大，可以抓所有协议的包 2、linux自带，直接在所有的服务器上面抓包，这是其他抓包软件不具备的 缺点： 1、数据包分析困难，需要配合wireshark使用 2、和wireshark一样，无法分析https数据包 实例：tcpdump分析TCP三次握手和四次挥手测试环境：macOS，命令行 12tcpdump host www.baidu.comcurl http://www.baidu.com 三次握手报文： 1234522:14:22.971082 IP 192.168.10.106.56870 &gt; 39.156.66.18.http: Flags [S], seq 1673627998, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 423967463 ecr 0,sackOK,eol], length 022:14:23.000954 IP 39.156.66.18.http &gt; 192.168.10.106.56870: Flags [S.], seq 3220397178, ack 1673627999, win 8192, options [mss 1452,nop,wscale 5,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,sackOK,eol], length 022:14:23.001002 IP 192.168.10.106.56870 &gt; 39.156.66.18.http: Flags [.], ack 1, win 4096, length 0 报文中Flags [S]表示SYN报文，Flags [.]表示ACK报文，Flags[S.]表示SYN+ACK报文。 四次挥手报文： 123456722:14:23.030163 IP 192.168.10.106.56870 &gt; 39.156.66.18.http: Flags [F.], seq 78, ack 2782, win 4096, length 022:14:23.055482 IP 39.156.66.18.http &gt; 192.168.10.106.56870: Flags [.], ack 79, win 2452, length 022:14:23.055486 IP 39.156.66.18.http &gt; 192.168.10.106.56870: Flags [F.], seq 2782, ack 79, win 2452, length 022:14:23.055539 IP 192.168.10.106.56870 &gt; 39.156.66.18.http: Flags [.], ack 2783, win 4096, length 0 报文中Flags [F.]表示FIN+ACK，Flags [.]表示ACK。","link":"/2023/02/01/%E5%B7%A5%E5%85%B7/tcpdump/"},{"title":"动态规划","text":"什么是动态规划动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 所以动态规划中每一个状态一定是由上一个状态推导出来的，这一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的。 如何理解动态规划动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。 A ：”1+1+1+1+1+1+1+1 =？” A ：”上面等式的值是多少” B ：计算 “8” A : 在上面等式的左边写上 “1+” 呢？ A : “此时等式的值为多少” B : 很快得出答案 “9” A : “你怎么这么快就知道答案了” A : “只要在8的基础上加1就行了” A : “所以你不用重新计算，因为你记住了第一个等式的值为8!动态规划算法也可以说是 ‘记住求过的解来节省时间’” 动态规划解决的问题能采用动态规划求解的问题的一般要具有3个性质： 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势） 动态规划模板 确定dp数组（dp table）以及下标的含义 确定递推公式 dp数组如何初始化 确定遍历顺序 举例推导dp数组 例题 基础 509. 斐波那契数 —— 题解 70. 爬楼梯 —— 题解 746. 使用最小花费爬楼梯 —— 题解 62. 不同路径 —— 题解 63. 不同路径 II —— 题解 343. 整数拆分 —— 题解 96. 不同的二叉搜索树 —— 题解 背包问题 —— 理论基础 能否能装满背包：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) 416. 分割等和子集 —— 题解 1049. 最后一块石头的重量 II —— 题解 装满背包有几种方法：dp[j] += dp[j - nums[i]] 70. 爬楼梯 —— 题解 494. 目标和 —— 题解 377. 组合总和 Ⅳ —— 题解 518. 零钱兑换 II —— 题解 背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) 474. 一和零 —— 题解 装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]) 322. 零钱兑换 —— 题解 279. 完全平方数 —— 题解 139. 单词拆分 —— 题解 打家劫舍 198. 打家劫舍—— 题解 213. 打家劫舍 II—— 题解 337. 打家劫舍 III—— 题解 买卖股票 121. 买卖股票的最佳时机—— 题解 122. 买卖股票的最佳时机 II—— 题解 123. 买卖股票的最佳时机 III—— 题解 188. 买卖股票的最佳时机 IV—— 题解 309. 最佳买卖股票时机含冷冻期—— 题解 714. 买卖股票的最佳时机含手续费—— 题解 子序列 子序列（不连续） 300. 最长递增子序列—— 题解 1143. 最长公共子序列—— 题解 1035. 不相交的线—— 题解 子序列（连续） 674. 最长连续递增序列—— 题解 718. 最长重复子数组—— 题解 53. 最大子数组和—— 题解 编辑距离 392. 判断子序列—— 题解 115. 不同的子序列—— 题解 583. 两个字符串的删除操作—— 题解 72. 编辑距离—— 题解 回文 647. 回文子串—— 题解 5. 最长回文子串 516. 最长回文子序列—— 题解","link":"/2022/10/29/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"二分查找算法","text":"什么是二分查找在计算机科学中，二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）、对数搜索算法（英语：logarithmic search algorithm），是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。 二分查找解决的问题 有序数组查找某一元素是否存在 有序数组查找某一元素的首地址或尾地址 算法思路123456789101112131415int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] &lt; target) { left = ... } else if (nums[mid] &gt; target) { right = ... } } return ...;} while 循环条件是 &lt;= 还是 &lt; ? 当 right 为 nums.length - 1 时循环条件是 &lt;= ， right 为 nums.length 时循环条件是 &lt; 。区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。 while 循环条件为 &lt;= 时，注意死循环问题 当采用 while 循环条件为 &lt;= 的方式解题时，遇到查找元素首地址或尾地址时可能疏忽没有将 left 或 right 变为 mid + 1 或 mid - 1。这会造成死循环，此时 left 和 right 的赋值条件无需改变，只需要明白 left 和 right 的含义，考虑我们需要的是 left 还是 right 即可。 当找元素首地址时我们应该用 left 为结果，因为 left 代表含义是 小于目标值 右侧的第一个值，即目标元素第一个地址。当 nums[mid] == target 时应将 right = mid - 1，因为我们要的是 left，right = mid 在 while 为 &lt;= 时会造成死循环，且 right = mid - 1 并不会造成元素丢失，因为因 nums[mid] == target 的 right = mid - 1 而结束循环时 left 的值为 mid 正是我们需要的。 当找元素尾地址时可以采用以 right 为结果的方式或查找 目标元素值+1的首地址 再将其-1即为目标元素尾地址。 例题 704. 二分查找 367. 有效的完全平方数 35. 搜索插入位置 34. 在排序数组中查找元素的第一个和最后一个位置 69. x 的平方根 33. 搜索旋转排序数组 —— 题解","link":"/2022/11/15/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"},{"title":"双指针算法","text":"什么是双指针算法双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。 例题 27. 移除元素 844. 比较含退格的字符串 977. 有序数组的平方 283. 移动零 26. 删除有序数组中的重复项","link":"/2022/11/16/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"title":"回溯法","text":"什么是回溯法回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 如何理解回溯法 回溯法是基于深度优先搜索思想, 通过遍历实现; 因此, 回溯法也是一种暴力解法, 我们可以通过剪枝, 在遍历过程中将绝对不符合条件的分支即时剪去, 避免无意义的遍历, 从而降低回溯的成本 回溯法解决的问题都可以抽象为树形结构，集合的大小构成了树的宽度，递归的深度构成了树的深度，是一个高度有限的N叉树 回溯与动态规划的区别共同点用于求解多阶段决策问题; 多阶段决策问题即: 求解一个问题分为很多步骤（阶段） 每一个步骤（阶段）可以有多种选择 不同点 动态规划用于求解问题的最优解 回溯算法可以搜索得到所有的方案(包括最优解), 但是本质上它是一种遍历算法, 时间复杂度很高 回溯法解决的问题回溯法，一般可以解决如下几种问题： 组合问题：N个数里面按一定规则找出k个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个N个数的集合里有多少符合条件的子集 排列问题：N个数按一定规则全排列，有几种排列方式 棋盘问题：N皇后，解数独等等 组合和排列的区别例如：{1, 2} 和 {2, 1} 在组合上，就是一个集合，因为不强调顺序，而要是排列的话，{1, 2} 和 {2, 1} 就是两个集合了。记住组合无序，排列有序，就可以了。 回溯法模板分析过程 回溯函数模板返回值及参数 回溯算法返回值一般为空 参数不容易确定下来，所以一般先写逻辑，根据逻辑填写参数 回溯函数终止条件 回溯可以抽象成树形结构，遍历树形结构达到终止条件一般是达到叶子节点，找到满足条件的答案，把答案存储并结束本层递归 回溯搜索的遍历过程 遍历伪代码如下: 12345# python for 选择 in 本层集合中元素: 处理节点 backtrack(路径, 选择列表) 回溯，撤销处理结果 for循环就是遍历集合区间，一个节点有多少孩子，for循环就执行多少次 backtrack调用自己，实现递归 for循环是横向遍历，backtrack是纵向遍历，这样就把一棵树遍历完了 模板1234567891011# pythonresult = []def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 本层集合中元素: 处理节点 backtrack(路径, 选择列表) 回溯，撤销处理结果 例题组合问题 77. 组合 216. 组合总和 III 17. 电话号码的字母组合 39. 组合总和 40. 组合总和 II 分割问题 131. 分割回文串 93. 复原 IP 地址 子集问题 78. 子集 90. 子集 II 491. 递增子序列 排列问题 46. 全排列 47. 全排列 II 棋盘问题 51. N 皇后 37. 解数独","link":"/2022/10/11/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"title":"滑动窗口","text":"什么是滑动窗口例题 209. 长度最小的子数组 904. 水果成篮—— 题解 76. 最小覆盖子串","link":"/2022/11/17/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"title":"背包问题","text":"什么是背包问题背包问题（Knapsack problem）是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中，背包的空间有限，但我们需要最大化背包内所装物品的价值。背包问题通常出现在资源分配中，决策者必须分别从一组不可分割的项目或任务中进行选择，而这些项目又有时间或预算的限制。 01背包题目描述有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 思路分析题目 暴力解法：每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。 由题目可知 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 模板（二维dp数组） 确定dp数组以及下标的含义 对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 确定递推公式 dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。那么可以有两个方向推出来dp[i][j]不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图： 再看其他情况。 状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。 dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。 当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。 dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？ 其实从递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。 但只不过一开始就统一把dp数组统一初始为0，更方便一些。 确定遍历顺序 在如下图中，可以看出，有两个遍历的维度：物品与背包重量 先遍历物品或先遍历背包重量都可以，但先遍历物品好理解。 123456789// 先遍历物品// weight数组的大小 就是物品个数for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); }} 12345678// 先遍历背包// weight数组的大小 就是物品个数for(int j = 0; j &lt;= bagweight; j++) { // 遍历背包容量 for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品 if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); }} 虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导 举例推导dp数组 模板（一维dp数组/滚动数组） 对于背包问题其实状态都是可以压缩的。 在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 确定dp数组的定义 在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。 一维dp数组的递推公式 dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。 dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]） 此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i] 所以递推公式为： 1dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 一维dp数组如何初始化 dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。 那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？ 看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。 一维dp数组遍历顺序 代码如下： 123456for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} 这里和二维dp的写法中，遍历背包的顺序是不一样的，二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。因为倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次。 一维dp本质上是复用数组为上一层数组（i-1）原理上还是二维dp，根据递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);赋值当前值要参考dp[j - weight[i]]，即上一层的数据，如果从前往后遍历，上层的数据会被覆盖，导致背包多次放入，从后往前遍历则当前元素前的元素仍然和上一层的值相同。 因为一维dp是复用上一层数据，所以不可以先遍历背包容量嵌套遍历物品，如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。 举例推导dp数组 代码python（二维dp数组）123456789101112131415161718192021222324252627282930def test_2_wei_bag_problem(bag_size, weight, value) -&gt; int: rows, cols = len(weight), bag_size + 1 dp = [[0 for _ in range(cols)] for _ in range(rows)] # 初始化dp数组. for i in range(rows): dp[i][0] = 0 first_item_weight, first_item_value = weight[0], value[0] for j in range(1, cols): if first_item_weight &lt;= j: dp[0][j] = first_item_value # 更新dp数组: 先遍历物品, 再遍历背包. for i in range(1, len(weight)): cur_weight, cur_val = weight[i], value[i] for j in range(1, cols): if cur_weight &gt; j: # 说明背包装不下当前物品. dp[i][j] = dp[i - 1][j] # 所以不装当前物品. else: # 定义dp数组: dp[i][j] 前i个物品里，放进容量为j的背包，价值总和最大是多少。 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - cur_weight]+ cur_val) print(dp)if __name__ == &quot;__main__&quot;: bag_size = 4 weight = [1, 3, 4] value = [15, 20, 30] test_2_wei_bag_problem(bag_size, weight, value) python（一维dp数组/滚动数组）12345678910111213141516def test_1_wei_bag_problem(): weight = [1, 3, 4] value = [15, 20, 30] bag_weight = 4 # 初始化: 全为0 dp = [0] * (bag_weight + 1) # 先遍历物品, 再遍历背包容量 for i in range(len(weight)): for j in range(bag_weight, weight[i] - 1, -1): # 递归公式 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(dp)test_1_wei_bag_problem() 完全背包题目描述有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。 完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。 背包最大重量为4。 物品为： 重量 价值 物品0 1 15 物品1 3 20 物品2 4 30 每件商品都有无限个！ 问背包能背的物品最大价值是多少？ 思路遍历顺序01背包和完全背包唯一不同就是体现在遍历顺序上，01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即： 1234567// 先遍历物品，再遍历背包for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 for(int j = weight[i]; j &lt;= bagWeight ; j++) { // 遍历背包容量 dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); }} dp状态图如下： for循环嵌套01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓。 因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。 如图所示完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。 1234567// 先遍历背包，再遍历物品for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量 for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品 if (j - weight[i] &gt;= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); } cout &lt;&lt; endl;} python（一维dp数组/滚动数组）1234567891011121314151617181920212223242526272829303132# 先遍历物品，再遍历背包def test_complete_pack1(): weight = [1, 3, 4] value = [15, 20, 30] bag_weight = 4 dp = [0]*(bag_weight + 1) for i in range(len(weight)): for j in range(weight[i], bag_weight + 1): dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(dp[bag_weight])# 先遍历背包，再遍历物品def test_complete_pack2(): weight = [1, 3, 4] value = [15, 20, 30] bag_weight = 4 dp = [0]*(bag_weight + 1) for j in range(bag_weight + 1): for i in range(len(weight)): if j &gt;= weight[i]: dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(dp[bag_weight])if __name__ == '__main__': test_complete_pack1() test_complete_pack2() 多重背包题目描述有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。 多重背包和01背包是非常像的， 为什么和01背包像呢？ 每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。 背包最大重量为10。 物品为： 重量 价值 数量 物品0 1 15 2 物品1 3 20 3 物品2 4 30 2 问背包能背的物品最大价值是多少？ 和如下情况有区别么？ 重量 价值 数量 物品0 1 15 1 物品0 1 15 1 物品1 3 20 1 物品1 3 20 1 物品1 3 20 1 物品2 4 30 1 物品2 4 30 1 毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。 python12345678910111213141516171819202122232425262728293031323334353637383940414243def test_multi_pack1(): '''版本一：改变物品数量为01背包格式''' weight = [1, 3, 4] value = [15, 20, 30] nums = [2, 3, 2] bag_weight = 10 for i in range(len(nums)): # 将物品展开数量为1 while nums[i] &gt; 1: weight.append(weight[i]) value.append(value[i]) nums[i] -= 1 dp = [0]*(bag_weight + 1) # 遍历物品 for i in range(len(weight)): # 遍历背包 for j in range(bag_weight, weight[i] - 1, -1): dp[j] = max(dp[j], dp[j - weight[i]] + value[i]) print(&quot; &quot;.join(map(str, dp)))def test_multi_pack2(): '''版本：改变遍历个数''' weight = [1, 3, 4] value = [15, 20, 30] nums = [2, 3, 2] bag_weight = 10 dp = [0]*(bag_weight + 1) for i in range(len(weight)): for j in range(bag_weight, weight[i] - 1, -1): # 以上是01背包，加上遍历个数 for k in range(1, nums[i] + 1): if j - k*weight[i] &gt;= 0: dp[j] = max(dp[j], dp[j - k*weight[i]] + k*value[i]) print(&quot; &quot;.join(map(str, dp)))if __name__ == '__main__': test_multi_pack1() test_multi_pack2()","link":"/2022/10/31/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"贪心算法","text":"什么是贪心算法贪心算法（greedy algorithm，又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。 如何理解贪心算法贪心算法的设计思想贪心算法在解决问题的策略上目光短浅，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。贪心算法对于大部分的优化问题都能产生最优解，但不能总获得整体最优解，通常可以获得近似最优解。该算法存在问题： 不能保证求得的最后解是最佳的 不能用来求最大或最小解问题 只能求满足某些约束条件的可行解的范围。Dijkstra算法、Prim算法和Kruskal算法都属于典型的贪心算法 贪心算法的基本要素对于一个具体的问题，怎么知道是否可用贪心算法解此问题，以及能否得到问题的最优解呢?这个问题很难给予肯定的回答。但是，从许多可以用贪心算法求解的问题中看到这类问题一般具有2个重要的性质：贪心选择性质和最优子结构性质。子问题：假设为了解决某一优化问题，需要依次作出n个决策D1，D2，…，Dn，对于任何一个整数k，1 &lt; k &lt; n，以Dk作为问题的初始状态，来进行以后的决策，这样的问题就成为是原问题的一个子问题。 贪心选择性质：所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。 贪心算法与动态规划算法的差异大多数时候，能用贪心算法求解的问题，都可以用动态规划算法求解。但是能用动态规划求解的，不一定能用贪心算法进行求解。因为贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划。 共同点 两者都具有最优子结构性质 不同点 动态规划算法中，每步所做的选择往往依赖于相关子问题的解，因而只有在解出相关子问题时才能做出选择。而贪心算法，仅在当前状态下做出最好选择，即局部最优选择，然后再去解做出这个选择后产生的相应的子问题。 贪心算法中作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留，贪心算法每一步的最优解一定包含上一步的最优解。动态规划算法中全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解。 贪心法的适用范围贪心算法并不能总求得问题的整体最优解。但对于某些问题，却总能求得整体最优解，这要看问题时什么了。只要能满足贪心算法的两个性质：贪心选择性质和最优子结构性质，贪心算法就可以出色地求出问题的整体最优解。即使某些问题，贪心算法不能求得整体的最优解，贪心算法也能求出大概的整体最优解。如果你的要求不是太高，贪心算法是一个很好的选择。最优子结构性质是比较容易看出来的，但是贪心选择性质就没那么容易了，这个时候需要证明。证明往往使用数学归纳法。 贪心算法解决的问题 哈夫曼编码 磁盘文件的存储 生产调度问题 信息查询 活动安排问题 0-1背包问题和背包问题（knapsack problem） 算法思路 建立数学模型来描述问题 把求解的问题分成若干个子问题 对每一子问题求解，得到子问题的局部最优解 把子问题的解局部最优解合成原来解问题的一个解 例题 455. 分发饼干 53. 最大子数组和 1005. K 次取反后最大化的数组和 134. 加油站 860. 柠檬水找零 968. 监控二叉树 两个维度权衡问题 135. 分发糖果 406. 根据身高重建队列 序列问题 376. 摆动序列 738. 单调递增的数字 区间问题 55. 跳跃游戏 45. 跳跃游戏 II 45. 用最少数量的箭引爆气球 435. 无重叠区间 763. 划分字母区间 56. 合并区间 股票问题 122. 买卖股票的最佳时机 II 714. 买卖股票的最佳时机含手续费","link":"/2022/10/16/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"title":"HTTP基本概念","text":"HTTP 是什么？HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。 能否详细解释「超文本传输协议」？ HTTP的名字「超文本协议传输」，它可以拆成三个部分： 超文本 传输 协议 协议 在生活中，我们也能随处可见「协议」，例如： 刚毕业时会签一个「三方协议」； 找房子时会签一个「租房协议」； 生活中的协议，本质上与计算机中的协议是相同的，协议的特点: 「协」字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。 「议」字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。 针对 HTTP 协议，我们可以这么理解。 HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。 传输 所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。 别轻视了这个简单的动作，它至少包含两项重要的信息。 HTTP 协议是一个双向协议。 我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。 数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。 就好像第一排的同学想传递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; — &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。 而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。 针对传输，我们可以进一步理解了 HTTP。 HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 超文本 HTTP 传输的内容是「超文本」。 我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算作「文本」。 再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。 HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。 OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案： HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。 那HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议 ，这种说法正确吗？ 这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确。 HTTP常见的状态码有哪些？ 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。 2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。 「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。 3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。 「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。 301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。 5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。 「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。 「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。 「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。 HTTP常见字段有哪些？Host 字段客户端发送请求时，用来指定服务器的域名。 1Host: www.A.com 有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站。 Content-Length 字段 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。 1Content-Length: 1000 如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。 大家应该都知道 HTTP 是基于 TCP 传输协议进行通信的，而使用了 TCP 传输协议，就会存在一个“粘包”的问题，HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。具体什么是 TCP 粘包，可以看这篇文章：如何理解是 TCP 面向字节流协议？(opens new window) Connection 字段Connection 字段最常用于客户端要求服务器使用「 HTTP 长连接」机制，以便其他请求复用。 HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive。 1Connection: Keep-Alive 开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。 PS：大家不要把 HTTP Keep-Alive 和 TCP Keepalive 搞混了，这两个虽然长的像，但是不是一个东西，具体可以看我这篇文章：TCP Keepalive 和 HTTP Keep-Alive 是一个东西吗？(opens new window) Content-Type 字段Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。 1Content-Type: text/html; charset=utf-8 上面的类型表明，发送的是网页，而且编码是UTF-8。 客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。 1Accept: */* 上面代码中，客户端声明自己可以接受任何格式的数据。 Content-Encoding 字段Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式 1Content-Encoding: gzip 上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。 客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。 1Accept-Encoding: gzip, deflate","link":"/2022/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"TCP-IP网络模型有哪几层？","text":"为什么要有 TCP/IP 网络模型？ 对于同一台设备上的进程间通信，有很多种方式，比如有管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套通用的网络协议。 这个网络协议是分层的，每一层都有各自的作用和职责，接下来就根据「 TCP/IP 网络模型」分别对每一层进行介绍。 应用层最上层的，也是我们能直接接触到的就是应用层（Application Layer），我们电脑或手机使用的应用软件都是在应用层实现。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。 所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。 应用层是不用去关心数据是如何传输的，就类似于，我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。 而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。 传输层应用层的数据包会传给传输层，传输层（Transport Layer）是为应用层提供网络支持的。 在传输层会有两个传输协议，分别是 TCP 和 UDP。 TCP 的全称叫传输控制协议（Transmission Control Protocol），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证数据包能可靠地传输给对方。 UDP 相对来说就很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。 应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）。 TCP 在建立连接的时候，会协商双方的MSS值，通常这个 MSS 会控制在 MTU 以内：最大 IP 包大小减去 IP 和 TCP 协议头的大小。（其最终目的：就是尽量避免 IP 分片） 这样 TCP 就可以在自己这一层，把用户发送的数据，预先分成多个大小限制在 MTU 里的 TCP 包。每个 TCP 的分片包，都完整了包含了 TCP 头信息，方便在接收方重组。 当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是端口。 比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。 由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。 网络层传输层可能大家刚接触的时候，会认为它负责将数据从一个设备传输到另一个设备，事实上它并不负责。 实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。 也就是说，我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是网络层（Internet Layer）。 网络层最常使用的是 IP 协议（Internet Protocol），IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。 对于UDP来说，它并没有协商的能力，所以它只能直接把用户发送的数据，传给网络层（IP层），由网络层来进行分片。 对 网络层（IP层）来说：它并不知道上层传过来的数据，到底是 TCP 还是 UDP，它并不关心这个东西，也没有能力去区分。 如果发现数据过大，那么 IP 层会自动对数据进行切割，分片。 网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。 我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。 因此，需要将 IP 地址分成两种意义： 一个是网络号，负责标识该 IP 地址是属于哪个「子网」的； 一个是主机号，负责标识同一「子网」下的不同主机； 怎么分的呢？这需要配合子网掩码才能算出 IP 地址 的网络号和主机号。 举个例子，比如 10.100.122.0/24，后面的/24表示就是 255.255.255.0 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。 知道了子网掩码，该怎么计算出网络地址和主机地址呢？ 将 10.100.122.2 和 255.255.255.0 进行按位与运算，就可以得到网络号，如下图： 将 255.255.255.0 取反后与IP地址进行进行按位与运算，就可以得到主机号。 大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。 那么在寻址的过程中，先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机。 除了寻址能力， IP 协议还有另一个重要的能力就是路由。实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。 路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。 所以，IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘。 网络接口层生成了 IP 头部之后，接下来要交给网络接口层（Link Layer）在 IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上。 IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。 什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。 以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在以太网进行通讯要用到 MAC 地址。 MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址。 所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。 总结综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是应用层，传输层，网络层和网络接口层。 再给大家贴一下每一层的封装格式： 网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。","link":"/2022/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%9C%89%E5%93%AA%E5%87%A0%E5%B1%82/"},{"title":"Go的诞生与哲学","text":"Go语言的诞生背景2007年9月20日的下午，在谷歌山景城总部的一间办公室里，谷歌的大佬级程序员Rob Pike启动了一个C++工程的编译构建。按照以往的经验判断，这次构建大约需要一个小时。利用这段时间，Rob Pike与谷歌的另两个大佬级程序员Robert Griesemer和Ken Thompson进行了一次有关设计一门新编程语言的讨论，而这次讨论成为Go语言诞生的“导火索”。 初衷当时的谷歌内部主要使用C++语言构建各种系统，但C++复杂性高，编译构建速度慢，在编写服务端程序时不便支持并发。诸如此类的一些问题让三位大佬产生了设计一门新编程语言的想法。在他们的初步构想中，这门新语言应该是能够给程序员带来快乐、匹配未来硬件发展趋势并适合用来开发谷歌内部大规模程序的。 思路在C语言的基础上，修正一些明显的缺陷，删除一些被诟病较多的特性，增加一些缺失的功能。具体功能和特性如下。 使用import替代include。去掉宏（macro）。 理想情况是用一个源文件替代.h和.c文件，模块的接口应该被自动提取出来（而无须手动在.h文件中声明）。 语句像C语言一样，但需要修正switch语句的缺陷。表达式像C语言一样，但有一些注意事项（比如是否需要逗号表达式）。 基本上是强类型的，但可能需要支持运行时类型。数组应该总是有边界检查。具备垃圾回收的机制。 支持接口（interface）。支持嵌套和匿名函数/闭包。一个简单的编译器。各种语言机制应该能产生可预测的代码。 这封电邮成为这门新语言的第一版设计稿，三位大佬在这门语言的一些基础语法特性上初步达成一致。 ”杀手级“应用在Go开源后，一些技术公司，尤其是云计算领域的大厂以及初创公司，成为Go语言的早期接纳者。经过若干年的磨合，在这些公司中诞生了众多“杀手级”或示范性项目，如容器引擎Docker、云原生事实标准平台Kubernetes、服务网格Istio、区块链公链以太坊（Ethereum）、联盟链超级账本（Hyperledger Fabric）、分布式关系型数据库TiDB和CockroachDB、云原生监控系统Prometheus等。这些项目也让Go被誉为“云计算基础设施编程语言”。Go在近些年云原生领域的广泛应用也让其跻身云原生时代的头部编程语言。 Go语言哲学 追求简单，少即是多 简洁、常规的语法（不需要解析符号表），它仅有25个关键字； 内置垃圾收集，降低开发人员内存管理的心智负担； 没有头文件； 显式依赖（package）； 没有循环依赖（package）； 常量只是数字； 首字母大小写决定可见性； 任何类型都可以拥有方法（没有类）； 没有子类型继承（没有子类）； 没有算术转换； 接口是隐式的（无须implements声明）； 方法就是函数； 接口只是方法集合（没有数据）； 方法仅按名称匹配（不是按类型）； 没有构造函数或析构函数； n++和n–是语句，而不是表达式； 没有++n和–n；赋值不是表达式； 在赋值和函数调用中定义的求值顺序（无“序列点”概念）； 没有指针算术； 内存总是初始化为零值； 没有类型注解语法（如C++中的const、static等）； 没有模板/泛型； 没有异常（exception）； 内置字符串、切片（slice）、map类型； 内置数组边界检查；内置并发支持； … 偏好组合，正交解耦 C++、Java等主流面向对象语言通过庞大的自上而下的类型体系、继承、显式接口实现等机制将程序的各个部分耦合起来，但在Go语言中我们找不到经典面向对象的语法元素、类型体系和继承机制，或者说Go语言本质上就不属于经典面向对象语言范畴。 原生并发，轻量高效 Go语言采用轻量级协程并发模型，使得Go应用在面向多核硬件时更具可扩展性 Go语言为开发者提供的支持并发的语法元素和机制 并发原则对Go开发者在程序结构设计层面的影响 面向工程，“自带电池”","link":"/2022/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/Go%E7%9A%84%E8%AF%9E%E7%94%9F%E4%B8%8E%E5%93%B2%E5%AD%A6/"},{"title":"进程","text":"进程和程序进程的非正式定义非常简单：进程就是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。 操作系统如何提供有许多CPU假象？操作系统通过虚拟化（virtualizing）CPU来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。这就是时分共享（time sharing）CPU技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果CPU必须共享，每个进程的运行就会慢一点。 进程的组成部分 进程的机器状态有一个明显组成部分，就是它的内存。指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分。 进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器，因此显然，它们对于执行该进程很重要。 请注意，有一些非常特殊的寄存器构成了该机器状态的一部分。例如，程序计数器（Program Counter，PC）（有时称为指令指针，Instruction Pointer或IP）告诉我们程序当前正在执行哪个指令；类似地，栈指针（stack pointer）和相关的帧指针（frame pointer）用于管理函数参数栈、局部变量和返回地址。 最后，程序也经常访问持久存储设备。此类I/O信息可能包含当前打开的文件列表。 进程的创建过程 操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。程序最初以某种可执行格式驻留在磁盘上（disk，或者在某些现代系统中，在基于闪存的SSD上）。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处）。 将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操作。必须为程序的运行时栈（run-time stack或stack）分配一些内存。操作系统也可能为程序的堆（heap）分配一些内存。 操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。 例如，在UNIX系统中，默认情况下每个进程都有3个打开的文件描述符（file descriptor），用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。 最后一项任务：启动程序，在入口处运行，即main()。 进程状态 运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。 就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。 阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起I/O请求时，它会被阻塞，因此其他进程可以使用处理器。 有时候系统会有一个初始（initial）状态，表示进程在创建时处于的状态。另外，一个进程可以处于已退出但尚未清理的最终（final）状态（在基于UNIX的系统中，这称为僵尸状态）。 这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于UNIX的系统中，程序成功完成任务时返回零，否则返回非零）。完成后，父进程将进行最后一次调用（例如，wait()），以等待子进程的完成，并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构。 如何高效、可控地虚拟化CPU 在构建虚拟化机制时存在一些挑战。第一个是性能：如何在不增加系统开销的情况下实现虚拟化？第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？ 受限直接执行我们采用的方法是引入一种新的处理器模式，称为用户模式（user mode）。在用户模式下运行的代码会受到限制。与用户模式不同的内核模式（kernel mode），操作系统（或内核）就以这种模式运行。在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出I/O请求和执行所有类型的受限指令。 要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。 陷阱如何知道在OS内运行哪些代码？内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时要运行哪些代码。 我们假设每个进程都有一个内核栈，在进入内核和离开内核时，寄存器（包括通用寄存器和程序计数器）分别被保存和恢复。 参考：用户栈和内核栈的区别、用户栈与系统栈的区别 如何重获CPU的控制权 直接执行的下一个问题是实现进程之间的切换。如果一个进程在CPU上运行，这就意味着操作系统没有运行。操作系统如何重新获得CPU的控制权（regain control），以便它可以在进程之间切换？ 协作方式：等待系统调用 操作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务。 如果应用程序执行了某些非法操作，也会将控制转移给操作系统。例如，如果应用程序以0为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制CPU（并可能终止违规进程）。 如果某个进程（无论是恶意的还是充满缺陷的）进入无限循环，并且从不进行系统调用，会发生什么情况？那时操作系统能做什么？ 非协作方式：操作系统进行控制 时钟中断（timer interrupt）。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。 即使进程以非协作的方式运行，添加时钟中断（timer interrupt）也让操作系统能够在CPU上重新运行。因此，该硬件功能对于帮助操作系统维持机器的控制权至关重要。 请注意，硬件在发生中断时有一定的责任，尤其是在中断发生时，要为正在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复正在运行的程序。这一组操作与硬件在显式系统调用陷入内核时的行为非常相似，其中各种寄存器因此被保存（进入内核栈），因此从陷阱返回指令可以容易地恢复。 上下文切换既然操作系统已经重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断更强制执行，都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。如果决定进行切换，OS就会执行一些底层代码，即所谓的上下文切换（context switch）。 上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。 请注意，在此协议中，有两种类型的寄存器保存/恢复。第一种是发生时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从A切换到B。在这种情况下，内核寄存器被软件（即OS）明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由A陷入内核，变成好像刚刚由B陷入内核。","link":"/2022/11/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B/"},{"title":"为什么我们误把渴望当幸福？","text":"核心思想核心思想：我们的大脑错把奖励的承诺当做快乐的保证，所以，我们会从不可能带来满足的事物中寻找满足感。 深入剖析 是什么让你的多巴胺神经元不停燃烧？是什么给了你奖励的承诺，迫使你去寻找满足感？ 神经营销学和环境的刺激。观察一下零售商和营销人员如何刺激奖励的承诺。 渴望的压力。注意观察，欲望是如何引发压力和焦虑的。 意志力实验 为了你的“我要做”挑战释放多巴胺。如果你总是拖延着不做某些事，试着把它和那些能让你的多巴胺神经元燃烧的事联系在一起，促使你自己去做那些事。 测试奖励的承诺。做那些大脑告诉你你会快乐、但似乎无法让你满足的事，比如吃零食、购物、电视以及与网络相关的、浪费时间的事，注意观察自己放纵时的感受。现实和大脑的承诺相符吗？","link":"/2022/11/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%AF%AF%E6%8A%8A%E6%B8%B4%E6%9C%9B%E5%BD%93%E5%B9%B8%E7%A6%8F%EF%BC%9F/"},{"title":"出售未来","text":"核心思想核心思想：我们无法明确地预知未来，这为我们带来了诱惑，让我们拖延着不做某些事。 深入剖析 你给未来的奖励打了几折？在你的意志力挑战中，每当你屈服于诱惑或拖延的时候，你会出售哪些未来的奖励？ 你在等待未来的自己吗？你是否在推迟重要的改变或任务，等待自控力更强的未来的自己出现？ 为了你自己好，你是否太“高瞻远瞩”了？你是否觉得放纵自己比抵抗诱惑还困难？ 意志力实验 等待10分钟。在诱惑面前强制安排10分钟的等待时间。在这10分钟里，一定要时刻想着长远的奖励，抵制住诱惑。 降低你的折扣率。当你受到诱惑，要做和长期利益相悖的事情时，请想一想，这个选择意味着，你为了即时的满足感放弃了更好的长期奖励。 预先对未来的自己作出承诺。作好拒绝诱惑的准备，让改变偏好变得更难，用奖励或威胁来激励未来的自己。 预见未来的自己。创造一个未来的记忆，给未来的自己发条信息，想象一下未来的自己。","link":"/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E5%87%BA%E5%94%AE%E6%9C%AA%E6%9D%A5/"},{"title":"容忍罪恶","text":"核心思想核心思想：当我们将意志力挑战看成衡量道德水平的标准时，善行就会允许我们做坏事。为了能更好地自控，我们需要忘掉美德，关注目标和价值观。 深入剖析 善与恶：当你的意志力挑战成功时，你会不会告诉自己你很“好”，然后允许自己做一些“坏”事？ 你是否在向明天赊账？你是不是告诉自己明天会弥补今天的过错？如果是这样的话，你是否真的弥补上了？光环效应：你是不是只看到了坏东西好的一面，如折扣省钱、零脂肪、保护环境？ 你觉得自己是谁？当你想到你的意志力挑战时，你觉得哪部分的你才是“真实”的你？是想追求目标的你，还是需要被控制的你？ 意志力实验 明天和今天毫无区别。当你想改变行为的时候，试着减少行为的变化性，而不是减少某种行为。 取消许可，牢记理由。下一回，当你发现自己在用曾经的善行为放纵辩护的时候，停下来想一想你做“好”事的原因，而不是你应不应该得到奖励。","link":"/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E5%AE%B9%E5%BF%8D%E7%BD%AA%E6%81%B6/"},{"title":"意志力的本能","text":"核心思想核心思想：意志力是种生理本能，它和压力一样，通过不断进化来保护我们不受自身伤害。 深入剖析 什么是威胁？对你的意志力挑战来说，什么是需要克制的内在冲动？ 压力和自控。试着找出持续一整天或一整周的压力，看看它对你的自控力产生怎样的影响。你有过强烈的欲望吗？你发脾气了吗？你把要做的事拖到了明天吗？ 意志力实验 呼吸出你的自控力。把你的呼吸降到每分钟4-6次，将身体调整到适合自控的生理状态。 5分钟给意志力加油。出门活动，哪怕只是在周围转转，也能减少压力、改善心情、提供动力。 睡眠。打盹或补觉可以消除睡眠不足的影响。 放松能让你恢复意志力储备。躺下，深呼吸，让“放松的生理反应”帮你从自控和压力造成的疲惫中恢复过来。","link":"/2022/11/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E6%84%8F%E5%BF%97%E5%8A%9B%E7%9A%84%E6%9C%AC%E8%83%BD/"},{"title":"我要做，我不要，我想要","text":"“我要做”“我不要”和“我想要”选择一个意志挑战 “我要做”意志力挑战：有没有什么事是你想多做一些的，或是停止拖延的，因为你知道这样做能提高你的生活质量？ “我不要”意志力挑战：你生活中最“顽固”的习惯是什么？有什么是你想放弃，或者想少做一点的，因为它妨害了你的健康、幸福甚至成功？ “我不要”意志力挑战：你生活中最“顽固”的习惯是什么？有什么是你想放弃，或者想少做一点的，因为它妨害了你的健康、幸福甚至成功？ 明确自己的目标“我要做”和“我不要”是自控的两种表现，但它们不是意志力的全部。要想在需要“说不”时“说不”，在需要“说好”时“说好”，你还得有第三种力量：那就是牢记自己真正想要的是什么。你没准会说，我真正想要的是巧克力蛋糕，是再喝一杯酒，是好好休个假。但当你面对诱惑和拖延症时，你得想清楚，你真正想要的，其实是变得苗条、升职加薪、不要欠债、家庭美满、远离监狱。只有想到这些，才能遏制你的一时冲动。想要做到自控，你就得在关键时刻明确自己的目标。这就是“我想要”的力量。意志力就是驾驭“我要做”、“我不要”和“我想要”这三种力量。 “我要做”“我不要”和“我想要”的神经学原理斯坦福大学的神经生物学家罗伯特·萨博斯基（Robert Sapolsky）认为，现代人大脑里前额皮质的主要作用是让人选择做“更难的事”。如果坐在沙发上比较容易，它就会让你站起来做做运动。如果吃甜品比较容易，它就会提醒你要杯茶。如果把事情拖到明天比较容易，它就会督促你打开文件，开始工作。 前额皮质并不是挤成一团的灰质，而是分成了三个区域，分管“我要做”“我不要”和“我想要”三种力量。前额皮质的左边区域负责“我要做”的力量。它能帮你处理枯燥、困难或充满压力的工作。比如，当你想冲个澡的时候，它会让你继续待在跑步机上。右边的区域则控制“我不要”的力量。它能克制你的一时冲动。比如，你开车时没有看短信，而是盯着前方的路面，就是这个区域的功劳。以上两个区域一同控制你“做什么”。 第三个区域位于前额皮质中间靠下的位置。它会记录你的目标和欲望，决定你“想要什么”。这个区域，的细胞活动越剧烈，你采取行动和拒绝诱惑的能力就越强。即便大脑的其他部分一片混乱，向你大叫“吃这个！喝那个！抽这个！买那个！”这个区域也会记住你真正想要的是什么。 两个自我两个自我导致的问题有些神经学家甚至认为，我们只有一个大脑，但我们有两个想法。或者说，我们的脑袋里有两个自我。一个自我任意妄为、及时行乐，另一个自我则克服冲动、深谋远虑。我们总是在两者之间摇摆不定，有时觉得自己想减肥，有时觉得自己想吃饼干。因此，我们可以这样来定义意志力的挑战——你一方面想要这个，一方面想要那个。当下的你想要这个，但如果不要的话，你未来的生活会更好。两个自我发生分歧的时候，总会有一方击败另一方。决定放弃的一方并没有做错，只是双方觉得重要的东西不同而已。 两个自我的价值虽然原始冲动并不总对我们有利，但想彻底摆脱它也是不对的。医学上曾研究过因脑部受损而失去本能的人。研究者发现，对于健康、幸福和自控力来说，原始的恐惧和欲望至关重要。如果没有了欲望，人们就会变得沮丧；如果没有了恐惧，人们就没法保护自己、远离伤害。在意志力挑战中获胜的关键，在于学会利用原始本能，而不是反抗这些本能。神经经济学家是一群研究人们决策时大脑活动的科学家。他们发现，自控系统和生存本能并不总会发生冲突。在某些时候，它们会相互协作，帮我们作出更好的选择。 意志力意志力第一法则：认识你自己自控力是人类最与众不同的特征之一。此外，人类还拥有自我意识。当我们做一件事的时候，我们能意识到自己在做什么，也知道我们为什么这样做。但愿我们还能知道，在做这件事情之前我们需要做些什么，这样我们就会三思而后行。 如果没有自我意识，自控系统将毫无用武之地。在作决定的时候，你必须意识到自己此刻需要意志力。否则，大脑总会默认选择最简单的。想戒烟的人需要第一时间意识到自己吸烟的冲动，也要知道哪里会让他有这种冲动（比如在室外、寒冷的环境里或摆弄打火机的时候）。他还得知道，如果自己这次投降了，明天很有可能会继续吸烟，未来很可能会疾病缠身。为了避免厄运降临，他必须有意识地戒烟。要是没有自我意识，他就完蛋了。 现代社会充斥着诱惑和刺激，不断冲击着人们的自控力。巴巴·史乌（Baba Shiv）向我们证明了，注意力分散的人更容易向诱惑屈服。如果你心里在想其他事，那么冲动就会主导你的选择。如果你想有更强的自控力，就得有更多的自我意识。 训练大脑，增强意志力神经学家发现，如果你经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你集中注意力、管理压力、克制冲动和认识自我的能力。一段时间之后，你的大脑就会变成调试良好的意志力机器。在你的前额皮质和影响自我意识的区域里，大脑灰质都会增多。 研究发现，经过仅仅3个小时的冥想练习，他们的注意力和自控力就有大幅提高。11个小时后，研究人员已经能观察到大脑的变化。刚学会冥想的人大脑里负责控制注意力、排除干扰、控制冲动的区域之间增加了许多类神经元。另一项研究发现，持续8周的日常冥想训练可以提升人们日常生活中的自我意识，相应大脑区域里的灰质也会随之增多。 意志力实验：5分钟训练大脑冥想 原地不动，安静坐好。 注意你的呼吸。 感受呼吸，弄清自己是怎么走神的。 刚开始的时候，你每天锻炼5分钟就行。习惯成自然之后，请试着每天做10-15分钟。如果你觉得有负担，那就减少到5分钟。每天做比较短的训练，也比把比较长的训练拖到明天好。这样，你每天都会有一段固定的时间冥想，比如早晨洗澡之前。如果你做不到，可以对时间进行适当的调整。 冥想不是让你什么都不想，而是让你不要太分心，不要忘了最初的目标。如果你在冥想时没法集中注意力，别担心。你只需多做练习，将注意力重新集中到呼吸上。","link":"/2022/11/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E6%88%91%E8%A6%81%E5%81%9A%EF%BC%8C%E6%88%91%E4%B8%8D%E8%A6%81%EF%BC%8C%E6%88%91%E6%83%B3%E8%A6%81/"},{"title":"自控力有极限","text":"核心思想核心思想：自控力就像肌肉一样有极限。自控力用得太多会疲惫，但坚持训练能增强自控力。 深入剖析 意志力的上下波动。本周，记录你的自控力，特别注意什么时候你的意志力最强，什么时候你最容易放弃。 你的疲惫感是真的吗？下次你觉得自己太“疲惫”而无法自控的时候，看看自己能不能挺过第一波疲惫的感觉，向前迈出一步。 意志力实验 你的疲惫感是真的吗？下次你觉得自己太“疲惫”而无法自控的时候，看看自己能不能挺过第一波疲惫的感觉，向前迈出一步。 你的疲惫感是真的吗？下次你觉得自己太“疲惫”而无法自控的时候，看看自己能不能挺过第一波疲惫的感觉，向前迈出一步。 发现你的“我想要”的力量。发现自己最重要的“我想要”的力量，也就是你脆弱的时候给你动力的东西。每当你面对诱惑、想要放弃的时候，都想一想这个东西。","link":"/2022/11/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E8%87%AA%E6%8E%A7%E5%8A%9B%E6%9C%89%E6%9E%81%E9%99%90/"},{"title":"那又如何","text":"核心思想核心思想：情绪低落会使人屈服于诱惑，摆脱罪恶感会让你变得更强大。 深入剖析 缓解压力的承诺。当你面临压力、感到焦虑或情绪低落时，你会怎么解决？ 什么吓到了你？注意那些从媒体、网络或其他渠道听到或看到的压力因素。 遭遇挫折。当意志力失效的时候，你会产生罪恶感并责备自己吗？ 决定改善心情。你会用幻想未来的自己来改善现在的心情，而不是采取实际行动来改善自己的行为吗？ 意志力实验 有效的解压方法。下一回，当你面临巨大的压力时，尝试一种有效的解压方法，例如锻炼身体或参加体育活动、祈祷或参加宗教活动、阅读、听音乐、花时间和家人朋友在一起、按摩、外出散步、冥想或做瑜伽，以及培养其他有创造性的爱好。 失败的时候，请原谅自己。面对自己的挫折，持同情自我的态度，以免罪恶感让你再次放弃抗争。 乐观的悲观主义者更有可能成功。预测你什么时候、会怎样受到诱惑和违背承诺，想象一个不让自己放弃抗争的具体方法。","link":"/2022/11/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%87%AA%E6%8E%A7%E5%8A%9B/%E9%82%A3%E5%8F%88%E5%A6%82%E4%BD%95/"},{"title":"GDP","text":"什么是GDPGDP就是国内生产总值，它是指一个国家或地区的所有常住单位在一定时期内（通常为一年）所生产和提供的最终产品和劳务的价值总和。 如何计算GDP第一种方法：生产法GDP = 各部分增加值之和 增加值 = 总产出 – 中间投入 第二种方法：收入法GDP = 固定资产折旧 + 劳动者报酬 + 生产税净额 + 营业盈余 从收入的角度看，GDP由四块构成：第一块是固定资产折旧。例如，当一个人投资企业时，投资购买了100万元固定资产，年折旧率是10%，每年就有10万元的折旧费，国家资产也是这样，所以GDP的第一块是固定资产折旧；第二块是劳动者报酬，这是给工人、农民等所有劳动者的工资；第三块是政府的净税收，也就是国民交的税，由政府支配的部分；第四块是企业盈余，也就是企业家盈利的部分。政府把蛋糕分成四块，构成不同人群的收入，这种计算GDP的方法就叫收入法。 第三种方法：支出法GDP = 总消费 + 总投资 + 净出口（出口 – 进口） 根据支出法公式可知，拉动一国经济增长有三驾马车：总消费、总投资、净出口。要做大一国的经济总量，增强一国的经济实力，政府就要在这三驾马车上下功夫。如果三驾马车都跑起来，该国的经济发展速度就会加快，只要有一驾马车倒下，经济发展就会放慢速度。 现实中应用最多的是支出法，GDP的一部分被人们拿去消费了，另一部分被用于投资。但在经济总量的计算中，还要考虑流往国外和从国外流入的部分。也就是说，外国人购买了我国的产品，算中国出口，需要记入中国的GDP。为什么出口也算中国的GDP？原因是当我们把产品出口到国外，外国人购买了我国的产品，外汇就流入我国的企业，我国的蛋糕就做大了。但我国进口别国商品时，同样也做大了他国的蛋糕。所以在计算GDP时，要计算净出口，即出口减进口。GDP分成三块：总消费、总投资、净出口，这三块构成了GDP的总量。 GDP的应用价值GDP说起来宏大而抽象，它却有非常现实的应用价值。通过GDP指标，我们可以计算很多数据，比如消费率、投资率、增长率等。我国政府宏观调控政策的出台就是看这个指标，如果增长率向下，说明经济下行了，需要宏观政策的调整，如果出口减少，就需要政策的刺激。","link":"/2022/10/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/GDP/"},{"title":"中国的分税制","text":"我国财税体制改革过程 1949年以后，我国财政采取的是“统收统支”，也就是说国有企业赚了多少钱全部上交国库，所有的支出再由政府拨下来，中央政府是统一收入、统一支出。 20世纪80年代以后，我国财税制度进行了三步改革：第一步改革是“利改税”，就是把所有国有企业上交的利润改成税收，不管是民营企业还是国有企业，一律要缴税，外资企业也不例外；第二步改革是“拨改贷”，就是以前给国有企业的拨款都改成了银行贷款；第三步改革是“统改包”，就是把过去的“统收统支”改成了中央政府和地方政府财政之间的“包干制”。地方收上税来后，定好一个基数给中央政府，余下的由地方政府自己支配。 1994年我国进行了一次大型财税体制改革，但没改革怎样把钱支出去。比如，我国建立了企业所得税、个人所得税制度，统一了内外资企业的税率等，而且实行了分税制，把税收的权限分开了。应该说，这场改革之后，我国中央财政和地方财政收入都在增长，政府宏观调控的能力增强了。 我国的分税制 分税制是我国现行的税制。所谓分税制是指中央政府和地方政府分开征税，一个是中央税，一个是地方税，还有一个是共享税。税收的人事权也分开了，有一个国税局和一个地税局，国税局替中央政府收税，地税局替地方政府收税。形成两套税收班子，2018年合并成新税务局统一挂牌。 当时的设想是，中央政府收那些好收的税，地方政府收那些难收的税。中央政府收的税由国税局完成，成立一个地税局来收地方税。比较大的税种由国家来收，比较小的税种由地方政府去收。什么是大税种呢？比如关税就是大税种，还有金融企业所得税，这些都属于中央税。 1994年的这次改革明确了中央和地方的支出原则。中央政府承担全国性的支出，地方政府承担本地区的发展支出。 我国的税制采用的是累进制，就是随着收入的提高，税率在不断提高，多赚钱就多缴税。其中也有一部分是按比例缴税。 分税制带来了哪些问题 地方财政苦乐不均，有的地方富，有的地方穷。中央财政现在每年都会拨给贫困地区很多钱，支援它们的发展。尽管如此，这些地区还是很困难，它们没有钱去发展，我国的中西部地区与东部沿海地区在财政收入水平上有一定差距。这些地区财政收入少，到了要支出时捉襟见肘。 我国1994年的财税体制改革，只在怎么把钱收上来的问题上做了改革，没有在怎么把钱支出上做改革。因为财政支出改革，涉及的各方利益太大了，它是在地方政府和中央政府之间做利益划分。 教育资源不平衡。当前，我国中小学教育是由地方财政来支出的。当地方财政钱不够时，中央财政再补助。这样一来，富裕地区政府有钱，那里的办学条件就会好一些，贫困地区政府钱不够，就会有失学儿童。有失学儿童的时候，中央政府就得管，否则就会出现教育不公平等现象。有些地方办希望小学，就是地方财政经费不足导致的。 个人所得税归属。当前，我国个人所得税属于地税。但随着经济发展和人们收入水平的不断提高，个人所得税会成为一个大税种。这一观点早已被西方发达国家的实践证明，西方国家的个人所得税占税收的比重很大。现在中国的个人所得税也正在变成一个大税种。 土地出让金的问题。在1994年财税体制改革时，中央政府以为土地出让金是一笔小数目，就把它划归地方政府。没想到土地出让金变得越来越大，由于商品房的出现，卖地成了地方政府的大收入，这造成了我国现在是土地财政，越穷的地方盖的楼越多。试问，如果地方政府没地可卖时，那财政支出怎么办？因此我国一定会推出房地产税。 我国未来会推出什么税 房地产税，目前国家正在研究中。未来一定会征收，这是为了解决地方政府财政收入的来源问题。 遗产税，西方各国政府都有征收，中国眼下还没有开始征收，但未来也一定会征收遗产税。为的是不让贫富在下一代转移，让每个人不因为出生在富裕家庭就不去奋斗。遗产税可以打破阶层的固化，让每个人都有机会成功。但遗产税推出需要时间，就像房地产税推出也需要时间一样。","link":"/2022/10/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E4%B8%AD%E5%9B%BD%E7%9A%84%E5%88%86%E7%A8%8E%E5%88%B6/"},{"title":"市场失灵","text":"市场会失灵吗？现在人们普遍接受亚当·斯密的经济理论，靠的是市场那只“看不见的手”。亚当·斯密说，政府别干预经济，价格机制本身就能调节经济。看价格就知道，赚钱的事我们会做，赔钱的事我们不做；对我们有利的事会做，对我们没利的事不做。可是，当河流被污染，山林被砍伐，当孩子们需要学校，出行者需要道路，当贫困山区的人们生活困难，当失业下岗的人揭不开锅时，市场是无法应对的，这就是市场失灵。特别是经济大萧条的来临，显示了市场之手的无助。人们发现，原来有些事情是市场不能做的，市场在某些方面存在失灵。 经济中的外部性市场失灵的第一个方面：经济中的外部性。什么叫外部性？就是一个人做了一件事，他对这件事的后果不负任何责任，他做了坏事不受惩罚，做了好事也得不到补偿，这就是经济中的外在性。当存在外在性时，市场解决不了它，价格也影响不了它。 经济中负的外部性比比皆是，一些人的行为损害了其他人的利益，但他们并不为此付费。当人们做出巨大贡献时，市场并没有对他们进行补偿，这是经济中正的外部性，也是市场机制不能解决的。所以，无论是正的外部性还是负的外部性，都是市场机制不能解决的。 公共物品的缺失经济生活中，还有一种情形也是市场机制不能解决的，那就是公共物品的缺失。从需求看，人们对公共物品的需求越来越多，如果有人提供了公共物品，使用时没人交费，大家都想免费使用，那么生产者和消费者之间的链条就断掉了，市场就失灵了。 收入分配不公平收入分配不公也是市场机制解决不了的。市场只能解决效率问题，让经济快速发展，但不能解决公平问题。这是市场失灵的又一种表现。收入分配不公平只能由政府解决，政府向高收入人群多征税，给低收入的人发放生活救济金，给予补助，让穷人也能过上温饱的日子。这就是我国政府目前正在做的脱贫计划。 政府扮演的经济角色 稳定经济 提供公共服务 提供公平竞争的条件 解决收入再分配的问题","link":"/2022/10/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E5%B8%82%E5%9C%BA%E5%A4%B1%E7%81%B5/"},{"title":"看得见的手","text":"看不见的手英国经济学家亚当·斯密，在1776年写了一本书《国富论》，书中提出了一只“看不见的手”指的是价格机制。他建议政府不要干预经济，让价格机制发挥作用，经济自然会达到平衡。亚当·斯密的这个思想统治了资本主义世界长达150年之久。在这么长的时间里，人们用斯密的理论管理国家——政府不干预经济，让经济自由发展，而政府只做一个守夜人。 看得见的手1929年，一场席卷世界的经济危机爆发了。危机首先从美国开始，股市崩盘、企业破产、银行倒闭、工人失业、经济陷入大萧条，很快就波及整个世界，各国都陷入经济大萧条中。当世人都束手无策时，英国又有一个伟大的经济学家出现了，他叫约翰·梅纳德·凯恩斯。他在1936年出版了一本书，书名叫《就业、利息和货币通论》，我们简称为《通论》。这本书可以称为经济学历史上一个重要里程碑。凯恩斯说，在经济萧条、股市低迷、失业严重的时候，你们都没有招了。但我有招，我的这个招就叫“看得见的手”。我们说，国家干预经济生活的历史是从凯恩斯开始的，宏观经济学可以说是凯恩斯开创的。经济学理论也从微观开始走向宏观，从个量分析走向总量分析。从凯恩斯开始，经济学产生了两个分支，即微观经济学和宏观经济学。 凯恩斯讲过一个著名的“挖坑理论”：雇200人挖坑，再雇200人把坑填上，这叫创造就业机会。雇200人挖坑时，需要发200把铁锹和200份干粮，这样钢材、木材和粮食需求就被拉动了。再雇200人把坑填上时，还需要发200把铁锹和200份干粮，钢材、木材和粮食的需求又被拉动了。凯恩斯举这个例子是想说明，当一国经济萧条时，政府不是没办法，政府应该出来做点事儿。用这只“看得见的手”，通过赤字和发行国债的方式把经济从大萧条中拉出来。因此，我们说“看得见的手”就是国家对经济的宏观调控。政府没钱但可以发行国债，用来刺激经济回升。","link":"/2022/10/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E7%9C%8B%E5%BE%97%E8%A7%81%E7%9A%84%E6%89%8B/"},{"title":"经济中的平衡","text":"凯恩斯的简单模型 经济学家凯恩斯说，宏观经济太复杂了，涉及的内容太多了，让我来设计一个模型吧。把一国复杂的宏观经济部门抽象出来，用一个模型来表示，大家一看就明白。这就是凯恩斯的简单模型。为什么叫简单模型呢？就是不考虑利率的变化，假定利率不变。 凯恩斯说，一国的宏观经济中有两个部门，一是家庭，二是企业。家庭出卖劳动，到企业去工作，赚钱购买生活所需用品（即消费）；企业生产出产品，把产品卖出去，收回钱来继续生产。一国的宏观经济要想平衡发展，它的条件是：家庭挣的钱全花了，企业生产的产品全卖了，这样宏观经济就能够正常进行。 凯恩斯又说，现实经济中每一个家庭都是一部分钱花出去，另一部分钱存起来。对企业来讲，它也不可能都在进行简单再生产，它想扩大再生产就需要投资。家庭不花的钱存进银行，就有了储蓄；企业扩大投资找银行借钱，就有了投资。只要企业的投资等于家庭的储蓄，宏观经济就能正常运转。所以说，宏观经济平衡的最重要条件是：储蓄等于投资。这也是最核心的经济学原理之一。 如果储蓄大于投资，经济就可能出现问题。我国政府这些年来一直希望人们把储蓄拿出来消费，只有花钱，经济才有希望增长。当储蓄大于投资时，就会出现通货紧缩，因为东西卖不出去，企业只能降价卖、便宜卖、保本卖，最后赔本也得卖。 如果投资大于储蓄时，大家都想赚钱，这时需求就多了，但东西少，物以稀为贵，商品就能卖高价，这就会出现通货膨胀。我们说，前者表现为通货紧缩，钱越来越值钱；后者表现为通货膨胀，东西越来越值钱。因此，在凯恩斯的宏观经济模型中，两部门的经济要想正常运行，经济平衡的条件是储蓄一定等于投资。 因此，我们分析两部门经济平衡的条件，是家庭的收入等于企业的产品。如果你不花钱，把钱存入银行，企业到银行借钱，那储蓄要等于投资 凯恩斯还说，任何一个国家都不能没有政府，否则这个社会就会混乱。所以在他的模型中，要加入政府部门。政府怎么生存？它需要有收入，政府收入就是税收。税收用于支付政府工作人员工资、军队开支以及各项公共教育等费用。 把政府加入模型中，宏观经济的平衡条件是：财政收入等于财政支出。当我们每个人拿到收入时要交个人所得税，企业有了收入，要交企业所得税，还要交企业增值税等。当大家把这些税缴纳给政府，政府有了收入，就要把钱花出去。这样宏观经济才能正常运转。如果政府财政收入不等于财政支出，就会出现财政赤字或财政赢余。 凯恩斯最后说，在这个宏观模型中，还要加一个国外部门。因为没有一个国家经济可以完全封闭起来，既不出口也不进口。所以，在这个模型中又加了一个国外部门，这就有了出口和进口。 当国外部门被加入时，宏观经济平衡的条件是：出口等于进口。如果一国出口多，进口少，赚的钱多了，外汇就会流进来，表现为贸易顺差，就像现在的中国一样；如果一国进口大于出口，则表现为贸易逆差，就像现在的美国一样。无论是贸易顺差还是贸易逆差，这都是宏观经济不平衡的表现。 宏观经济平衡宏观经济如何平衡一国宏观经济如何平衡呢?根据凯恩斯的简单模型我们可以得到得到一个简单的总供求平衡公式： 消费+储蓄+政府税收+进口=消费+投资+政府支出+出口 经济学里用字母来表示，就是： C + S + T + M = C + I + G + X 可在现实生活中，储蓄等于投资吗？不等于！政府的税收等于支出吗？不等于！出口等于进口吗？不等于！都不等于，那宏观经济还能转动吗？凯恩斯认为，它们不必个别相等，只要总量加起来相等就可以。当你把钱给了政府，政府一定要把这笔钱花出去，当你把钱存入银行，银行一定要把它贷出去，否则经济就不能发展。 宏观经济达不到平衡，那该怎么办？当一国宏观经济不平衡，需求太多，供给不足时，人们不愿意把钱存进银行，担心钱会越来越不值钱。所以不是拿去投资就是增加消费，结果物价指数就会攀升；反之，当供给太多，需求太少时，人们都愿意把钱放在手里或者存进银行里，就是不肯花出去。不管政府怎样刺激需求，使出什么高招，百姓就是不花钱，这时宏观经济怎么平衡？只能用价格来找平。 对企业来说，他们想卖出产品就得降价卖。如果原材料厂家让生产厂家买它的原材料，就必须价格便宜，甚至就赊账卖。这种供过于求的结果，就是价格指数下降。所以我们说，当总供求不平衡时，只能用价格来平衡。 当价格指数上升时，经济开始回暖，总需求超过总供给，通货膨胀发生；当价格指数下降时，经济开始变冷，总供给超过总需求，通货紧缩出现。 政府的宏观经济调控方式政府对宏观经济的调控就是在总需求和总供给上做文章。政府不是在刺激总需求就是在增加总供给。不过，需要强调的是，政府动总需求相对容易，动总供给却相对困难。 动总需求，政府只要出台政策就能马上刺激消费，刺激投资，增加出口；但是动总供给却不那么容易。比如，想增加钢材产量，先要找到原材料，再买设备，然后培训工人，再进行生产，最快也得一年半载才能投产。所以，政府动总供给很难，动总需求相对容易。 因此，一国政府在短期内调整的是总需求，在长期内才能调整的是总供给。这一点很重要。如果总供给和总需求都调整不好，那就通过价格找平。 一国经济的总供给和总需求是否平衡，通过物价指数就可以反映出来。当你看到价格指数平稳运行，既没有通货膨胀也没有通货紧缩时，那你就知道，宏观经济趋于平衡了。如果物价指数向上，说明经济开始回暖了；如果企业利润增加，说明经济开始起来了；如果股市回升，说明经济开始热了。所以，我们说一国经济的平衡就是总供给和总需求的平衡。","link":"/2022/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E7%BB%8F%E6%B5%8E%E4%B8%AD%E7%9A%84%E5%B9%B3%E8%A1%A1/"},{"title":"财政政策","text":"财政政策的种类财政政策的种类，可以分为三种类型。 赤字性财政政策：赤字性财政政策指的是通过加大财政赤字来刺激经济。运用的条件是经济萧条时期，总供给大于总需求。储蓄大于投资，生产出来的产品卖不出去，价格下降。采取的措施是减税和扩大政府支出，以增加有效需求。所以说，赤字性的财政政策也叫积极的财政政策。 扩大政府支出：当经济遇冷时，企业不愿意投入。因为投资到哪儿都没钱可赚，大家都不愿意消费。这时政府就会拿出钱来完善基础设施建设。比如，修路、架桥、铺设高铁及高速公路等等，政府用扩大支出的方式拉动经济增长。 政府减税对国民是好事，加大政府支出对国民也是好事，但减税和加大支出带来的结果往往是带来更大的赤字和更多的国债。 紧缩性财政政策：紧缩性财政政策运用的条件是在通货膨胀时期，总需求大于总供给，投资大于储蓄，物价上涨、需求膨胀。采取的措施是加税和减少政府支出，以抑制总需求。 平衡性财政政策：平衡性财政政策对社会总供求的影响保持中性。当社会总供求矛盾不突出时使用效果才会明显。 乘数效应当我们说到财政政策时，常常会涉及乘数效应。什么叫乘数效应？乘数效应说的是政府进行投资，并不是投了1000亿元就只是1000亿元的经济规模，它还会带动相关的投资和配套资金，会产生乘数效应。 我国财政主要解决的问题我国政府的财政主要解决的是民生问题、失业问题、养老问题、教育问题等，重要的是通过税收杠杆来解决收入的再分配，让穷人有饭吃。","link":"/2022/10/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/"},{"title":"财政赤字与国债","text":"财政赤字什么是财政赤字财政赤字就是财政的支出大于收入，赤字通常用红色来记录，因此叫财政赤字。相反，如果财政收入多而支出少，也会出现一个差额，那叫财政盈余。但是，在当今世界各国中，财政盈余的很少，绝大多数国家政府出现的都是财政赤字。 财政赤字警戒线标准国际上衡量财政赤字有两条警戒线标准： 警戒线标准是财政赤字占GDP比重不能超过3%。如果超过了3%，就会出现财政风险。 警戒线标准是政府的财政赤字，不能超出财政总支出的15%。这指的是政府的钱不够花时可以借债支出，但不能借债太多，超出财政总支出的15%就有风险。 如何弥补财政赤字一般来讲，当一国财政出现赤字时有两种解决办法，一是透支，二是发行国债。 透支就是财政部在中央银行有一个账户，就像我们每个人在银行都有账户，只能取出自己存进银行的钱。如果钱不够，就需要找银行借钱，就等于账户里出现了“红字”，也就是负数，这叫透支。最后，政府只能打开印钞机，用印钞来填补窟窿。但新的问题随之而来，打开印钞机就意味着通货膨胀要来了。 国债透支有这么大的弊端，说明这种透支行为不可取。那还有什么办法能解决财政赤字问题？有，那就是发行国债。 发行国债好处 人们拿着自己手中的钱购买国债，就意味着原计划储蓄的部分借给了政府。一般情况下，国债利息比银行存款利息高，这也是百姓乐于购买国债的原因。也就是说，你不花的钱政府借去花了，这样并不会增加货币总量，只是改变了存量分配。 政府通过发行国债获得资金，用于基建投资，加大政府支出，拉动经济增长，从经济增长中获得更多税收，再用获得的税收来赎回国债，还上借的钱。这样，政府就不用多印钞票，也就不会造成通货膨胀。 国债分类国债分为内债和外债，还分为短期、中期和长期三种。我国政府在外债上发行是的长期国债，在内债上发行的是短期、中期和长期国债。 债务危机发行国债的用途十分重要。发行国债一定不能用于经常性支出，而要用于建设性支出上。有些国家发行国债去给公务人员发工资，这样借的债就永远还不上了。因为经常性支出是给公务人员发工资，它不产生收益，也回不到政府手里，持续下去就会产生债务危机。","link":"/2022/10/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E8%B4%A2%E6%94%BF%E8%B5%A4%E5%AD%97%E4%B8%8E%E5%9B%BD%E5%80%BA/"},{"title":"财政的收入与支出","text":"我国财政收入的主要来源 税收收入。税收是最大的一块财政收入。任何一个国家，无论是发达国家还是发展中国家，政府财政收入主要都是从税收中来的。我国财政收入的绝大部分也是从税收中来的。税收的特点是强制性和无偿性。政府收税之后，无须再返还。 债务收入。当政府的钱不够花时，它可以借债。债务收入是自愿的，但需要政府还本付息。债务收入和税收收入是完全不同的。因为借债可能存在还不上的风险。 企业收入，也叫国有资产收益。它是指国家凭借国有资产所有权获得的利润、租金、股息，红利、资金使用费等收入的总称。因为国有企业是国家出钱办的企业。 其他收入。例如，使用国有森林、地下资源等国家资源必须向政府缴纳一定费用。此外，政府还会有一些转让使用的收入。 财政收入中最核心的部分是税收。包含企业上缴的增值税、营业税、所得税等，以及我们每个人上缴的个人所得税，还有关税、金融企业所得税等一系列税收。目前，我国税收管理体制分为国家税和地方税两部分，国税归中央政府所有，地税归地方政府所有。 财政支出有哪些方面 经常性支出 比如，我国公立大学教师的收入就是从政府税收中来的。国民缴税给政府，政府把这笔钱从财政部拨出一部分给了教育部，教育部拨给了全国的高校，高校再给教师们发工资。我国有两百多万军人，有国家的公检法机构，有教育部门，有科技部门，还有庞大的公务员队伍，这些都需要国家财政养活，政府要给他们发工资，这些支出就叫财政的经常性支出。这里提出了一个概念，经常性支出。什么是经常性支出呢？就是每个月都要支出的钱。例如，这月发给公务员的工资，下月还得发，需要一直发下去。 财政的经常性支出包括三个方面：第一，维持国家机器运行的需要；第二，支持科学、教育、文化、卫生等公共事业的发展；第三，建立和维持社会保障体系的运行。 建设性支出 比如，我国搞了很多大型项目投资，修建京九铁路、三峡工程等，仅三峡工程的预算就有2 000多亿元人民币，当然这些项目有时是靠发行国债进行的。但是，这毕竟属于财政资金的投入，属于建设性支出。 建设性支出又包括两方面：一是投资关系全局的基础设施建设；二是投资大中型企业的建设。 财政的经常性支出和建设性支出一定要分清楚。经常性支出就是每个月都必须支付的钱，如果财政没有钱，那么政府机构就无法正常运转。财政余下的钱用来搞建设，如果钱不够，政府可以通过发行国债的方式搞建设。","link":"/2022/10/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A2%E6%94%BF%E6%94%BF%E7%AD%96/%E8%B4%A2%E6%94%BF%E7%9A%84%E6%94%B6%E5%85%A5%E4%B8%8E%E6%94%AF%E5%87%BA/"},{"title":"通货膨胀","text":"什么是通货膨胀什么是通货膨胀？一国物价总水平普遍而持续地上升，就叫通货膨胀。如果只有一种商品的价格上升，这不是通货膨胀，只有大多数商品的价格都上升，而且物价水平是持续上涨，这才是通货膨胀。 通货膨胀如何衡量通货膨胀怎么衡量呢？一般是用价格指数来衡量通货膨胀。因为通货膨胀最终要通过物价水平的上涨表现出来，所以物价总水平的持续上涨幅度，就成为通货膨胀的标志。各国都用价格指数来表示一国的通货膨胀率。 国外最常用的价格指数有三种：一是消费价格指数；二是生产价格指数；三是批发价格指数。 消费价格指数（CPI），它衡量的是一篮子消费品和劳务的市场成本。这一篮子里主要大类是食物、衣服、住房、燃料、交通和医疗。这里包括了人们的衣食住行。 生产价格指数用来测量生产者卖给批发商的商品价格水平。 生产价格指数用来测量生产者卖给批发商的商品价格水平。 为什么有这么多的价格指数呢？因为只有一种价格指数不足以衡量价格水平变化的趋势。当你看到生产价格指数涨了，批发价格指数也涨了，你就会知道消费价格指数很快就会跟着涨了。这些指数就是用来判断价格变化的趋势。 通货膨胀类型通货膨胀有三种类型：一是温和的通货膨胀；二是奔腾式的通货膨胀；三是恶性通货膨胀。 温和的通货膨胀是指年率低于10%的通货膨胀率，也叫1位数的通胀。凡是10%以下的都叫作温和的通货膨胀。 奔腾式的通货膨胀是指一国通货膨胀按照20%、100%甚至200%的年率上升，就是2位数或3位数的通胀。这时物价就控制不住了，由于货币价值损失得太快，人们都不愿意持有任何货币，金融市场消失了，人们囤积商品，购买房屋，谁都不会按照普通的利率贷出货币。在阿根廷和巴西都曾出现过100%的通货膨胀率。 当恶性通货膨胀来临时，经济将遭受巨大的灾难。“一战”后的德国就发生了恶性通货膨胀。由于德国政府无法借债也收不上税，于是德国政府就打开了印钞机，把货币和价格都推向了天文数字。一个德国人在1922年拥有一张价值3亿美元的债券，两年后，这张债券连一块橡皮糖都买不到。国民手里的钱都变成了废纸。 指数化尽管通货膨胀非常可恶，但当它被预计到时，通货膨胀带来的大部分经济成本便会消失。这里有一个概念叫指数化。 简单地说，如果人们预测到今年的通货膨胀率是10%，那么工资收入也要提高10%，这就是指数化。把工资收入和通货膨胀率挂钩。西方国家价格指数化比较普遍。如工资价格指数化、社会保障支付指数化、利息和利率指数化。由于指数化的出现，整个经济中通胀造成的损失减缓了。 通货膨胀受害者通货膨胀的受害者包括三类人：一是放贷者；二是退休者；三是现金持有者。 第一类受害者：放贷者。由于大多数的贷款没有指数化，通货膨胀上升，就意味着放款者从借款者那里收回的钱低于它借出时的价值。还有许多人把他们为退休准备的积蓄，大部分拿去买了债券或证券，如果通货膨胀发生，他们将蒙受损失。当通货膨胀突然出现，借给别人钱的人着急了，因为收回的钱贬值了，这时借款人合适了，他还的钱少了。通货膨胀有利于债务人，不利于债权人。 第二类受害者：退休者。退休后如果他们的收入一直都没有调整，依然保持原来的退休工资，那物价水平的上升会使退休者的生活水平变糟。许多退休者只拥有固定的养老金，为了满足退休生活的需要，他们储蓄了一生，但通货膨胀可能意味着他们的养老金收入将不足以使他们按照自己期望的方式生活。因此，在通货膨胀时期，最受打击的是退休者。 第三类受害者：现金持有者。因为手头的现金会随通货膨胀而贬值。所以，通货膨胀对持有现金的人来说就是一种税收。经济学家把它称为“通货膨胀税”。如果一国的通货膨胀率是5%，就相当于你手里的现金交了5%的税。所以，凡是持有现金者都得再缴一个“通货膨胀税”，这是政府对公众财富的一种掠夺。在我国，许多农民手中的钱放在手边或存在家中的，通货膨胀对他们的损失将是巨大的。","link":"/2022/11/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80/%E9%80%9A%E8%B4%A7%E8%86%A8%E8%83%80/"},{"title":"中央银行","text":"银行是信用的产物银行既是信用的产物，也是信心的象征。只要大家信心在，银行就不会垮。这里需要强调的是，公众持有货币是一种信心，把钱放到银行里更是一种信心，只要公众的信心在，就不会发生恐慌，银行就可以运转下去。 只要一直有人存钱，银行就不会出问题。国际上那些几百年老字号的银行都是靠着信誉维持到今天的。无论存款人还是贷款人都相信这家银行，那这家银行就永远可以正常运转下去。 但如果有一天，一个人去一家银行取钱，银行没钱支付给他，那么银行有可能因为对这一个储户失去信用，而遭受灭顶之灾。一旦信用的缺口打开了，会有越来越多的人不信任这家银行，人们开始涌入银行去提款。储户是有权随时提取存款的，但银行贷出去的钱却不可能随时收回。 因此，从理论上讲，再好的银行也难以承受挤兑。当一个国家经济萧条，银行发生挤兑时，就可能一圈一圈地迅速恶性扩散。如果政府不进行抢救，就会引发通货膨胀，经济进入恶性循环，甚至导致政府破产。 银行破产首先打消的是人们对银行的信心，当人们对银行的信心消失时，银行就会倒下。当人们都去抛出货币，这个国家的货币就会贬值，通货膨胀就会来临。那么，谁能让商业银行遵守信用呢？是中央银行。 中央银行的诞生美国在20世纪初还没有中央银行，那时美国的银行经常出现支付危机，挤兑现象时有发生。美国在没有中央银行时，银行出了问题，政府财政出了问题，是靠谁解决的？ 在19世纪末20世纪初，美国一位叫JP. 摩根的人扮演了中央银行的角色。在美国出现中央银行之前，摩根一个人起到了中央银行的作用。联邦政府财政出了问题，找他出面解决；大公司出现问题，找他出面调停；银行出现问题，也请他出面解决。但一个国家的财政和金融问题也仅靠一个人来解决，这也未免太脆弱了。于是，美国诞生了中央银行。 美国在没有中央银行之前，摩根一个人充当了中央银行的角色。摩根去世后，美国在1914年成立了中央银行，就是美国联邦储备委员会。 中央银行的性质中央银行是一国银行体系的总枢纽，由政府赋予许多特权，通常具有官方地位，它是政府管理商业银行的机构。中央银行不以营利为目的，不直接经营商业银行的业务，而是代表政府管理整个银行系统。它的责任是制定货币政策，保证币值稳定。 为什么中央银行不能经营存贷业务呢？因为它代表一国政府来管理商业银行，如果央行也经营存贷业务，那所有人都会选择这条最安全的途径——把钱都存入中央银行。这样一来，其他商业银行就无法生存了。所以，中央银行不经营存贷业务，它只能制定货币政策，保证货币的稳定。只要让货币足值，保障人们随时能取出存款即可。 目前，世界绝大多数国家都有自己的中央银行，也就是在一般银行之外，单独设立中央银行。例如，美国的联邦储备系统（简称美联储）、英国的英格兰银行、德国的德意志银行、我国的中国人民银行等，它们都是本国的中央银行。 中央银行的职能 保持货币的足值 独占货币的发行权。一国的钞票是由央行发行的，任何银行都不可以随便发行钞票。 保证币值稳定。央行把钞票发出去，它要对所有持票的人负责。 人们手里拿到1元钱，这1元钱要有1元钱的购买力，如果买不到价值1元钱的东西，这是中央银行的责任，因为是央行让货币贬值了。所以，央行最重要的是保证币值的稳定。 币值稳定是一国经济健康的重要指标。如果一国货币升值，说明该国经济良好。人们都要这种货币时，该国货币就会升值；如果人们都不要这种货币，该国货币就要贬值。所以，货币标志着一国的经济实力，它是一种信心的象征，人们愿意持有一国货币是因为它的足值和稳定。 它是银行的银行 为商业银行保存准备金。央行是所有商业银行的坚强后盾。商业银行必须接受央行的监督和控制，它负责保存商业银行的准备金。 央行统一办理全国各银行的结算。它是商业银行的结算中心。比如，跨行汇款业务，就需要通过中央银行去结算。 央行充当最终贷款者。如果商业银行哪一天出现支付危机，或者储户来提款银行没钱，商业银行就可以找央行贷款，以应付紧急情况。 政府的银行 为政府提供金融服务，是政府的一个理财机构。它跟财政部一样，财政部负责政府财政上的收入和支出；而央行负责制定货币政策，它负责管理国家的这些钱。 对金融体系进行管理，所有商业银行要服从央行的管理。 央行集中保管黄金和外汇储备。一国的黄金由央行保管，外汇储备也由央行管理。我国的外汇储备由央行下设的外汇管理局管理。我国的黄金也由央行管理。 制定和执行货币政策。央行通过制定货币政策，来控制全国的商业银行，控制货币的投放量，因为钞票是央行印发的。央行还代表国家出席国际金融会议等。 中央银行的相对独立性西方经济学认为，央行应该相对独立于政府之外，它不能完全听政府的。虽然央行和财政部都是政府的理财机构，但它和财政部不一样，财政部要听命于一国政府，而央行不能完全听命于一国政府。 央行最重要的职能是保证一国币值的稳定。比如，美国决定要加入一场战争，总统让财政部配合，扩大财政支出。财政如果有钱的话，可以加大政府支出；财政如果没钱的话，政府可以发行国债，那样就可以筹措到战争的款项。但美国政府可以命令美国的中央银行，让它增发钞票吗？不可以。 如果央行和政府穿一条裤子，该国的货币就会贬值，因为央行对它的发钞不负责任了。我们谁还敢持有美元呢？所以，央行不能随意听从政府的要求。它必须相对独立于政府之外，它要对本国货币负责，对本国经济增长负责，对银行体系的安全负责。","link":"/2022/10/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E4%B8%AD%E5%A4%AE%E9%93%B6%E8%A1%8C/"},{"title":"政府调控经济的政策","text":"政府拉动经济增长有三驾马车：一是消费，二是投资，三是出口。一国经济要想平衡发展，它的总供给一定要等于总需求。如果不相等，政府不是动左手，就是动右手，那这两只手究竟怎么动？政府调控经济有三大政策：一是财政政策，二是货币政策，三是对外经济政策。 财政政策财政政策，主要是财政的收入与支出。财政的收入主要来自税收，政府通过收税来调控经济；财政的支出分成两大块：一块用于经常性支出，一块用于建设性支出，财政支出的多少也是政府调控经济的手段。总结起来，财政包含财政的收入、财政的支出、政府的税收、国家的债务。政府会用税收和支出来刺激或收缩经济，用赤字和债务来拉动经济。 货币政策货币政策，主要是中央银行的作用。在走向市场经济的过程中，我国货币政策在经济生活中的作用越来越重要。货币政策有三招：准备金率，贴现率和公开市场业务。中央银行控制着货币供给的闸门，它可以给经济“踩刹车”和“踩油门”。比如，现在世界都在关注美国的央行美联储是否降息，美联储就是通过利率来调控美国经济的冷与热。 对外经济政策对外经济政策，主要表现为汇率和关税的作用。随着我国加入世贸组织WTO以来，我国努力加大出口、吸引外商投资。这些年我国是吸引外资最多的国家之一，甚至超过了美国。外资直接投资到中国，说明他们看好了中国经济的未来。 一国经济为何不能一直高速增长？经济学有个原理叫生产可能性边界。一国有多少自然资源、财力资源、人力资源，都是有一定限制的，超过了这个限制经济就不再增长，只有价格的增长。但是随着科技的发展，未来生产可能性边界也会向外扩展。 上述这个例子是想说明，任何一国在一定的生产阶段，它只能干这个阶段该干的事情。这是由我国资源的稀缺性决定的，当我国经济的发展超过这种生产可能性边界时，经济就不可能继续向前发展了，这时必须“踩刹车”。如果不刹车，经济就会出现硬着陆。东西少需求多，导致价格上升，通货膨胀就会来临。 经济太冷时，我国政府就会实施“踩油门”政策。在财政政策上，减少税收，增加支出；在货币政策上，降低利率，增加货币供给量。当经济太冷时，央行会打开货币供给的水龙头，把利率从高位降下来，就是我们常说的降息。当利率很低时，人们更愿意贷款去投资、去买房。当人们觉得贷款消费合适时，钱就会重新流入经济领域。当人们愿意投资、消费、生产，觉得有钱可赚的时候，经济就会从谷底回升，由冷变暖。","link":"/2022/11/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E6%94%BF%E5%BA%9C%E8%B0%83%E6%8E%A7%E7%BB%8F%E6%B5%8E%E7%9A%84%E6%94%BF%E7%AD%96/"},{"title":"货币供给和需求","text":"货币供给的计算方法 货币的数量就叫货币供给。经济学家计算的货币是从我们身边带的纸币和硬币开始的，离身边最近的就是最活跃的货币，离我们最远的就是不活跃的货币。经济学家提出多种衡量货币供给的方法，我们先来看看一般西方经济学家计算货币供给的方法。 一般把货币供给分为三类，也就是三种官方的货币计算标准，M1、M2、M3。M就是Money的首字母。 计算货币供给的第一种方法是M1，它是狭义的货币供给。 M1=现金+活期存款 计算货币供给的第二种方法是M2，它是广义的货币供给。 M2=M1+定期存款 计算货币供给的第三种方法是M3。 M3=M2+其他金融机构的存款，所以M3是更广义的货币供给。 我国计算货币供给的方法，也有三种。 流通中的货币，用M0来表示。现金是中国人民银行发行的钞票，就是通货。这是最活跃的货币，可以直接把它当钱来花。 M0=现金（通货） 狭义货币供给，用M1表示。 M1=M0+企业活期存款 广义货币供给，用M2表示。 M2=M1+企业定期存款+居民储蓄存款+财政存款我们通常使用的是M2，这是广义的货币供给。 经济学家之所以要使用几种不同的计算货币供给方法，是因为仅仅根据一种方法不足以预测经济活动水平的变化。比如，为什么有时货币供给特别多，这是因为经济中出现赚钱的机会，人们就会把M2变成M1，把定期存款变成活期存款，把活期存款变成现金，然后直接买房或买股票；相反，如果经济遇冷时，大家都不花钱，现金就会变成M1，M1变成M2，最后变成存在银行里的钱，所以钱就感觉少了。我们在实际研究中以M1作为货币供给的定义。 货币需求 那谁来决定货币供给的多与少呢？这由中央银行决定，因为钞票是央行发的，法定准备金是央行定的，公开市场业务是央行做的，央行控制着货币供给的总闸门。货币需求有流量和存量之分，人们每月得到的工资收入是一个流量，人们在手里或银行账户上所拥有的货币就是一个存量。我们讲的货币需求通常指的是存量，就是人们在某个时点愿意持有的货币量。 人们持有货币主要有三种需求：交易需求、预防需求、投机需求。 货币的交易需求和预防需求与收入正相关，与利率负相关；货币的投机需求与收入的关系不大，与市场利率关系很大。利率越高，投机的需求越少；利率越低，投机的货币需求越多。 货币的流通速度一国流通中客观上需要多少货币还取于货币的流通速度。什么叫货币的流通速度呢？就是1元货币一年周转多少次。货币周转次数越多，需要的货币量就越少，货币周转次数越少，需要的货币量就越多。 1982年，美国的每1美元一年转6.7次。我国在1980年时每1元转2.06次，到1991年为1.13次。所以我国的货币需求量就比美国要多。所以，货币流通速度的高低，与货币需求有很密切的关系。 均衡利率货币供给最终是由中央银行决定的。在货币政策不变时，货币供给量是一定的。货币需求由价格、GDP、利率三种因素决定。在既定的时点和既定的价格水平上，可以把GDP视为固定的，那么货币需求主要由利率决定。货币是一种存量，当供给的货币量等于需求的货币量时，货币供求就实现了平衡。均衡利率指的就是货币供求平衡时的利率。所以，利率的调整使货币供求实现了平衡，央行就是通过利率来调控宏观经济的。 基础货币基础货币=通货+准备金 通货就是流通领域的货币；准备金就是要交给中央银行的钱。放在你手里的钱都叫通货，放进中央银行的钱就变成了准备金。 基础货币的定义是指能够派生出信用货币的货币，它主要由央行对商业银行的再贷款形成。基础货币必须是中央银行的货币。换句话说，基础货币就是中央银行发行的钞票。","link":"/2022/10/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E8%B4%A7%E5%B8%81%E4%BE%9B%E7%BB%99%E5%92%8C%E9%9C%80%E6%B1%82/"},{"title":"货币政策工具","text":"法定准备金率实行存款准备金制度的最初目的是防止银行出现大量挤兑。后来演变为央行控制货币供给的一个重要工具。准备金率下调，意味着央行打开了货币供给的水龙头，商业银行可贷出的钱就多了。所以，当央行降低准备金率时，钱就从银行流了出来，它能够为经济提供更多的货币支撑。 什么情况下央行会提高准备金率？经济过热，放出去的贷款过多，快要产生通胀时，央行就会提高准备金率。把准备金率从5%提到15%，这样，原来商业银行可贷出95元，现在只能贷出85元了。假定一家商业银行持有1亿元人民币，按照5%的准备金率，它要缴存500万元准备金，可贷出9 500万元。准备金率提到15%，它的1亿元就只能贷出8 500万元了。商业银行要马上收回它多贷出去的10%的金额，它要从企业中把1 000万元收回来上缴央行，这会发生一系列追讨资金的行为。 提高准备金率就是把流通领域的钱抽走，经济中没了资金的流动性，很大一笔钱要被冻结起来放进中央银行，经济发展就会放缓。所以说，央行调整准备金率是一个非常强有力的手段 什么情况下央行会降低准备金率呢？在经济萧条时期，供过于求，所有的东西都卖不出去。央行就会打开货币供给的水龙头。 因此，我们说调整法定准备金率是一个非常强烈的手段，它只有在特殊情况下才能使用。 贴现率贴现率是指将未来支付改变为现值所使用的利率，或指持票人以没有到期的票据向银行要求兑现，银行将利息先行扣除所使用的利率。这种贴现率也指再贴现率，即各成员银行将已贴现过的票据作担保，作为向中央银行借款时所支付的利息。 如果央行货币政策是紧的，贴现率就高，说明央行不愿意放出钱来。如果央行给出一个低贴现率，说明央行愿意把钱放出来。所以，央行是通过贴现率来控制货币的闸门。事实上，中央银行对利率只有一个权利，就是它能够决定贴现率。 贴现率是由央行定的，那商业银行的利率是由谁来决定的？我们说，在市场经济国家，利率既不是政府定的也不是央行定的，利率是由市场来决定的。美元利率为什么有时高有时低呢？如果美国有商机，市场上好赚钱，大家都需要美元，美元的需求大于供给，美元的利率就高；相反，如果大家不看好美国经济，都不要美元，美元的供给大于需求，美元的利率就低。因此，利率是由市场供求决定的。 央行只能决定贴现率，在中国它叫再贷款利率，在美国它叫联邦基准利率。央行可以用贴现率来给市场降温或给市场加油。 比如，原来贴现率是5%，现在变成8%，就说明通胀严重，央行不准备把钱放出去。你想想看，央行给商业银行的贴现率是8%，商业银行贷出的利率就得高于8%。贷款利率过高，企业就不会去贷款投资了，人们不去贷款消费了，商品价格就会降下来，通胀率就被控制住了。 因此，我们说贴现率也是一个比较强硬的手段。但央行不能经常调整贴现率，因为利率杠杆一动，引起的市场波动太大。 公开市场业务公开市场业务是指央行在公开市场上进行操作，买进或卖出债券。这些债券有三个月期、半年期、一年期、三年期和五年期的不等。 央行发现经济冷了，它决定打开货币水龙头，就是在公开市场买进债券。当经济太冷时，市场需要现金。央行买进债券就放出了现金，这就打开了货币供给的水龙头。央行收购国债，把钱放出来，鼓励人们去消费、去投资。央行这样做的目的是刺激经济回升。 央行在哪种情况下会卖出国债呢？就是当央行发现经济需要降温，再热下去要出现泡沫，通胀率高了，央行就会在公开市场上卖出国债。央行给一个高利率吸引人们购买债券，让人们都愿意持有国债。当人们持有债券时，就没有钱去消费和投资了，市场上流动的现金减少了，经济就会适度降温。 公开市场操作可以频繁进行，它可以对经济进行微调。我们说，公开市场业务就是央行和百姓之间买卖国债，它是现金和债券的互换。央行通过债券的买卖控制货币供给的多与少。","link":"/2022/10/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96%E5%B7%A5%E5%85%B7/"},{"title":"金融市场","text":"什么是金融市场由于货币具有延期支付的职能，就产生了信用，在信用的基础上出现了银行，银行出现后，因为它具有创造货币的功能，就在更大的基础上创造了信用。这就涉及到了金融。 什么叫金融？金融就是由货币、信用和银行形成的资金融通，取中间两个字称为“金融”。凡是货币转移、票据交易、银行信贷、证券投资，都属于金融活动，为这些活动提供的场所叫金融市场。 在现代社会，有些人有钱不想投资，另一些人没钱但想投资。为了使储蓄者和投资者结合起来，就需要一条渠道，金融市场的作用就是提供渠道，实现资金从储蓄者向投资者转移。正是由于有不同需求，才有了金融市场。因此，金融市场是一个大的概念，它包括了所有的金融活动。 间接融资和直接融资的区别通过银行完成的信贷活动叫间接融资，通过证券市场完成的交易活动叫直接融资，区别就在于前者的风险在银行，后者的风险在个人。 间接融资，就是找银行借钱。 银行创造了资金的流动性，它可以贷出多笔资金，只要滚动着向前走即可，即使有少数贷款收不回来，还是能保证多数贷款按期还上。只要有资金不断流入，银行就能向前发展。当一些企业效益不好、出现问题时，银行会冻结并收回它们的贷款。银行可以把资金从夕阳产业转向朝阳产业，通过银行这只手，资金流向有利润、有前途的行业，这使得经济可以在良性循环的轨道上发展。 直接融资，就是到股市融资。 资金成本最低，除了上市费用和以后给股东分红外，上市公司不必归还本金。所以，找银行借钱叫间接融资，到证券市场发行股票叫直接融资。 我国目前正在努力拓宽直接融资的渠道，分散银行储蓄过多的压力，也分担银行贷款的负担。建立和完善我国股票市场和资本市场，这是我国政府面临的一项艰巨任务。 在过去那些年，我国经济活动中大量出现的都是间接融资，老百姓存钱只能到银行，投资者借钱也只有找银行。这样就使银行的负担过重。 相反，有很多新兴的、有潜力的企业不具备相当的规模和信誉，也够不上银行的贷款条件。所以企业到银行贷款就变得非常困难，银行还要承受支付储户利息的巨大压力。这使得很多银行贷款都流向了房地产市场。 我国金融体制改革的大趋势就是变间接融资为直接融资，而发展壮大我国的资本市场是大势所趋。 货币市场和资本市场什么是货币市场货币市场是在短期内(一年以内)的金融资产交易的市场，产品有短期国债、银行汇票等。在货币市场上进行的交易都具有期限短、风险小、流动性强的特点，在货币供应层次划分上在现金货币和存款货币之后，被称为准货币，所以被称为货币市场。货币市场可以解决借款者的短期资金需求的问题，也可以为暂时闲置的资金找到合适的安放渠道。 什么是资本市场资本市场是进行中长期(一年以上)资金借贷融通活动的市场，产品有股票、20年期公司债券等。在资本市场上进行的交易都具有融资期限长、风险大、流通性差的特点，但同时也具有长期稳定的收入，跟资本投入相似，所以被称为资本市场。 货币市场和资本市场有什么区别 特点不同。货币市场的特点是交易期限短、风险低、流动性强。而资本市场的特点是资金借贷量大、风险性强、流动性差、期限长 功能不同。货币市场可以解决流动资金、短期资金问题，同时是政府、银行的信用工具。资本市场为筹集资金提供场所，解决资本结构，长期资金问题，可以进行资源的合理配置，有利于企业重组。 子市场不同。货币市场由同行业拆借市场、票据市场等6个子市场构成。资本市场包括银行中长期存贷款市场和有效证券市场。 总而言之，货币市场与资本市场最大的区别，其实就是金融工具和期限的不同。但二者的区别并不仅仅在于此，它们的资金来源以及融资目的以及风险程度和收益水平都不同。","link":"/2022/10/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E9%87%91%E8%9E%8D%E5%B8%82%E5%9C%BA/"},{"title":"货币职能与发行","text":"货币的职能货币具备四种职能。 交换媒介：我们每个人身上或多或少都要带些钱，用来购买商品和服务。货币就是交换的媒介，没有它，我们每天的交换几乎都无法完成。 贮藏：一种货币在一定时期内必须能够保值。否则人们将不再需要这种货币，宁愿把它换成商品或其他国家的足值货币。 计量单位：我们到商场买东西，不同的商品有不同的价格，相同商品在不同的商店价格也不同。 延期支付：你今天买了东西，以后再付钱的这种行为就叫延期支付。假定你经营一家企业，可供货的原材料厂商很多，选择的主动权就在你手上。这时你可以告诉供应商：“你先把东西放这儿，两个月后我再付钱给你。” 延期支付的信用问题因为货币具有延期支付的职能，人们之间就有了信用，接着就出现了赊欠行为。但并不是每个人都遵守承诺，很多人不守信用，到期不付钱，这样一来，商家就损失了。 这时银行出现了，银行说，商家之间不必相互赊账。谁想借钱就来找我，我负责借钱，负责追债，银行会让所有人都遵守信用制度。就这样，银行成了买卖双方的信用中介。 大家存钱到银行，借钱也到银行。银行是靠赚存款和贷款的差价来生存的。银行业就这样发展起来了。银行出现后，在更大的基础上创造了信用，使人类社会的发展加快了脚步。 准备金当一个储户把钱存进银行时，银行不能把这些钱全都贷出去。这是为了保证储户取钱时有钱，各个银行都要有一部分准备金。 为了避免部分银行准备金过少没有足够的钱支付储户取款从而出现挤兑现象各国中央银行都规定了一个法定准备金率。商业银行不能把储户的存款都贷出去，必须留下一部分钱作为准备金，强制性地存到中央银行，如果储户来提款，银行要有钱支付给他们。 我国的商业银行也要上交法定准备金。当储户到银行取钱时，银行一定得有钱给他，如果这家银行没有钱，它可以去中央银行或找其他银行拆借，无论如何银行都要把钱支付给储户，这是银行的信用。 商业银行为什么能找中央银行去借钱呢？因为它在中央银行存放了法定准备金。这时，又产生了一个新问题。就是说，现代社会的货币供给是由银行创造的。 银行创造货币的过程假定，我国的法定准备金率是20%，一个储户手里有1 000元钱，他把这笔钱存入了中国工商银行（简称工行），工行必须把200元留下交给中央银行（我国的中央银行是指中国人民银行），工行只能贷出800元。 此时，有人正好去工行借800元，他要买一台吸尘器。到了商场，他把钱交给柜台，商场又把这800元存入自己的开户行——中国农业银行（简称农行）。 当农行收到这笔钱时，这800元钱它也不能都贷出去，必须把160元上交中央银行，只能贷出640元。这时正好有人想买个榨汁机，就去农行借钱，当他借到640元后，到一家超市买了榨汁机，把640元钱交到收款台，这家超市又把这640元存入自己开户行——中国建设银行（简称建行）。 建行接到这笔钱后，要把20%的法定准备金交到中央银行，它只能贷出512元。如此下去，储户的这1 000元存款通过银行系统不断的存贷而被放大，最后变成多少钱了呢？ 我们看，账面上银行新增存款是5 000元，新增贷款是4 000元，货币总量增加了5000元，法定准备金是1 000元。 然而，中央银行并没有多印一张钞票，钱怎么就多出这么多呢？这是银行通过信用活动创造出来的。所以说，银行具有创造货币供给的功能。 货币乘数什么叫货币乘数？准备金率变化和存款最后变化之间的关系就叫货币乘数。 银行创造的货币与法定准备金率成反比。银行创造货币能力的大小，取决于准备金率的高与低。准备金率越高，货币乘数就越小，准备金率越低，货币的乘数就越大。 通货外流通货外流是指现实中并不是所有的银行放出去的贷款都能以准备金的形式再回到银行。某些贷款从银行体系中漏出去了，就叫通货外流。 比如，你今天到超市买东西，但超市没有把你的这笔钱存入银行，而是留下用于明天的进货。这笔钱进入了流通领域，它就不能创造货币供给增加。 由于通货外流，使现实中的货币乘数小于理论上的货币乘数。只有通过银行信贷活动创造的新存款，才能增加现有货币量。当人们把钱存进银行时，经济就开始加速了。 乘数效应人们把钱存进银行，银行把钱贷给他人，他人再放进银行，银行接着再贷出去。就这样，一笔钱一直存贷下去，货币供给量就会成倍增加，经济规模和增长速度也会成倍放大。这就是乘数效应。 当我们去银行取钱时，银行应该有钱，我们每个人都能取出来。这并不是纯粹数字的虚增，因为在每一个环节上都有新的财富创造出来。 让我们来思考一下，到银行存钱的人，他是从哪里得到这笔钱呢？ 因为他销售了产品，为别人提供了服务，获得了报酬；而那些从银行借钱的人，他也要通过自己的经营活动获得利润，才能把借银行的这笔钱还上。因此，我们说，这里的每一个环节都在创造财富，也都在增加财富。银行通过信用创造的货币供给是真实存在的。 由此，银行的信誉越好，它创造货币供给的能力就越大。一国的法定准备金率越低，银行创造的货币供给就越多。这就像货币的水龙头，法定准备金率降低时，水就会流出来；法定准备金率提高时，资金之水就会被抽走。 明白了这一点，我们就能知道为什么央行调整法定准备金率，能发挥出强大的调控经济作用。同时大家还会明白，现代社会经济是一环接一环扣在银行身上加速运行的。","link":"/2022/10/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/%E8%B4%A7%E5%B8%81%E7%90%86%E8%AE%BA/%E8%B4%A7%E5%B8%81%E7%9A%84%E8%81%8C%E8%83%BD/"},{"title":"声明、类型、语句与控制结构","text":"使用一致的变量声明形式 变量声明形式的选择上应尽量保持项目范围内一致。 Go语言提供var块用于将多个变量声明语句放在一起，并且在语法上不会限制放置在var块中的声明类型。但是我们一般将同一类的变量声明放在一个var块中，将不同类的声明放在不同的var块中。 就近原则，即尽可能在靠近第一次使用变量的位置声明该变量。就近原则实际上是变量的作用域最小化的一种实现手段。如果一个包级变量在包内部被多处使用，那么这个变量还是放在源文件头部声明比较适合。 包级变量，只能使用 var 关键字的变量声明方式。 尽量在分支控制时应用短变量声明形式。 使用无类型常量简化代码 Go是对类型安全要求十分严格的编程语言。Go要求，两个类型即便拥有相同的底层类型（underlying type），也仍然是不同的数据类型，不可以被相互比较或混在一个表达式中进行运算。有类型常量给代码简化带来了麻烦，但这也是Go语言对类型安全严格要求的结果。 无类型常量也拥有自己的默认类型：无类型的布尔型常量、整数常量、字符常量、浮点数常量、复数常量、字符串常量对应的默认类型分别为bool、int、int32(rune)、float64、complex128和string。 所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。当操作数是常量时，在编译时也能发现一些运行时的错误，例如整数除零、字符串索引越界等。 无类型常量是Go语言推荐的实践，它拥有和字面值一样的灵活特性，可以直接用于更多的表达式而不需要进行显式类型转换，从而简化了代码编写。此外，按照Go官方语言规范的描述，数值型无类型常量可以提供比基础类型更高精度的算术运算，至少有256 bit的运算精度。 使用iota实现枚举常量 Go的const语法提供了“隐式重复前一个非空表达式”的机制： 12345const ( Apple, Banana = 11, 22 Strawberry, Grape Pear, Watermelon) 常量定义的后两行没有显式给予初始赋值，Go编译器将为其隐式使用第一行的表达式，这样上述定义等价于： 12345const ( Apple, Banana = 11, 22 Strawberry, Grape = 11, 22 Pear, Watermelon = 11, 22) iota是Go语言的一个预定义标识符，它表示的是const声明块（包括单行声明）中每个常量所处位置在块中的偏移值（从零开始）。同时，每一行中的iota自身也是一个无类型常量，可以像无类型常量那样自动参与不同类型的求值过程，而无须对其进行显式类型转换操作。 Go的枚举常量不限于整型值，也可以定义浮点型的枚举常量。 12345const ( PI = 3.1415926 // π PI_2 = 3.1415926 / (2 * iota) // π/2 PI_4 // π/4) 使用有类型枚举常量保证类型安全: 12345678910111213// $GOROOT/src/time/time.gotype Weekday intconst ( Sunday Weekday = iota Monday Tuesday Wednesday Thursday Friday Saturday) 尽量定义零值可用的类型 当通过声明或调用new为变量分配存储空间，或者通过复合文字字面量或调用make创建新值，且不提供显式初始化时，Go会为变量或值提供默认值。 Go语言中的每个原生类型都有其默认值，这个默认值就是这个类型的零值。下面是Go规范定义的内置原生类型的默认值（零值）。 所有整型类型：0 浮点类型：0.0 布尔类型：false 字符串类型：”” 指针、interface、切片（slice）、channel、map、function：nil 另外，Go的零值初始是递归的，即数组、结构体等类型的零值初始化就是对其组成元素逐一进行零值初始化。 Go中的切片类型具备零值可用的特性，我们可以直接对其进行append操作，而不会出现引用nil的错误。 Go标准库的设计者很贴心地将sync.Mutex结构体的零值设计为可用状态，让Mutex的调用者可以省略对Mutex的初始化而直接使用Mutex。 Go语言零值可用的理念给内置类型、标准库的使用者带来很多便利。不过Go并非所有类型都是零值可用的，并且零值可用也有一定的限制，比如：在append场景下，零值可用的切片类型不能通过下标形式操作数据： 123var s []ints[0] = 12 // 报错！s = append(s, 12) // 正确 另外，像map这样的原生类型也没有提供对零值可用的支持： 12345var m map[string]intm[&quot;go&quot;] = 1 // 报错！m1 := make(map[string]int)m1[&quot;go&quot;] = 1 // 正确 另外零值可用的类型要注意尽量避免值复制： 123var mu sync.Mutexmu1 := mu // 错误: 避免值复制foo(mu) // 错误: 避免值复制 我们可以通过指针方式传递类似Mutex这样的类型： 12var mu sync.Mutexfoo(&amp;mu) // 正确 保持与Go一致的理念，给自定义的类型一个合理的零值，并尽量保持自定义类型的零值可用，这样我们的Go代码会更加符合Go语言的惯用法。 使用复合字面值作为初值构造器 Go提供的复合字面值（composite literal）语法可以作为复合类型变量的初值构造器。 1234s := myStruct{&quot;tony&quot;, 23}a := [5]int{13, 14, 15, 16, 17}sl := []int{23, 24, 25, 26, 27}m := map[int]string {1:&quot;hello&quot;, 2:&quot;gopher&quot;, 3:&quot;!&quot;} field:value形式的复合字面值初值构造器与普通复合字面值形式不同，field:value形式字面值中的字段可以以任意次序出现，未显式出现在字面值的结构体中的字段将采用其对应类型的零值。 复合字面值作为结构体值构造器的大量使用，使得即便采用类型零值时我们也会使用字面值构造器形式： 12s := myStruct{} // 常用s := new(myStruct) // 较少使用 不允许将从其他包导入的结构体中的未导出字段作为复合字面值中的field，这会导致编译错误。 对于数组/切片类型而言，当元素为复合类型时，可以省去元素复合字面量中的类型，比如： 123456789type Point struct { x float64 y float64}sl := []Point{ {1.2345, 6.2789}, // Point{1.2345, 6.2789} {2.2345, 19.2789}, // Point{2.2345, 19.2789}} 对于key或value为指针类型的情况，也可以省略“&amp;T”： 1234567m2 := map[string]*Point{ &quot;Persepolis&quot;: {29.935523, 52.891566}, // 相当于value为&amp;Point{29.935523, 52.891566} &quot;Uluru&quot;: {-25.352594, 131.034361}, // 相当于value为&amp;Point{-25.352594, 131.034361} &quot;Googleplex&quot;: {37.422455, -122.084306}, // 相当于value为&amp;Point{37.422455, -122.084306}}fmt.Println(m2) // map[Googleplex:0xc0000ae050 Persepolis:0xc0000ae030 Uluru:0xc0000ae040] 了解切片实现原理并高效使用 Go数组是值语义的，这意味着一个数组变量表示的是整个数组，这点与C语言完全不同。在C语言中，数组变量可视为指向数组第一个元素的指针。而在Go语言中传递数组是纯粹的值拷贝，对于元素类型长度较大或元素个数较多的数组，如果直接以数组类型参数传递到函数中会有不小的性能损耗。这时很多人会使用数组指针类型来定义函数参数，然后将数组地址传进函数，这样做的确可以避免性能损耗，但这是C语言的惯用法，在Go语言中，更地道的方式是使用切片。 切片可以提供比指针更为强大的功能，比如下标访问、边界溢出校验、动态扩容等。 通过语法u[low: high]形式进行数组切片化而创建的切片，一旦切片cap触碰到数组的上界，再对切片进行append操作，切片就会和原数组解除绑定。 重新分配底层数组并复制元素的操作代价很大，如果可以预估出切片底层数组需要承载的元素数量，强烈建议在创建切片时带上cap参数。 了解map实现原理并高效使用 map对value的类型没有限制，但是对key的类型有严格要求：key的类型应该严格定义了作为“==”和“!=”两个操作符的操作数时的行为，因此函数、map、切片不能作为map的key类型。 map类型不支持“零值可用”，未显式赋初值的map类型变量的零值为nil。对处于零值状态的map变量进行操作将会导致运行时panic。 和切片一样，map也是引用类型，将map类型变量作为函数参数传入不会有很大的性能损耗，并且在函数内部对map变量的修改在函数外部也是可见的。 面对一个非nil的map类型变量，我们可以向其中插入符合map类型定义的任意键值对。Go运行时会负责map内部的内存管理，因此除非是系统内存耗尽，我们不用担心向map中插入数据的数量。如果key已经存在于map中，则该插入操作会用新值覆盖旧值。 map类型更多用在查找和数据读取场合。所谓查找就是判断某个key是否存在于某个map中。我们可以使用“comma ok”惯用法来进行查找： 1234_, ok := m[&quot;key&quot;]if !ok { // &quot;key&quot;不在map中} 如果key不存在于map中，我们看到v仍然被赋予了一个“合法”值0，这个值是value类型int的零值。在这样的情况下，我们无法判定这个0是“key3”对应的值还是因“key3”不存在而返回的零值。为此我们还需要借助“comma ok”: 123456789m := map[string]intm[&quot;key1&quot;] = 1m[&quot;key2&quot;] = 2v := m[&quot;key1&quot;]fmt.Println(v) // 1v = m[&quot;key3&quot;]fmt.Println(v) // 0 即便要删除的数据在map中不存在，delete也不会导致panic。 对同一map做多次遍历，遍历的元素次序并不相同。这是因为Go运行时在初始化map迭代器时对起始位置做了随机处理。因此千万不要依赖遍历map所得到的元素次序。如果你需要一个稳定的遍历次序，那么一个比较通用的做法是使用另一种数据结构来按需要的次序保存key，比如切片。 充当map描述符角色的hmap实例自身是有状态的（hmap.flags）且对状态的读写是没有并发保护的，因此map实例不是并发写安全的，不支持并发读写。如果对map实例进行并发读写，程序运行时会发生panic。比如下面并发读写map的例子： 12345678910111213141516171819202122232425262728293031323334// chapter3/sources/map_concurrent_read_and_write.gofunc doIteration(m map[int]int) { for k, v := range m { _ = fmt.Sprintf(&quot;[%d, %d] &quot;, k, v) }}func doWrite(m map[int]int) { for k, v := range m { m[k] = v + 1 }}func main() { m := map[int]int{ 1: 11, 2: 12, 3: 13, } go func() { for i := 0; i &lt; 1000; i++ { doIteration(m) } }() go func() { for i := 0; i &lt; 1000; i++ { doWrite(m) } }() time.Sleep(5 * time.Second)} Go 1.9版本中引入了支持并发写安全的sync.Map类型，可以用来在并发读写的场景下替换掉map。另外考虑到map可以自动扩容，map中数据元素的value位置可能在这一过程中发生变化，因此Go不允许获取map中value的地址，这个约束是在编译期间就生效的。示例代码如下： 12p := m[key] // 无法获取m[key]的地址fmt.Println(p) map底层结构如下： 和切片一样，尽量使用cap参数创建map避免频繁扩容降低性能。 了解string实现原理并高效使用 在Go语言中，无论是字符串常量、字符串变量还是代码中出现的字符串字面量，它们的类型都被统一设置为string。 string类型的数据是不可变的一旦声明了一个string类型的标识符，无论是常量还是变量，该标识符所指代的数据在整个程序的生命周期内便无法更改。对string进行切片化后，Go编译器会为切片变量重新分配底层存储而不是共用string的底层存储，因此对切片的修改并未对原string的数据产生任何影响。 通过unsafe指针指向string在运行时内部表示结构中的数据存储块的地址，然后通过指针修改那块内存中存储的数据是行不通的。对string的底层的数据存储区仅能进行只读操作，一旦试图修改那块区域的数据，便会得到SIGBUS的运行时错误。 Go string类型支持“零值可用”的理念。Go字符串无须像C语言中那样考虑结尾’\\0’字符，因此其零值为””，长度为0。 Go string类型数据是不可变的，因此一旦有了初值，那块数据就不会改变，其长度也不会改变。Go将这个长度作为一个字段存储在运行时的string类型的内部表示结构中。这样获取string长度的操作，即len(s)实际上就是读取存储在运行时中的那个长度值，这是一个代价极低的O(1)操作。 由于Go string是不可变的，因此如果两个字符串的长度不相同，那么无须比较具体字符串数据即可断定两个字符串是不同的。如果长度相同，则要进一步判断数据指针是否指向同一块底层存储数据。如果相同，则两个字符串是等价的；如果不同，则还需进一步比对实际的数据内容。 Go语言源文件默认采用的Unicode字符集。Unicode字符集是目前市面上最流行的字符集，几乎囊括了所有主流非ASCII字符（包括中文字符）。Go字符串的每个字符都是一个Unicode字符，并且这些Unicode字符是以UTF-8编码格式存储在内存当中的。 在UTF-8中，大多数中文字符都使用三字节表示。 Go语言直接提供了通过反引号构造“所见即所得”的多行字符串的方法。 Go string在运行时表示为下面的结构： 12345// $GOROOT/src/runtime/string.gotype stringStruct struct { str unsafe.Pointer len int} 在能预估出最终字符串长度的情况下，使用预初始化的strings.Builder连接构建字符串效率最高；strings.Join连接构建字符串的平均性能最稳定，如果输入的多个字符串是以[]string承载的，那么strings.Join也是不错的选择；使用操作符连接的方式最直观、最自然，在编译器知晓欲连接的字符串个数的情况下，使用此种方式可以得到编译器的优化处理；fmt.Sprintf虽然效率不高，但也不是一无是处，如果是由多种不同类型变量来构建特定格式的字符串，那么这种方式还是最适合的。 无论是string转slice还是slice转string，转换都是要付出代价的，这些代价的根源在于string是不可变的，运行时要为转换后的类型分配新内存。 slice类型是不可比较的，而string类型是可比较的，因此在日常Go编码中，我们会经常遇到将slice临时转换为string的情况。Go编译器为这样的场景提供了优化。在运行时中有一个名为slicebytetostringtmp的函数就是协助实现这一优化的： 12345678910111213// $GOROOT/src/runtime/string.gofunc slicebytetostringtmp(b []byte) string { if raceenabled &amp;&amp; len(b) &gt; 0 { racereadrangepc(unsafe.Pointer(&amp;b[0]), uintptr(len(b)), getcallerpc(), funcPC(slicebytetostringtmp)) } if msanenabled &amp;&amp; len(b) &gt; 0 { msanread(unsafe.Pointer(&amp;b[0]), uintptr(len(b))) } return *(*string)(unsafe.Pointer(&amp;b))} 该函数的“秘诀”就在于不为string新开辟一块内存，而是直接使用slice的底层存储。当然使用这个函数的前提是：在原slice被修改后，这个string不能再被使用了。因此这样的优化是针对以下几个特定场景的。 string(b)用在map类型的key中 string(b)用在字符串连接语句中 string(b)用在字符串比较中 Go编译器对用在for-range循环中的string到[]byte的转换也有优化处理，它不会为[]byte进行额外的内存分配，而是直接使用string的底层数据。 1234567891011121314151617181920// chapter3/sources/string_for_range_covert_optimize.gofunc convert() { s := &quot;中国欢迎您，北京欢迎您&quot; sl := []byte(s) for _, v := range sl { _ = v }}func convertWithOptimize() { s := &quot;中国欢迎您，北京欢迎您&quot; for _, v := range []byte(s) { _ = v }}func main() { fmt.Println(testing.AllocsPerRun(1, convert)) fmt.Println(testing.AllocsPerRun(1, convertWithOptimize))} 123$go run string_for_range_covert_optimize.go10 理解Go语言的包导入 Go要求每个源文件在开头处显式地列出所有依赖的包导入，这样Go编译器不必读取和处理整个文件就可以确定其依赖的包列表。 Go要求包之间不能存在循环依赖，这样一个包的依赖关系便形成了一张有向无环图。由于无环，包可以被单独编译，也可以并行编译。 已编译的Go包对应的目标文件（file_name.o或package_name.a）中不仅记录了该包本身的导出符号信息，还记录了其所依赖包的导出符号信息。这样，Go编译器在编译某包P时，针对P依赖的每个包导入（比如导入包Q），只需读取一个目标文件即可（比如：Q包编译成的目标文件中已经包含Q包的依赖包的导出信息），而无须再读取其他文件中的信息。 源文件头部的包导入语句import后面的部分就是一个路径，路径的最后一个分段也不是包名。不过Go语言有一个惯用法，那就是包导入路径的最后一段目录名最好与包名一致。 当包名与包导入路径中的最后一个目录名不同时，最好用下面的语法将包名显式放入包导入语句。 1234567891011// app2/main.gopackage mainimport ( mypkg2 &quot;github.com/bigwhite/effective-go-book/chapter3-demo1/pkg/pkg2&quot;)func main() { mypkg2.Func1()} Go编译器在编译过程中必然要使用的是编译单元（一个包）所依赖的包的源码。 Go编译器的包源码搜索路径由基本搜索路径和包导入路径组成，两者结合在一起后，编译器便可确定一个包的所有依赖包的源码路径的集合，这个集合构成了Go编译器的源码搜索路径空间。 同一源码文件的依赖包在同一源码搜索路径空间下的包名冲突问题可以由显式指定包名的方式解决。 理解Go语言表达式的求值顺序 包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高。 表达式操作数中的函数、方法及channel操作按普通求值顺序，即从左到右的次序进行求值。 赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按从左到右的顺序对变量进行赋值。 switch-case语句中的表达式求值属于“惰性求值”范畴。惰性求值指的就是需要进行求值时才会对表达值进行求值，这样做的目的是让计算机少做事，从而降低程序的消耗，对性能提升有一定帮助。 12345678910111213141516// chapter3/sources/evaluation_order_7.gofunc Expr(n int) int { fmt.Println(n) return n}func main() { switch Expr(2) { case Expr(1), Expr(2), Expr(3): fmt.Println(&quot;enter into case1&quot;) fallthrough case Expr(4): fmt.Println(&quot;enter into case2&quot;) }} 123456$go run evaluation_order_7.go212enter into case1enter into case2 我们再来看看select-case语句的求值。Go语言中的select为我们提供了一种在多个channel间实现“多路复用”的机制，是编写Go并发程序最常用的并发原语之一。我们通过一个例子直观看一下select-case语句中表达式的求值规则： 12345678910111213141516171819202122232425262728293031323334353637383940// chapter3/sources/evaluation_order_8.gofunc getAReadOnlyChannel() &lt;-chan int { fmt.Println(&quot;invoke getAReadOnlyChannel&quot;) c := make(chan int) go func() { time.Sleep(3 * time.Second) c &lt;- 1 }() return c}func getASlice() *[5]int { fmt.Println(&quot;invoke getASlice&quot;) var a [5]int return &amp;a}func getAWriteOnlyChannel() chan&lt;- int { fmt.Println(&quot;invoke getAWriteOnlyChannel&quot;) return make(chan int)}func getANumToChannel() int { fmt.Println(&quot;invoke getANumToChannel&quot;) return 2}func main() { select { // 从channel接收数据 case (getASlice())[0] = &lt;-getAReadOnlyChannel(): fmt.Println(&quot;recv something from a readonly channel&quot;) // 将数据发送到channel case getAWriteOnlyChannel() &lt;- getANumToChannel(): fmt.Println(&quot;send something to a writeonly channel&quot;) }} 1234567$go run evaluation_order_8.goinvoke getAReadOnlyChannelinvoke getAWriteOnlyChannelinvoke getANumToChannelinvoke getASlicerecv something from a readonly channel 如果选择要执行的是一个从channel接收数据的case，那么该case等号左边的表达式在接收前才会被求值。比如在上面的例子中，在getAReadOnlyChannel创建的goroutine在3s后向channel中写入一个int值后，select选择了第一个case执行，此时对等号左侧的表达式(getASlice())[0]进行求值，输出“invoke getASlice”，这也算是一种惰性求值。 理解Go语言代码块与作用域 Go语言中的代码块是包裹在一对大括号内部的声明和语句，且代码块支持嵌套。如果一对大括号之间没有任何语句，那么称这个代码块为空代码块。代码块是代码执行流流转的基本单元，代码执行流总是从一个代码块跳到另一个代码块。 Go语言中有两类代码块，一类是我们在代码中直观可见的由一堆大括号包裹的显式代码块，比如函数的函数体、for循环的循环体、if语句的某个分支等另一类则是没有大括号包裹的隐式代码块。 Go规范定义了如下几种隐式代码块。宇宙（Universe）代码块：所有Go源码都在该隐式代码块中，就相当于所有Go代码的最外层都存在一对大括号。包代码块：每个包都有一个包代码块，其中放置着该包的所有Go源码。文件代码块：每个文件都有一个文件代码块，其中包含着该文件中的所有Go源码。每个if、for和switch语句均被视为位于其自己的隐式代码块中。switch或select语句中的每个子句都被视为一个隐式代码块。 Go标识符的作用域是基于代码块定义的，作用域规则描述了标识符在哪些代码块中是有效的。 了解Go语言控制语句惯用法及使用注意事项 当出现错误时，快速返回。 成功逻辑不要嵌入if-else语句中。 for range的惯用法是使用短变量声明方式（:=）在for的initStmt中声明迭代变量（iteration variable）。但需要注意的是，这些迭代变量在for range的每次循环中都会被重用，而不是重新声明。这是因为根据上一条Go语言代码块和作用域规则中的说明，我们可以将for range进行等价转换： 1234var m = [...]int{1, 2, 3, 4, 5}for i, v := range m { ...} 上述代码可等价转换为： 1234567var m = [...]int{1, 2, 3, 4, 5}{ i, v := 0 for i, v = range m { ... }} 这样，我们就可以清晰地看到迭代变量的重用。 for range语句中，range后面接受的表达式的类型可以是数组、指向数组的指针、切片、字符串、map和channel（至少需具有读权限），但参与循环的是range表达式的副本。 for range对于string来说，每次循环的单位是一个rune，而不是一个byte，返回的第一个值为迭代字符码点的第一字节的位置。 当channel作为range表达式类型时，for range最终以阻塞读的方式阻塞在channel表达式上，即便是带缓冲的channel亦是如此：当channel中无数据时，for range也会阻塞在channel上，直到channel关闭。 Go语言规范中明确规定break语句（不接label的情况下）结束执行并跳出的是同一函数内break语句所在的最内层的for、switch或select的执行。要修正这一问题，可以利用Go语言为for提供的一项高级能力：break [label]。 通过case接表达式列表的方式要比使用fallthrough更加简洁和易读。因此，在程序中使用fallthrough关键字前，先想想能否使用更为简洁、清晰的case表达式列表替代。","link":"/2022/11/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/%E5%A3%B0%E6%98%8E%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"},{"title":"进程调度","text":"如何开发调度策略工作负载假设探讨可能的策略范围之前，我们先做一些简化假设。这些假设与系统中运行的进程有关，有时候统称为工作负载（workload）。确定工作负载是构建调度策略的关键部分。工作负载了解得越多，你的策略就越优化。 我们对操作系统中运行的进程（有时也叫工作任务）做出如下的假设： 每一个工作运行相同的时间。 所有的工作同时到达。 一旦开始，每个工作保持运行直到完成。 所有的工作只是用CPU（即它们不执行IO操作）。 每个工作的运行时间是已知的。 调度指标除了做出工作负载假设之外，还需要一个东西能让我们比较不同的调度策略：调度指标。 现在，让我们简化一下生活，只用一个指标：周转时间（turnaround time）。任务的周转时间定义为任务完成时间减去任务到达系统的时间。更正式的周转时间定义T周转时间是： T周转时间 = T完成时间 − T到达时间 先进先出（FIFO）我们可以实现的最基本的算法，被称为先进先出（First In First Out或FIFO）调度，有时候也称为先到先服务（First Come First Served 或FCFS）。 我们一起看一个简单的例子。想象一下，3个工作A、B和C在大致相同的时间（T到达时间 = 0）到达系统。因为FIFO必须将某个工作放在前面，所以我们假设当它们都同时到达时，A比B早一点点，然后B比C早到达一点点。假设每个工作运行10s。这些工作的平均周转时间（average turnaround time）是多少？ 从图可以看出，A在10s时完成，B在20s时完成，C在30s时完成。因此，这3个任务的平均周转时间就是（10 + 20 + 30）/ 3 = 20。 现在让我们放宽假设。具体来说，让我们放宽假设1，因此不再认为每个任务的运行时间相同。如图所示，A先运行100s，B或C才有机会运行。因此，系统的平均周转时间是比较高的：令人不快的110s（（100 + 110 + 120）/ 3 = 110）。 最短任务优先（SJF）一个非常简单的方法解决了这个问题，这个新的调度准则被称为最短任务优先（Shortest Job First，SJF），该名称应该很容易记住，因为它完全描述了这个策略：先运行最短的任务，然后是次短的任务，如此下去。 我们用上面的例子，但以SJF作为调度策略。图中展示的是运行A、B和C的结果。它清楚地说明了为什么在考虑平均周转时间的情况下，SJF调度策略更好。仅通过在A之前运行B和C，SJF将平均周转时间从110s降低到50s（（10 + 20 + 120）/3= 50）。 现在让我们放宽另一个假设。具体来说，我们可以针对假设2，现在假设工作可以随时到达，而不是同时到达。这导致了什么问题？ 从图中可以看出，即使B和C在A之后不久到达，它们仍然被迫等到A完成，从而遭遇同样的护航问题。这3项工作的平均周转时间为103.33s，即（100+（110−10）+（120−10））/3。 护航效应（convoy effect），一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。 最短完成时间优先（STCF）为了解决这个问题，需要放宽假设条件（工作必须保持运行直到完成）。SJF是一种非抢占式（non-preemptive）调度程序，因此存在上述问题。幸运的是，有一个调度程序完全就是这样做的：向SJF添加抢占，称为最短完成时间优先（Shortest Time-to-Completion First，STCF）或抢占式最短作业优先（Preemptive Shortest Job First ，PSJF）调度程序。每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。 从图中可以看出平均周转时间大大提高：50s。和以前一样，考虑到我们的新假设，STCF可证明是最优的。考虑到如果所有工作同时到达，SJF是最优的，那么你应该能够看到STCF的最优性是符合直觉的。 新度量指标：响应时间因此，如果我们知道任务长度，而且任务只使用CPU，而我们唯一的衡量是周转时间，STCF将是一个很好的策略。事实上，对于许多早期批处理系统，这些类型的调度算法有一定的意义。然而，引入分时系统改变了这一切。现在，用户将会坐在终端前面，同时也要求系统的交互性好。因此，一个新的度量标准诞生了：响应时间（response time）。 响应时间定义为从任务到达系统到首次运行的时间。更正式的定义是： T响应时间= T首次运行−T到达时间 STCF和相关方法在响应时间上并不是很好。例如，如果3个工作同时到达，第三个工作必须等待前两个工作全部运行后才能运行。这种方法虽然有很好的周转时间，但对于响应时间和交互性是相当糟糕的。假设你在终端前输入，不得不等待10s才能看到系统的回应，只是因为其他一些工作已经在你之前被调度：你肯定不太开心。因此，我们还有另一个问题：如何构建对响应时间敏感的调度程序？ 轮转为了解决这个问题，我们将介绍一种新的调度算法，通常被称为轮转（Round-Robin，RR）调度。基本思想很简单：RR在一个时间片（time slice，有时称为调度量子，scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。因此，RR有时被称为时间切片（time-slicing）。请注意，时间片长度必须是时钟中断周期的倍数。因此，如果时钟中断是每10ms中断一次，则时间片可以是10ms、20ms或10ms的任何其他倍数。 SJF： 轮转： RR的平均响应时间是：（0 + 1 + 2）/3 = 1; SJF 算法平均响应时间是：（0 + 5+ 10）/ 3 = 5。 如你所见，时间片长度对于RR是至关重要的。越短，RR在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应。 请注意，上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在CPU高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本。 我们开发了两种调度程序。第一种类型（SJF、STCF）优化周转时间，但对响应时间不利。第二种类型（RR）优化响应时间，但对周转时间不利。我们还有两个假设需要放宽：假设4（作业没有I/O）和假设5（每个作业的运行时间是已知的）。接下来我们来解决这些假设。 结合I/O调度程序显然要在工作发起I/O请求时做出决定，因为当前正在运行的作业在I/O期间不会使用CPU，它被阻塞等待I/O完成。如果将I/O发送到硬盘驱动器，则进程可能会被阻塞几毫秒或更长时间，具体取决于驱动器当前的I/O负载。因此，这时调度程序应该在CPU上安排另一项工作。 调度程序还必须在I/O完成时做出决定。发生这种情况时，会产生中断，操作系统运行并将发出I/O的进程从阻塞状态移回就绪状态。 假设有两项工作A和B，每项工作需要50ms的CPU时间。但是，有一个明显的区别：A运行10ms，然后发出I/O请求（假设I/O每个都需要10ms），而B只是使用CPU 50ms，不执行I/O。调度程序先运行A，然后运行B。 假设我们正在尝试构建STCF调度程序。显然，仅仅运行一个工作，然后运行另一个工作，而不考虑如何考虑I/O是没有意义的。 一种常见的方法是将A的每个10ms的子工作视为一项独立的工作。因此，当系统启动时，它的选择是调度10ms的A，还是50ms的B。对于STCF，选择是明确的：选择较短的一个，在这种情况下是A。然后，A的工作已完成，只剩下B，并开始运行。然后提交A的一个新子工作，它抢占B并运行10ms。这样做可以实现重叠（overlap），一个进程在等待另一个进程的I/O完成时使用CPU，系统因此得到更好的利用。 这样我们就看到了调度程序可能如何结合I/O。通过将每个CPU突发作为一项工作，调度程序确保“交互”的进程经常运行。当这些交互式作业正在执行I/O时，其他CPU密集型作业将运行，从而更好地利用处理器。 多级反馈队列（MLFQ）多级反馈队列（Multi-level Feedback Queue，MLFQ）是一种著名的调度方法。1962年，Corbato首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。 多级反馈队列需要解决两方面的问题。首先，它要优化周转时间。这通过先执行短工作来实现。然而，操作系统通常不知道工作要运行多久，而这又是SJF（或STCF）等算法所必需的。其次，MLFQ希望给交互用户（如用户坐在屏幕前，等着进程结束）很好的交互体验，因此需要降低响应时间。然而，像轮转这样的算法虽然降低了响应时间，周转时间却很差。 MLFQ：基本规则MLFQ中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ总是优先执行较高优先级的工作（即在较高级队列中的工作）。 当然，每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。 至此，我们得到了MLFQ的两条基本规则。 ● 规则1：如果A的优先级 &gt; B的优先级，运行A（不运行B）。 ● 规则2：如果A的优先级 = B的优先级，轮转运行A和B。 如果要在某个特定时刻展示队列，最高优先级有两个工作（A和B），工作C位于中等优先级，而D的优先级最低。按刚才介绍的基本规则，由于A和B有最高优先级，调度程序将交替的调度他们，可怜的C和D永远都没有机会运行，太气人了！ 尝试1：如何改变优先级我们必须决定，在一个工作的生命周期中，MLFQ如何改变其优先级（在哪个队列中）。要做到这一点，我们必须记得工作负载：既有运行时间很短、频繁放弃CPU的交互型工作，也有需要很多CPU时间、响应时间却不重要的长时间计算密集型工作。下面是我们第一次尝试优先级调整算法。 ●规则3：工作进入系统时，放在最高优先级（最上层队列）。 ● 规则4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。 ● 规则4b：如果工作在其时间片以内主动释放CPU，则优先级不变。 看一个较复杂的例子，看看MLFQ如何近似SJF。在这个例子中，有两个工作：A是一个长时间运行的CPU密集型工作，B是一个运行时间很短的交互型工作。假设A执行一段时间后B到达。会发生什么呢？对B来说，MLFQ会近似于SJF吗？ 通过这个例子，你大概可以体会到这个算法的一个主要目标：如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ近似于SJF。 假设交互型工作中有大量的I/O操作（比如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃CPU。在这种情况下，我们不想处罚它，只是保持它的优先级不变。 当前MLFQ的一些问题首先，会有饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用CPU，导致长工作永远无法得到CPU（它们饿死了）。即使在这种情况下，我们希望这些长工作也能有所进展。 其次，聪明的用户会重写程序，愚弄调度程序（game the scheduler）。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。上述算法对如下的攻击束手无策：进程在时间片用完之前，调用一个I/O操作（比如访问一个无关的文件），从而主动释放CPU。如此便可以保持在高优先级，占用更多的CPU时间。做得好时（比如，每运行99%的时间片时间就主动放弃一次CPU），工作可以几乎独占CPU。 最后，一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间表现为一个交互型的进程。用我们目前的方法，它不会享受系统中其他交互型工作的待遇。 尝试2：提升优先级一个简单的思路是周期性地提升（boost）所有工作的优先级。可以有很多方法做到，但我们就用最简单的：将所有工作扔到最高优先级队列。于是有了如下的新规则。 ● 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。 新规则一下解决了两个问题。首先，进程不会饿死——在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享CPU，从而最终获得执行。其次，如果一个CPU密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。 当然，添加时间段S导致了明显的问题：S的值应该如何设置？德高望重的系统研究员 John Ousterhout[O11]曾将这种值称为“巫毒常量（voo-doo constant）”，因为似乎需要一些黑魔法才能正确设置。如果S设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的CPU时间比例。 尝试3：更好的计时方式现在还有一个问题要解决：如何阻止调度程序被愚弄？可以看出，这里的元凶是规则4a和4b，导致工作在时间片以内释放CPU，就保留它的优先级。那么应该怎么做？ 这里的解决方案，是为MLFQ的每层队列提供更完善的CPU计时方式（accounting）。调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时。只要进程用完了自己的配额，就将它降到低一优先级的队列中去。不论它是一次用完的，还是拆成很多次用完。因此，我们重写规则4a和4b。 ● 规则4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。 MLFQ调优及其他问题关于MLFQ调度算法还有一些问题。其中一个大问题是如何配置一个调度程序，例如，配置多少队列？每一层队列的时间片配置多大？为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级？这些问题都没有显而易见的答案，因此只有利用对工作负载的经验，以及后续对调度程序的调优，才会导致令人满意的平衡。 例如，大多数的MLFQ变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如10ms或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是CPU密集型工作，配置更长的时间片会取得更好的效果。 最后，许多调度程序有一些我们没有提到的特征。例如，有些调度程序将最高优先级队列留给操作系统使用，因此通常的用户工作是无法得到系统的最高优先级的。有些系统允许用户给出优先级设置的建议（advice），比如通过命令行工具nice，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看man手册。 比例份额比例份额（proportional-share）调度程序，有时也称为公平份额（fair-share）调度程序。比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。 比例份额由于一些原因，并没有作为CPU调度程序被广泛使用。一个原因是这两种方式都不能很好地适合I/O；另一个原因是其中最难的票数分配问题并没有确定的解决方式，例如，如何知道浏览器进程应该拥有多少票数？通用调度程序（像前面讨论的MLFQ及其他类似的Linux调度程序）做得更好，因此得到了广泛的应用。比例份额调度程序只有在这些问题可以相对容易解决的领域更有用（例如容易确定份额比例）。例如在虚拟（virtualized）数据中心中，你可能会希望分配1/4的CPU周期给Windows虚拟机，剩余的给Linux系统，比例分配的方式可以更简单高效。","link":"/2022/11/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"},{"title":"Python代码格式化工具Black（转载）","text":"作者：muzing 原文链接：https://muzing.top/posts/a29e4743/ 良好的 Python 代码应有良好的格式规范（不止于遵守 PEP 8 ），使用一个更强大更专业的代码格式化工具，来替代编辑器自带的「格式化代码」功能是有一定必要的，这还可以使团队成员即使在不同编辑器下工作也可以得到完全相同的风格。相比于目前中文社区中较为流行的 autopep8，其实还有一个更好的选择 —— Black 。 Life is short, you need Python. 本文采用了较全面介绍的写法，且对相当一部分的官方文档做了摘录翻译，篇幅较长。如果只是想简单快速上手使用工具，直接阅读前面关于安装、使用的几个小节即可（这些小节前面有这样的紫色的标记提醒），跳过其他部分不会有影响。 简介 Black 的 Logo “Any color you like.” GItHub | 官方文档 | PyPI | 在线试用 Black 自称“零妥协代码格式化工具（The uncompromising code formatter）”。 截止到 2022 年 5 月，Black 已经在 GitHub 斩获 27.4k 个 Stars，由 Google 开发维护的 YAPF 为 12.5k ，而 autopep8 则只有 4.1k 。可以说 Black 是目前最广受好评的 Python 代码格式化工具。 “Talk is cheap. Show me the code.” 废话不多说，直接看疗效： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105# 格式化前from seven_dwwarfs import Grumpy, Happy, Sleepy, Bashful, Sneezy, Dopey, Docx = { 'a':37,'b':42,'c':927}x = 123456789.123456789E123456789if very_long_variable_name is not None and \\ very_long_variable_name.field &gt; 0 or \\ very_long_variable_name.is_debug: z = 'hello '+'world'else: world = 'world' a = 'hello {}'.format(world) f = rf'hello {world}'if (thisand that): y = 'hello ''world'#FIXME: https://github.com/psf/black/issues/26class Foo ( object ): def f (self ): return 37*-2 def g(self, x,y=42): return ydef f ( a: List[ int ]) : return 37-a[42-u : y**3]def very_important_function(template: str,*variables,file: os.PathLike,debug:bool=False,): &quot;&quot;&quot;Applies `variables` to the `template` and writes to `file`.&quot;&quot;&quot; with open(file, &quot;w&quot;) as f: ...# fmt: offcustom_formatting = [ 0, 1, 2, 3, 4, 5, 6, 7, 8,]# fmt: onregular_formatting = [ 0, 1, 2, 3, 4, 5, 6, 7, 8,]PYTHON# 使用 Black-v22.3.0 格式化后from seven_dwwarfs import Grumpy, Happy, Sleepy, Bashful, Sneezy, Dopey, Docx = {&quot;a&quot;: 37, &quot;b&quot;: 42, &quot;c&quot;: 927}x = 123456789.123456789e123456789if ( very_long_variable_name is not None and very_long_variable_name.field &gt; 0 or very_long_variable_name.is_debug): z = &quot;hello &quot; + &quot;world&quot;else: world = &quot;world&quot; a = &quot;hello {}&quot;.format(world) f = rf&quot;hello {world}&quot;if this and that: y = &quot;hello &quot; &quot;world&quot; # FIXME: https://github.com/psf/black/issues/26class Foo(object): def f(self): return 37 * -2 def g(self, x, y=42): return ydef f(a: List[int]): return 37 - a[42 - u : y**3]def very_important_function( template: str, *variables, file: os.PathLike, debug: bool = False,): &quot;&quot;&quot;Applies `variables` to the `template` and writes to `file`.&quot;&quot;&quot; with open(file, &quot;w&quot;) as f: ...# fmt: offcustom_formatting = [ 0, 1, 2, 3, 4, 5, 6, 7, 8,]# fmt: onregular_formatting = [ 0, 1, 2, 3, 4, 5, 6, 7, 8,] 经过 Black 重新格式化后，代码立刻就清爽舒适了很多。事实上，Black 有一套经过反复讨论、仔细研究得出的非常详尽的 Python 代码格式化风格，在本文的后面也会展开来讲（见 The Black Code Style 一节）。 安装本节为快速上手必看 可以通过 pip 直接从 PyPI 下载安装： 1pip install black 注意需要 Python 3.6.2 以上的版本。 如果想在 Jupyter Notebooks 中使用，则可以通过如下代码安装： 1pip install black[jupyter] 如果急于试用最新版本，可以通过下面的命令从 GitHub 安装（不推荐）： 1pip install git+git://github.com/psf/black 简单使用本节为快速上手必看 作为脚本运行1black {source_file_or_directory} 作为 Python 包运行如果将 Black 作为脚本运行不起作用，您可以尝试将其作为包运行： 1python -m black {source_file_or_directory} 跳过字符串格式化Black 会默认将字符串格式化为使用双引号包裹，但有些项目已经使用了单引号的规范且不应修改为双引号，就需要加上一个 -S / --skip-string-normalization 的选项。 1black -S {source_file_or_directory} 其他更多选项见 详细使用 - 命令行选项 一节 集成到 IDE / 编辑器中本节为快速上手必看 相比于每次都专门打开一个终端，手动使用命令行调用 Black 格式化代码，我们更希望能把 Black 集成到我们常用的 IDE / 编辑器中，不需要离开写代码的界面即可完成格式化操作。 在 PyCahrm 中使用Black 官方文档中给出了在 PyCharm（或 IntelliJ IDEA）中配置使用 Black 的方法： 确认 Black 安装位置在 macOS / Linux / BSD 上： 12$ which black/usr/local/bin/black # 可能的位置 在 Windows 上： 12$ where black%LocalAppData%\\Programs\\Python\\Python36-32\\Scripts\\black.exe # 可能的位置 如果是使用 Pycahrm 建立的虚拟环境，则直接使用 $PyInterpreterDirectory$/black 作为程序路径。 在 PyCharm 中添加外部工具打开 文件 -&gt; 设置 -&gt; 工具 -&gt; 外部工具 File -&gt; Settings -&gt; Tools -&gt; External Tools 打开设置-工具-外部工具 创建工具 名称：Black 描述：毫不妥协的 Python 代码格式化工具 程序：「上一小节得到的安装位置」 参数：$FilePath$ 工作目录：$ProjectFileDir$ 编辑创建工具 如果需要自定义其他选项，写在 $FilePath$ 前即可，比如代表「取消格式化字符串为双引号包裹”」的选项 -S： 加上其他选项参数 使用在已经打开的代码编辑界面（或项目文件树的某个目录上）鼠标右键，找到 External Tools -&gt; Black，点击即可。 在右键菜单中使用 Black 设置快捷键还可以在 设置 -&gt; 键盘映射 -&gt; 外部工具 -&gt; Black 上右键，打开编辑快捷键的菜单，添加键盘快捷键： 设置快捷键 如果已经习惯了 PyCharm 默认的Ctrl + Alt + L 快捷键格式化代码，那么可以这样设置： 在 主菜单 -&gt; 代码 -&gt; 重新格式化代码 中删去快捷键 给 外部工具 -&gt; External Tools -&gt; Black 设置键盘快捷键Ctrl + Alt + L 保存文件时自动格式化（可选） 确保已经安装了 File Watchers 插件 进入 设置 -&gt; 工具 -&gt; File Watchers，点击 + 以添加一个新的 watcher： Name: Black File type: Python Scope: Project Files Program: 上一小节得到的安装位置 Arguments: $FilePath$ Output paths to refresh: $FilePath$ Working directory: $ProjectFileDir$ 在高级选项中： 取消勾选 “Auto-save edited files to trigger the watcher” 取消勾选 “Trigger the watcher on external changes” 在 VS Code 中使用VS Code 官方文档介绍 安装 Python 插件首先确保已经在 VS Code 中安装了 Python 插件。如果没有安装，则在 VS Code 中按下 Ctrl + P ，并输入如下命令： 1ext install ms-python.python 或者直接在扩展商店中搜索 Python 并安装。 在 VS Code 中安装 Python 插件 配置 Python 扩展按下 Ctrl + , ，打开 VS Code 设置 打开 VS Code 设置 在「设置」中搜索 python formatting provider ，然后把默认的 autopep8 改为 black 即可。 更改 Python Formatting Provider 保存文件时自动格式化代码（可选）在「设置」界面搜索 format on save ，可以勾选打开保存时格式化文件的功能。 保存时自动格式化 取消格式化为双引号包裹字符串（可选）在「设置」界面的右上角打开 settings.json 配置文件 打开 json 配置文件 在配置文件中添加一行 123&quot;python.formatting.blackArgs&quot;: [ &quot;--skip-string-normalization&quot; ] 添加一行 Black 运行选项 注意每个人的 settings.json 配置文件都有所不同，行号不太一样，在文件末尾新建一行添加即可。 使用 Black Formatter 插件微软官方出品的 Python 扩展体积日渐增长，故微软也在逐渐将其部分功能拆分为单独的扩展。目前 Black Formatter 扩展已经以预发布状态上线 VS Code 插件商店。待该插件转为正式版时，本文会同步更新。 在 Vim 中使用同样可以在 Black 官方文档中找到在 Vim 中使用 Black 官方插件的方法：https://black.readthedocs.io/en/stable/integrations/editors.html#vim 更多Black 还可以集成到许多其他编辑器中。此外，官方文档还给出了集成至 GitHub Actions 中、集成至利用 pre-commit 工具实现的版本控制集成工作流中的方法，这样每次更新项目都会自动使用 Black 重新格式化代码了。 详见文档：https://black.readthedocs.io/en/stable/integrations/index.html 详细使用 摘录翻译自官方文档 Usage and Configuration - The basics Black 是一个工作良好的 Unix 风格命令行工具： 当没有原文件传入时什么都不会做 如果使用 - 作为文件名，则将会从标准输入读取并写入到标准输出 只向用户输出标准错误信息 当没有内部错误发生时，退出代码为 0 （除非使用了 --check 选项） 命令行选项Black 倾向于“独裁”，故意限制并很少添加选项，然而这却反而成了它备受赞赏的一点——既然要统一格式，就不应该有太多个性化选项。 下面列出了 Black 的 Help 输出，并尽我所能做了翻译： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677$ black --help使用： black [OPTIONS] SRC ... 零妥协的代码格式化工具。选项： -c, --code TEXT 将传入的代码作为字符串格式化。 -l, --line-length INTEGER 每行允许的字符数。 [默认值： 88] -t, --target-version [py27|py33|py34|py35|py36|py37|py38|py39] Black 的输出应该支持的 Python 版本 [默认值：每个文件自动检测] --pyi 不考虑文件扩展名，将所有输入文件格式化为 typing stubs （当使用来自标准输入的管道时很有用）。 --ipynb 不考虑文件扩展名，将所有输入文件格式化为 Jupyter Notebooks 风格（当使用来自标准输入的管道时很有用）。 -S, --skip-string-normalization 不要标准化字符串引号或前缀。 -C, --skip-magic-trailing-comma 不要将尾随逗号作为分割行的理由。 --check 不要写回文件，只返回状态。 返回代码 0 意味着没有任何改变。 返回代码 1 意味着有些文件将被重新格式化。 返回代码 123 意味着存在 internal error 内部错误。 --diff 不要写回文件， 只是使用 stdout 标准输出显示 每个文件的 diff 差异。 --color / --no-color 显示彩色的 diff。 只有当使用了`--diff` 选项才生效。 --fast / --safe 如果给定了 --fast，则跳过 temporary sanity 检查。 [默认值： --safe] --required-version TEXT 需要运行特定版本的 Black （用于在不同环境上得到同样的 结果，比如使用一个 pyproject.toml 文件）。 --include TEXT 匹配递归搜索中应包含的文件和目录的正则表达式。 空值意味着包含所有文件（无论文件名是什么）。 对所有平台上的目录使用正斜杠（在 Windows 上亦是如此）。 首先匹配要排除的项，然后匹配包含项。 [默认值： (\\.pyi?|\\.ipynb)$] --exclude TEXT 匹配递归搜索中应排除的文件和目录的正则表达式。 空值意味着不排除任何路径。 对所有平台上的目录使用正斜杠（在 Windows 亦是如此）。 首先匹配要排除的项，然后匹配包含项。 [默认值： /(\\.direnv|\\.eggs|\\.git|\\.h g|\\.mypy_cache|\\.nox|\\.tox|\\.venv|venv|\\.svn |_build|buck-out|build|dist)/] --extend-exclude TEXT 类似 --exclude，但在排除的文件和目录之上 添加了额外的文件和目录。（如果您只是想简单地添加到 默认值，这会很有用） --force-exclude TEXT 类似 --exclude，但是与此正则表达式匹配的文件和目录 将被排除，即使它们作为参数显式传递。 --stdin-filename TEXT 通过 stdin 标准输入传递时的文件名。 有助于确保 Black 在某些依赖使用 stdin 的编辑器上 尊重 --force-exclude 选项。 -q, --quiet 不向 stderr 输出非报错信息。 错误信息仍然会被输出； 使用 2&gt;/dev/null 关闭这些信息。 -v, --verbose 还向 stderr 输出文件未更改或因为排除模式被忽略的信息。 --version 显示版本并退出。 --config FILE 从 FILE 路径读取配置。 -h, --help 显示本帮助信息并退出。 代码输入选择从标准输入读取Black 支持从 stdin 标准输入中读取并格式化代码，并将结果输出至 stdout 标准输出。只需把 - 作为传入路径即可。 12345$ echo &quot;print ( 'hello, world' )&quot; | black -print(&quot;hello, world&quot;)reformatted -All done! ✨ 🍰 ✨1 file reformatted. 提示：如果您需要 Black 把 stdin 标准输入视作一个直接通过 CLI 传来的文件，请使用--stdin-filename 选项。这有助于确保 Black 在某些依赖使用 stdin 的编辑器上考虑 --force-exclude 选项。 作为字符串您也可以通过 -c / --code 选项来把代码作为字符串传递 12$ black --code &quot;print ( 'hello, world' )&quot;print(&quot;hello, world&quot;) 写回与报告默认情况下，Black 会原地重新格式化给定的文件。有时候您只需要知道 Black 将会做什么，而无需真的重新写入 Python 文件中。 有两种方式实现这个效果，分别通过各自的选项独立开启，也可以同时启用。 退出代码传递 --check 参数将使 Black 以如下代码退出： 代码 0 ：没有任何文件将被改变 代码 1 ：有些文件将被重新格式化 代码 123：出现内部错误 12345678910111213141516171819$ black test.py --checkAll done! ✨ 🍰 ✨1 file would be left unchanged.$ echo $?0$ black test.py --checkwould reformat test.pyOh no! 💥 💔 💥1 file would be reformatted.$ echo $?1$ black test.py --checkerror: cannot format test.py: INTERNAL ERROR: Black produced code that is not equivalent to the source. Please report a bug on https://github.com/psf/black/issues. This diff might be helpful: /tmp/blk_kjdr1oog.logOh no! 💥 💔 💥1 file would fail to reformat.$ echo $?123 差异比较传递 --diff 参数以使 Black 打印出差异，表明其将要做出的更改。这将会输出到 stdout 标准输出，因此很容易捕获。 使用 --color 来开启彩色差异比较。 123456789$ black test.py --diff--- test.py 2021-03-08 22:23:40.848954 +0000+++ test.py 2021-03-08 22:23:47.126319 +0000@@ -1 +1 @@-print ( 'hello, world' )+print(&quot;hello, world&quot;)would reformat test.pyAll done! ✨ 🍰 ✨1 file would be reformatted. 详细输出一般来说，Black 尽可能生成适量的输出，在使用性和简洁性之间取得平衡。默认情况下，Black 会输出已修改的文件和错误消息，再加上一个简短的摘要。 1234567$ black src/error: cannot format src/black_primer/cli.py: Cannot parse: 5:6: mport asyncioreformatted src/black_primer/lib.pyreformatted src/blackd/__init__.pyreformatted src/black/__init__.pyOh no! 💥 💔 💥3 files reformatted, 2 files left unchanged, 1 file failed to reformat. 传递 -v / --verbose 选项会让 Black 也输出有关未更改的文件或由于排除模式而被忽略的文件的信息。如果 Black 使用了配置文件，则会输出一条蓝色的消息，详细说明它正在使用哪个配置文件。 1234567891011$ black src/ -vUsing configuration from /tmp/pyproject.toml.src/blib2to3 ignored: matches the --extend-exclude regular expressionsrc/_black_version.py wasn't modified on disk since last run.src/black/__main__.py wasn't modified on disk since last run.error: cannot format src/black_primer/cli.py: Cannot parse: 5:6: mport asyncioreformatted src/black_primer/lib.pyreformatted src/blackd/__init__.pyreformatted src/black/__init__.pyOh no! 💥 💔 💥3 files reformatted, 2 files left unchanged, 1 file failed to reformat 传递 -q / --quiet 选项会让 Black 停止输出所有的非严重信息。此时错误信息仍然会输出（这可以通过 2&gt;dev&gt;null 关闭）。 12$ black src/ -qerror: cannot format src/black_primer/cli.py: Cannot parse: 5:6: mport asyncio 版本您可以使用 --version 标志来检查您已经安装的 Black 版本。 12$ black --versionblack, version 21.9b0 还提供了要求运行特定版本的选项。 1234$ black --required-version 21.9b0 -c &quot;format = 'this'&quot;format = &quot;this&quot;$ black --required-version 31.5b2 -c &quot;still = 'beta?!'&quot;Oh no! 💥 💔 💥 The required version does not match the running version! 在安装了不一定相同的版本的多个环境中运行 Black 时，这个选项非常有用。 可以在配置文件中设置此选项，以获得跨环境的一致结果。 通过文件配置 翻译自官方文档 Black 能够从 pyproject.toml 文件中读取对于特定项目其命令行选项的默认值。 这对为您的项目指定自定义 --include 和 --exclude/--force-exclude/--extend-exclude 模式特别有用。 提示：当您在问自己“我是否需要配置任何东西”时，回答是否定的。Black 的一切皆为合理的默认值。使用这些默认选项将会使您的代码符合许多其他 Black 格式的项目。 pyproject.toml 文件PEP 518 定义了 pyproject.toml 为用于存储 Python 项目构建系统需求（build system requirements）的配置文件。在 Poetry 或 Flit 的帮助下，它能够取代 setup.py 和 setup.cfg 文件。 查找路径默认情况下，Black 将从命令行上传递的所有文件和目录的公共基目录开式查找 pyproject.toml 。如果不存在，则查找父目录。当它找到文件，或者一个 .git 目录，或一个 .hg 目录，或文件系统的根目录时，则停止查找，以先找到的为准。 如果您正在从标准输入进行格式化，Black 将从当前工作目录开始查找配置。 您可以使用一个存储在您的家目录的特定位置的“全局”配置。这是一个备用配置，即当且仅当 Black 未找到上述的任何配置时才会使用。根据您的操作系统，此文件的存储位置应为： Windows： ~\\.black 类Unix系统 （Linux, MacOS等）： $XDG_CONFIG_HOME/black （如果没有设置 XDG_CONFIG_HOME 环境变量，则为 ~/.config/black） 注意，这些是 TOML 文件本身的路径（意味着它们不应该被命名为 pyproject.toml ），而不是您存储配置的目录。这里 ~ 代表您的家目录的绝对路径。在 Windows 上，这会是类似于 C:\\\\Users\\UserName 的东西。 您还可以使用 --config 选项来显示指定您想使用的特定文件。在这种情况下，Black 不会寻找任何其他文件。 如果您在运行时使用了 --verbose 选项，如果找到并使用了配置文件，您将会看到一条蓝色的消息。 请注意，blackd 将不会使用 pyproject.toml 配置。 配置格式如文件扩展名所示，pyproject.toml 是一个 TOML 文件。它包含不同工具对应的不同的部分。Black 使用 [tool.black] 部分。选项的键与命令行选项中的长名称相同。 请注意，对于正则表达式，您必须在 TOML 中使用单引号字符串。它相当于 Python 中的 r-strings 。Black 将多行字符串视为冗长的正则表达式。使用 [] 标明重要的空格字符。 一个 pyproject.toml 的例子： 123456789[tool.black]line-length = 88target-version = ['py37']include = '\\.pyi?$'extend-exclude = '''# A regex preceded with ^/ will apply only to files and directories# in the root of the project.^/foo.py # exclude a file named foo.py in the root of the project (in addition to the defaults)''' 配置项使用层级关系命令行选项具有默认值，可以在 --help 中查看（见本文上一小节）。pyproject.toml 会覆盖默认配置。而用户通过命令行输入的选项具有最高优先级，将覆盖前两者。 Black 在整个运行过程中只会使用一个 pyproject.toml 文件。 它不会查找多个文件，也不会从文件层次结构的不同级别组合配置。 The Black Code Style我将 The Black code style - Current style 英文文档全部做了翻译，感兴趣的小伙伴可以仔细阅读一下。 代码风格Black 原地重新格式化整个文件（即直接将重新格式化的结果写回并覆盖原文件）。代码风格配置可选项故意限制得很少，且很少添加新选项。除了神奇的尾随逗号（trailing comma）和保留换行符，它不会考虑以前的代码格式。以 # fmt: off 开头并以 # fmt: on 结尾的代码块，或以 # fmt: skip 结尾的行不会被重新格式化。# fmt: on/off 必须在相同级别的缩进位置。出于礼貌，它也对 YAPF 的块注释具有相同的效果。 换行方式Black 会忽略先前的格式，并对代码应用统一的空格和换行方式。空格的风格可以总结为：取悦 pycodestyle 。Black 使用的代码风格可以视为是 PEP 8 的严格子集。 对于换行，Black 试着让每一行都只有一个完整的表达式或简单语句。如果这符合指定的行长度就更好了。 12345678910# in:j = [1, 2, 3]# out:j = [1, 2, 3] 否则，Black 将查看第一个外部括号匹配的内容，并将其放在单独的缩进行中。 123456789# in:ImportantClass.important_method(exc, limit, lookup_lines, capture_locals, extra_argument)# out:ImportantClass.important_method( exc, limit, lookup_lines, capture_locals, extra_argument) 如果这仍然不符合要求，它将使用相同的规则进一步分解内部表达式，每次在匹配的括号处缩进。 如果匹配括号对的内容是逗号分隔的（如参数列表，字典文字等），那么 Black 将首先尝试将它们与对应匹配的括号保持在同一行。 如果仍然不行，它会将这些内容放在单独的行中。 1234567891011121314151617181920# in:def very_important_function(template: str, *variables, file: os.PathLike, engine: str, header: bool = True, debug: bool = False): &quot;&quot;&quot;Applies `variables` to the `template` and writes to `file`.&quot;&quot;&quot; with open(file, 'w') as f: ...# out:def very_important_function( template: str, *variables, file: os.PathLike, engine: str, header: bool = True, debug: bool = False,): &quot;&quot;&quot;Applies `variables` to the `template` and writes to `file`.&quot;&quot;&quot; with open(file, &quot;w&quot;) as f: ... Black 更喜欢括号而不是反斜杠，如果找到反斜杠则会删除： 12345678910111213141516171819202122232425# in:if some_short_rule1 \\ and some_short_rule2: ...# out:if some_short_rule1 and some_short_rule2: ...# in:if some_long_rule1 \\ and some_long_rule2: ...# out:if ( some_long_rule1 and some_long_rule2): ... 反斜杠和多行字符串是 Python 语法中最主要的破坏缩进的两项。永远不要使用反斜杠，它们用于强制换行（即在原本换行将引起语法错误的地方换行），这使得它们令人困惑且难以修改。所以 Black 极力避免反斜杠。 如果您在您的代码中使用了反斜杠，这表明您只要稍作重构就可以明显优化代码。希望上面的例子能有所启发。 右括号总是缩进，并且添加一个尾随逗号。这种格式产生更小的差异：当添加或删除一个元素时，总是只占一行。此外，使右括号在代码的两个不同部分，而不是相同的缩进级别（比如上面那个例子中的参数列表和文档字符串），使得分隔更清晰。 如果组合数据结构（元组、列表、集合、字典），或者一行 “from” 导入无法适应分配的长度，则 Black 总是把每一项拆分到单独的一行中。这最大限度地减小了差异，同时使得阅读代码的人能够找到引入特定条目的 commit 。这还使得 Black 和带有现成的 black 配置文件或手动配置的 isort 兼容。 行长度Black 默认行长度比较特殊，为每行 88 个字符，恰好比 80 多 10% 。这个行长度下的文件总长度要比坚持使用 80（最流行的），或者甚至 79 （标准库使用的）要短的多。总的来说，90 似乎是明智之选。 如果您按照自己的代码规范限制行长度，您可以通过 --line-length 传递一个较小的数字。 Black 会尽量尊重该选项。 但是，有时这会造成冲突。 在极少数情况下，自动格式化的代码行长度将超出您设置的限制。 您也可以增加行长度，但请记住，有视力障碍的人阅读超过 100 个字符的行会很困难。 这还会对典型屏幕分辨率下的并排差异审查造成不便。 太长的行也使得在文档或幻灯片中整齐地呈现代码变得更加困难。 如果您在使用 Flake8 ，您可以将 max-line-length 提高到88，然后几乎忘掉这些。但是更好的选择是使用 Bugbear 的 B950 警告替代 E501，然后提高行最大长度到 88（或者您在 Black 上使用的 --line-length），这会更和 Black 的 “尽可能尊重 --line-length ，但是达不到也不要强求” 保持一致。您会这样做： 12345[flake8]max-line-length = 88...select = C,E,F,W,B,B950extend-ignore = E203, E501 可以在本文档中进一步了解 E203 被禁用的原因。如果您对 B950 背后的原因感到好奇，Bugbear 的文档对此进行了解释。“就像高速公路上的限速，超速几迈不会有什么麻烦。” 一个最精简的、兼容 Black 的 Flake8 配置： 123[flake8]max-line-length = 88extend-ignore = E203 空白行Black 避免使用无用的空行。这是符合 PEP 8 精神的，即函数内的空行应该谨慎使用。 Black 允许在函数内有单空行，以及原编辑器中在模块级别中使用的单空行和双空行（除非它们在括号内的表达式中）。由于这些表达式总是被重新格式化以占用最小空间，所以这些空行会丢失。 Black 还会在函数定义之前和之后插入适当的空行。内部函数前后一行，模块级别的函数和类前后两行。Black 不会在函数 / 类定义和紧挨着给定函数 / 类之前的独立注释之间插入空行。 Black 将在类级别的文档字符串和第一个后续字段或方法之间强行控制为一个空行，这符合 PEP 257 。 Black 不会在函数文档字符串后插入空行，除非由于内部函数紧随其后，需要空行分隔。 注释Black 不格式化注释内容，但它会在同一行的代码和注释之间强制使用两个空格，并在注释文本开始之前添加一个空格。Black 会考虑某些需要特定间距规则的注释类型：文档注释（#: comment）、section comments with long runs of hashes、Spyder 的 cell 。有时可能因为格式更改而移动注释，这可能会破坏为其分配特殊含义的工具的执行效果。哈希运算后的不间断空格也被保留。更多讨论，请看格式化前后的 AST 一节。 尾随逗号Black 将向由逗号分隔的表达式添加尾随逗号，每个元素占据单独的一行。这包括函数声明。 添加尾随逗号的一个例外情况是，函数声明包括 *， *args，或 **kwargs。在这种情况下，尾随逗号只能在 Python 3.6 上安全使用。Black 将会检测您的文件是否已经是只兼容 3.6+ 并在这种情况下使用尾随逗号。 Black 的判断方法是，它会在带有星号的函数声明中查找 f-strings和尾随逗号的现有用法。换言之，如果您想在这种情况下使用尾随逗号而 Black 没有意识到这是安全的，那么在那里手动添加，Black 会保留它。 已经存在的尾随逗号提示 Black 始终将当前括号对的内容分解为每行一个项目。在下一小节中的神奇的尾随逗号获取更多关于此的信息。 字符串相比于单引号（ ' 和 '''）， Black 更倾向于双引号（&quot; 和 &quot;&quot;&quot;）。只要不会导致出现更多的反斜杠转义，Black 就会用双引号替换单引号。 Black 还标准化了字符串前缀，使它们始终小写。最重要的是，如果您的代码已经是只用于 Python 3.6+ ，或者使用了 unicode_literals 未来导入，Black 将会从字符串前缀中删除 u ，因为它在这些情况下毫无意义。 美观是标准化到一个单一形式的引用的主要原因。在各处都使用相同风格的引用可以减少读者注意力分散。这还将使 Black 的未来版本能够合并以同一行结尾的连续字符串文字（详细有关信息，请参阅 #26） 为何选用双引号？他们估计在英文文本中会有撇号。它们符合 PEP 257 中描述的文档字符串标准。无论使用何种字体和语法高亮，双引号（&quot;&quot;）中的空字符串都不可能与单引号混淆。最重要的是，字符串使用双引号，与 Python 经常与之交互的 C 语言一致。 在某些键盘布局（如美国英语）上，键入单引号比双引号（需要使用 Shift 键）更容易一些。 我的建议是继续使用更快的输入方式，让 Black 去处理转换。 如果您在一个存在预先已有字符串约定（例如很流行的在数据上使用单引号，人类阅读的字符串上使用双引号）的大型项目上使用 Black ，您可以在命令行上传递 --skip-string-normalization 参数。这旨在采纳意见，应该避免将其用在新项目上。 作为一个实验选项（可以通过 --experimental-string-processing 启用），Black 拆分长字符串（在适当的情况下使用括号），并合并短字符串。拆分时，不需要格式化的 f-字符串部分将转换为纯字符串。当用户创建的分割不超过行长度限制时，它们将会被保留。用于表示行继续的反斜杠将被转换为带括号的字符串。不必要的括号将被删除。由于该功能是实验性的，故强烈建议您提供反馈和问题报告！ Black 还会处理文档字符串。首先会针对引用和其中的文本更正文档字符串的缩进，但是文本中的相对缩进会被保留。每行多余的尾随空格和文档字符串末尾的不必要的新行都会被删除。所有前导制表符都转换为空格，但保留文本内的制表符。删除单行文档字符串的前导/尾随空格。 数字文字量Black 将大多数数字文字量（numeric literals）标准化为语法部分使用小写字母，数字本身使用大写字母：0xAB 替换 0XAB 、1e10 替换 1E10。 二元运算符与换行在将代码块拆分为多行时， Black 将在二元运算符之前换行。这是为了符合 PEP 8 中最近的更改：强调这种方法提高了可读性。 切片类型PEP 8 推荐将切片中的 : 视为具有最低优先级的二元运算符，并在两边留下相同数量的空格，除非一个参数被省略（例如ham[1 + 1 :]）。它建议对于“简单表达式”，: 运算符周围不要加空格（ham[lower:upper]）；对于“复杂表达式”则添加额外空格（ham[lower : upper + offset]）。Black 把变量名之外的东西都视为“复杂”（ham[lower : upper + 1]）。它还指出，对于扩展的切片操作，除非省略了一个参数（ham[1 + 1 ::]），两个 : 运算符必须拥有相同的间距。Black 始终强制执行这些规则。 这些行为可能会在 Flake8 等强制风格指导工具中引发 E203 whitespace before ':' 警告。由于 E203 不符合 PEP 8，您应该设置 Flake8 忽略这些警告。 括号在 Python 语法中，有些括号是可有可无的。任何表达式都可以用一对括号包裹组成一个原子。下面是几个有趣的例子： if (...): while (...): assert (...), (...) from X import (...) 赋值，比如： target = (...) target: type = (...) some, *un, packing = (...) augmented += (...) 在这些情况下，当整个语句适合一行时，或者如果内部表达式没有任何分隔符、可以进一步拆分，则会删除括号。如果只有一个分隔符，并且表达式以括号开头或结尾，括号也可以直接省略，因为现有的括号对无论如何都会整齐地组织表达式。否则，将添加括号。 请注意，Black 不会添加或删除任何额外的嵌套括号，为了清晰或进一步组织代码，您可能会希望使用这些括号。例如，这些括号不会被删除： 12return not (this or that)decision = (maybe.this() and values &gt; 0) or (maybe.that() and values &lt; 0) 调用链许多流行的 API（比如 ORM）使用调用链。这种 API 风格以流畅的接口闻名。Black 通过将调用或索引操作后面的点视作优先级非常低的分隔符来格式化这些代码。啰嗦无益，直接看代码： 12345678910def example(session): result = ( session.query(models.Customer.id) .filter( models.Customer.account_id == account_id, models.Customer.email == email_address, ) .order_by(models.Customer.id.asc()) .all() ) 存根文件PEP 484 描述了 Python 中类型提示的语法。类型的用例之一是，为不能直接包含它们的模块提供类型注释（它们可能是用 C 编写的，或者它们可能是第三方的，或者它们的实现可能过于动态，等等）。 为了解决这个问题，可以使用以.pyi为文件扩展名的存根文件来描述外部模块的类型信息。这些存根文件省略了它们描述的类和函数的实现，而是只包含文件的结构（列出全局变量、函数和类及其成员）。这些文件的推荐代码风格比 PEP 8 更简洁： 倾向于让 ... 与类/函数签名处于同一行； 避免在单个类中的连续模块级函数、名称或方法和字段之间出现垂直空白； 在顶级类定义之间使用一个空行，如果类非常小，则不使用。 Black 执行上述规则。目前尚未有强制性的格式化 .pyi 文件的指南，但可能会出现在格式化程序的未来版本中： 所有的函数体都应该是空的（包含 ... 而不是函数体）； 不使用文档字符串； 相比 pass 更倾向于使用 ... ； 对于带有默认值的参数，使用 ... 而不是实际的默认值； 避免在类型注释中使用字符串文字，存根文件本身支持前向引用（如带有 from __future__ import annotations 的 Python 3.7 代码）； 使用变量注释而不是类型注释，即使是针对旧版本 Python 的存根； 对于默认为 None 的参数，显式使用 Optional[] ； 使用 float 替换 Union[int, float] 。 实用主义早期版本的 Black 在某些方面是绝对主义者，紧跟最初作者的步伐。这在当时很好，使实现更简单，而且当时本来也没有多少用户。没有收到很多边缘案例的报告。作为一个成熟的工具，Black 确实对它的规则做了一些例外处理。本节记录了这些例外，以及其发生的原因。 神奇的尾随逗号Black 在进行格式化时，通常不考虑已有的格式。 然而在某些情况下，您在代码中写了一个简短的集合或函数调用，但您估计未来会添加新的项，例如： 1234TRANSLATIONS = { &quot;en_us&quot;: &quot;English (US)&quot;, &quot;pl_pl&quot;: &quot;polski&quot;,} 早期版本的 Black 通常会简单粗暴直接将它们折成一行（这很合适！）。现在。您可以通过自己在集合中放一个尾随逗号来表明您不希望这样。当您这样做时，Black 会总是将集合的每一项放在单独的一行中。 停用该特性的方法也很简单，只要删去尾随逗号，Black 就会在合适的情况下把您的集合折叠到一行中。 如果有必要，您可以使用 --skip-magic-trailing-comma / -C 选项来使得 Black 恢复早期版本的处理方式。 r”strings” 与 R”strings”Black 将字符串引号和字符串前缀标准化并使其小写。 此规则的一个例外是 r-strings 。 事实证明，非常流行的 MagicPython 语法高亮器（GitHub、VS Code 等默认使用的都是这个），区分 r-strings 和 R-strings。 前者是作为正则表达式突出显示的语法，而后者被视为没有特殊语义的真正原始字符串。 格式化前后的 AST 译者注：AST，即 Abstract syntax Trees，抽象语法树 当使用了 --safe 选项运行时，Black 会检查前后的代码在语义上是否相同。此检查是通过将源 AST 与目标 AST 进行比较来完成的。在三种有限的情况下，AST 确实有所不同： Black 清除文档字符串的前导和尾随空格，在必要情况下重新缩进。这是格式化程序最流行的用户报告功能之一，用于修复文档字符串的空白问题。虽然结果在技术上是 AST 差异，但由于形成文档字符串的各种可能性，我们知道的所有实时使用文档字符串都会清理缩进和前导/尾随空格。 Black 管理某些语句的可选括号。在 del 声明情况下，包装括号的有无会改变结果的 AST，但在解释器中语义是等效的。 Black 可能会移动注释，包括类型注释。这是 Python 3.8 中 AST 的一部分。虽然 Black 为这些注释实现了许多特殊情况，但不能保证它们将保持在源代码中的位置。注意这不会改变源代码运行时的行为。 从长远来看，代码等价性检查是 Black 的一个特性，其他格式化程序根本没有实现这个特性。对我们来说，确保代码在重新格式化之前的行为方式至关重要。我们将此视为一项特性，并且未来也不会懈怠。上面列举的例外来自于用户反馈或工具的实现细节。在每种情况下，我们都进行了审慎检查，以确保 AST 差异没有实际影响。 其他在 README 中展示如果你的项目使用了 Black 工具，可以在 README.md 中加入下面一行 1[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black) 这样就可以显示一个 shields 图标了：![Code style: black](Python代码格式化工具Black/code style-black-000000.svg) 吃瓜：单引号？双引号关于字符串应该用单引号还是双引号包裹，Black 的开发组成员和一些用户有不同的意见。在早先的版本中，Black 强制使用双引号，且用户无法自行修改。于是他们足足在 Issue 里“吵”了一百多楼，各种引经据典，据理力争……终于开发组不得不妥协，勉为其难的给出了一个不格式化字符串引号的选项。 GitHub 原楼请戳 关于代码风格格式化的一点讨论作为一个比较好学的 Python 小白，我从很早的时候就已经仔细阅读了 PEP 8，并利用 PyCharm 中自动检查规范自己的代码，深信代码首先是写给人看的，其次才是写给机器运行的。 在阅读 Black 文档时，我看到了这样一段话： Pro-tip: If you’re asking yourself “Do I need to configure anything?” the answer is “No”. Black is all about sensible defaults. Applying those defaults will have your code in compliance with many other Black formatted projects. 进阶提示：当您在问自己“我是否需要配置任何东西”时，回答是否定的。Black 的一切皆为合理的默认值。使用这些默认选项将会使您的代码符合许多其他 Black 格式的项目。 Black 的精神似乎是 “less is more”，首先制定一套非常详细完备的标准，然后大家只需要使用该标准即可（还是傻瓜式操作），不需要也非常不建议搞“自定义”而破坏统一性。对于我这种一共也没写过几万行代码，也谈不上个人代码风格的小白是很大的福音：已经有人替我斟酌考虑好了细节，直接使用即可获得美观度一流的代码，何乐而不为呢？","link":"/2022/11/10/Python/Python%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7Black/"}],"tags":[{"name":"待办","slug":"待办","link":"/tags/%E5%BE%85%E5%8A%9E/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Go","slug":"Go","link":"/tags/Go/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"tcpdump","slug":"tcpdump","link":"/tags/tcpdump/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找算法","slug":"二分查找算法","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"},{"name":"双指针算法","slug":"双指针算法","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"},{"name":"回溯法","slug":"回溯法","link":"/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Go语言精进之路","slug":"Go语言精进之路","link":"/tags/Go%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"操作系统导论","slug":"操作系统导论","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"},{"name":"自控力","slug":"自控力","link":"/tags/%E8%87%AA%E6%8E%A7%E5%8A%9B/"},{"name":"宏观经济通识课","slug":"宏观经济通识课","link":"/tags/%E5%AE%8F%E8%A7%82%E7%BB%8F%E6%B5%8E%E9%80%9A%E8%AF%86%E8%AF%BE/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"}],"categories":[{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"编程语言","slug":"计算机基础/编程语言","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Go","slug":"计算机基础/编程语言/Go","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/"},{"name":"PHP","slug":"计算机基础/编程语言/PHP","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PHP/"},{"name":"数据库","slug":"计算机基础/数据库","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据结构","slug":"计算机基础/数据结构","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计算机组成原理","slug":"计算机基础/计算机组成原理","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"算法","slug":"计算机基础/算法","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机基础/计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"MySQL","slug":"计算机基础/数据库/MySQL","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"},{"name":"计算机","slug":"读书笔记/计算机","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"心理","slug":"读书笔记/心理","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BF%83%E7%90%86/"},{"name":"经济理财","slug":"读书笔记/经济理财","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%BB%8F%E6%B5%8E%E7%90%86%E8%B4%A2/"},{"name":"Python","slug":"计算机基础/编程语言/Python","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"}],"pages":[]}